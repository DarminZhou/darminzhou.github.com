<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java知识增强]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E7%9F%A5%E8%AF%86%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[每日一考！ 倒排索引 讲讲redis里面的哈希表？ happen-before的规则？ volatile修饰符，synchronize锁 java单例模式的实现，懒汉、饿汉？ 进程与线程的区别，多进程和多线程的区别？ HashMap原理，为什么用红黑树，红黑树的特点？ 快排时间空间复杂度，最好最坏的情况，优化方案？ TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？ 讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？ 讲一下最大堆和最小堆 LRU算法实现（伪代码） 链表倒数第K个数（讲思路） 一堆螺丝和螺母用最短时间匹配（代码实现） 求每天浏览页面的新用户（Hive QL实现） 求抖音小视频每日点击量最高的10个（Hash + 最小堆）]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次NZJ]]></title>
    <url>%2F2019%2F05%2F13%2F%E7%AC%AC%E4%B8%80%E6%AC%A1NZJ%2F</url>
    <content type="text"><![CDATA[入我厂第一次沟，以后还需更加努力。.23333]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点锦集]]></title>
    <url>%2F2019%2F04%2F13%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E9%94%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[知识锦集 hashMap原理，java8做的改变从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。ConcurrentHashMap线程安全。解决碰撞：当出现冲突时，运用拉链法，将关键词为同义词的结点链接在一个单链表中，散列表长m，则定义一个由m个头指针组成的指针数组T，地址为i的结点插入以T(i)为头指针的单链表中。Java8中，冲突的元素超过限制（8），用红黑树替换链表。 String 和 StringBuilder 的区别1）可变与不可变：String不可变，每一次执行“+”都会新生成一个新对象，所以频繁改变字符串的情况中不用String，以节省内存。2）是否多线程安全：StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。StringBuffer和String均线程安全。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想]]></title>
    <url>%2F2019%2F04%2F10%2F%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[又到了一年一度域名续费的日子了加入我厂也有大半年了，从一开始忙到飞起，体验做不完的活，每次想起这个就想到陈老师给形容的：工作就像打仗一样。入我厂从一名Test做起，慢慢才开始做起开发，最近还搞起了设计，学到了Linux，sh，sql，angular，这些之前都很少接触，入我司半年，也算是小有所得。记得刚来的时候，住的特别挫，居然租了一个10楼无电梯的小房子，OMG，想起去年脚扭伤了，泽林和华哥送我上楼，然后好几天都没下来过，不是不想下来看医生，是根本下不来…2333，确实没必要租这么挫的房子，后面在要排到百草园的前夕，实在是受不了，拔草了后面一栋的三楼一个房子，光线不错，不过下水系统设计的很随意，又排起了百草园的队。。。2333都是泪。从去年年底开始看房子，到现在还没定好房子，发现钱在这个大件面前，真的好不值钱，想买的买不起，买的起的太郊区了，浪费钱。 博客好久没写了，还是好好学习吧，域名就不续了，除了自己访问一下，貌似也没啥用！]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人人懂AI]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BA%BA%E4%BA%BA%E6%87%82AI%2F</url>
    <content type="text"><![CDATA[人人懂AI入门学习！ 神经网络M-P Model多参数，多权重学习模型 单层感知器：输入就输出的 多层感知器深度网络的前身。输入层–隐含层–输出层 Back Propagetion Algorithm前向计算输出，比较期望输出，得到误差，然后反向调整权项值，逼近阈值。 可以做车牌识别， 局限性：训练过程，局部最小，不是全局最小，收敛不了。和初始点选择有关，和全局下降速率有关。]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本学习与演练]]></title>
    <url>%2F2018%2F10%2F14%2Fshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BC%94%E7%BB%83%2F</url>
    <content type="text"><![CDATA[平时经常接触Linux的操作指导，是不是可以写个脚本一键式解决这些繁琐的操作呢？ok 写一个简单脚本123456789vi test1.sh······························test1.sh#! /bin/bashecho "Hello !"······························chmod +x ./test1.sh./test1.sh shell 变量1234your_name="zzz"echo $your_nameyour_name="cccc"echo $your_name 字符串里写变量123your_name='aaa'str="Hello, you are \"$your_name\"!"echo $str 数组123456789101112131415array_name=(value0 value1 value2 value3)# orarray_name=(value0value1value2value3)# 单个valuen=$&#123;array_name[n]&#125;# 所有元素echo $&#123;array_name[@]&#125; 运算123456#!/bin/bash# 不是单引号 是斜引号val=`expr 4 + 2`echo "and : $val"]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之广度优先搜索算法]]></title>
    <url>%2F2018%2F08%2F12%2FJava%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[BFS，全称是Breadth First Search。 简单说就是图搜索算法。 Word LadderGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence frombeginWord to endWord, such that: Only one letter can be changed at a timeEach intermediate word must exist in the word listFor example, Given:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,return its length 5. Note: Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters. 简单来说就是从一个单词出发，每次只改变一个字母，直到变到最后一个单词，求最短路径。 再简单点思考就是 hit—&gt;hot—&gt;lot/dot—&gt;log/dog—&gt;cog 思路就是用两个set,一个存老的单词，如果添加进路径，就删除；一个存路径。 循环终止条件是路径匹配到尾巴的目标单词； 关键代码12345678910111213141516171819202122232425262728293031public int ladderLen(String beginWord ,String endWord ,List&lt;String&gt; wordList)&#123; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Set&lt;String&gt; visited = new HashSet&lt;&gt;; visited.add(beginWord); int len=1; //开始计算路径与清楚单词集合里的单词 //算法终止条件 while(!visited.contains(endWord))&#123; Set&lt;String&gt; temp = new HashSet&lt;&gt;(); for(String word:visited)&#123; for(int i=0;i&lt;word.length;i++)&#123; char[] chars=word.toCharArray(); for(int j=(int)'a';j&lt;(int)'z'+1;j++)&#123; chars[i]=(char)j; String newWord=new String(chars); if(wordSet.contains(newWord))&#123; temp.add(newWord); wordSet.remove(newWord); &#125; &#125; &#125; &#125; len += 1; if(temp.size()==0)&#123; return 0; &#125; vistied=temp; &#125; return len;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之排序算法]]></title>
    <url>%2F2018%2F08%2F06%2FJava%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序，各种排序~ 桶排序First Missing PositiveGiven an unsorted integer array, find the first missing positive integer. For example, given [1,2,0] return 3 and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 分析：本质上是桶排序，每当A[i]!=i+1时，A[i]与A[A[i]-1]交换，终止条件是A[i]==A[A[i]-1]. 12345678910111213141516171819202122232425public int firstMissingPositive(int [] nums)&#123; bucket_sort(nums); for(int i=0;i&lt;nums.length;++i)&#123; if(nums[i]!=(i+1))&#123; return i+1; &#125; return nums.length+1; &#125; private static void bucket_sort(int [] A)&#123; final int n=A.length; for(int i=0;i&lt;n :i++)&#123; while(A[i]!=i+1)&#123; if(A[i]&lt;1 || A[i]&gt;n || A[i]==A[A[i]-1]) break; int temp = A[i]; A[i]=A[temp-1]; A[temp-1]=temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之二叉树算法]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二叉树算法 二叉查找树Validate Binary Search Tree 验证二叉搜索树Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. 思路，用递归，左&lt;根&lt;右 &amp;&amp; 左根递归 &amp;&amp; 右根递归关键代码1234567891011public boolean isValidBST(TreeNode root)&#123; return isValidBST(root,INT_MIN,INT_MAX);&#125;bool isValidBST (TreeNode* root,int lower ,int upper )&#123; if(root == nullptr) return true; return root.val&gt;lower &amp;&amp; root.val&lt;upper &amp;&amp; isValidBST(root.left,lower,root.val) &amp;&amp; isValidBST(root.right,root.val,upper);&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之数组算法]]></title>
    <url>%2F2018%2F07%2F26%2FJava%E4%B9%8B%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组是常见的算法题，所以多做题，多总结，总是能找到idea的。 Product of Array Except SelfGiven an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 思路：首先，介绍方法： [1,a1,a12,a123].*[a234,a34,a4,1]=[a234,a134,a124,a123]这个算法有个O(1)的思路:就是用常数的方法，从左边乘到右边，再取一个常数，从右边乘到左边 1234567891011121314//关键算法段left[0]=1;for(int i=1;i&lt;num.length;++i)&#123; left[i]=left[i-1]*num[i-1];&#125;int right=1;for(int i=num.length-1;i&gt;=0;i--)&#123; left[i]*=right; //right 初始为1，每次乘完再迭代 right*=num[i];&#125;return left;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Essence]]></title>
    <url>%2F2018%2F07%2F24%2FEssence%2F</url>
    <content type="text"><![CDATA[生活珠玑~ 尽量结合兴趣，选准方向，不要动摇，深入研究。 和牛人共事，和善良的人交友。 从此刻起，加上思考，梳理手头的todolist，把最重要的工作找出来，全身心突出亮点。 不问别人为什么，多问自己凭什么！ —by 2018/8/9 健康 不要熬夜，尽量少熬夜 锻炼身体 不抽烟，少饮酒 注意日常行为姿势 多吃健康食品，少吃外卖 不要用眼过度，注意眼睛的休息 注重心理健康 定期体检 生活 建造强大的内心 尽早有理财念头 多出去走走 平和的心态面对一切 喜欢的东西要攒钱买下来 不要以为自己吃不胖 心本善，但是要有提防人的心 社交 增加自身的价值(有效社交) 不要盲目社交 注重对方的需求，不要一味索取 要多和人进行高质量的交流 不要勉强自己合群 分清自己的社交关系深浅 去掉一切不必要的应酬和饭局 不要急切的表达自己的观点，多听少说 人生 尽早做好人生规划(短期、长期) 建立正确的三观(学习、思考、实践) 趁年轻抓紧努力 要有自己的核心竞争力 别因为懒惰放弃能抓住的机会和挑战 要真正了解自己 别怕犯错和失败 不要自作聪明，恃才傲物 承担责任(社会、工作、家庭、自己的选择) 不要怕事，但别主动惹事 尽早进入社会历练 找到正确的平台比能力更重要 学会拒绝 不要轻易跳槽，但每次都要更上一个台阶 工作尽可能积累资源 要忠于自己，再忠于工作和公司 适当的妥协不丢人 要有长远的眼光，不要总是盯着眼前的利益 学习 勤学勤思考 多读书，广读书，读好书 迷茫的时候就学习 要有自己的专精 少刷手机 操作系统、网络、算法数据结构、离散数学、数据库原理与实践，这些看起来枯燥而无味的基础科学，要了解它们是必须付出非常多的时间才有可能理解通透些。而这些基础的扎实程度，就直接决定了你的高度。]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>观点与感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Hadoop权威指南》 Notes]]></title>
    <url>%2F2018%2F07%2F08%2F%E3%80%8AHadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-Notes%2F</url>
    <content type="text"><![CDATA[业余读书笔记1 初识HadoopHadoop项目简述 Common 一组分布式文件系统和通用I/O的组件与接口(序列化、Java RPC 和持久化数据结构)。 Avro 一种支持高效、跨语言的RPC以及永久存储数据的序列化系统。 MapReduce 分布式数据处理模型和执行环境，运行于大型商用机集群。 HDFS 分布式文件系统，运行于大型商用机集群。 Pig 一种数据流语言和运行环境，用以检索非常大的数据集。Pig运行在MapReduce和HDFS的集群上。 Hive 一个分布式、按列存储的数据仓库。Hive管理HDFS中存储的数据，并提供基于SQL的查询语言以查询数据。 HBase 一个分布式、按列存储数据库。 ZooKeeper 一个分布式、可用性高的协调服务。 Sqoop 在数据库和HDFS之间高效传输数据的工具。 关于MapReduce数据处理方法 将输入数据分成固定大小的块，然后把每块分配到各个进程，这样一来，即使有些进程能处理更多数据，我们也可以为他们分配更多的数据。 对每块数据进行处理，取每块中的最大值，作为每块的最高标准。 多台机器如何处理协调性和可靠性的问题。 查找最高气温的方法论 Hadoop自身提供一套可优化网络序列化传输的基本类型，在org.apache.hadoop.io包中。 map()方法的输入时一个键和一个值，首先将包含有一行输入的text值转换成java的String类型，之后使用subString()方法提取感兴趣的列。 map()方法还提供了OutputCollector实例用于输出内容的写入，在这种情况下，将年份按照Text对象进行读写，将气温值封装在IntWritable类型中。 测试气温数据是否缺失or显示为正确的气温读数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程实战]]></title>
    <url>%2F2018%2F06%2F16%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[基于《Java并发编程实战》，作者Brain等。 任务执行顺序执行SingleThreadWebServer顺序处理他的任务：接收到达80端口的HTTP请求123456789class SingleThreadWebServer&#123; public static void main(String [] args)throws IOException&#123; ServerSocket socket = new ServerSocket(80); while(true)&#123; Socket connection = socket.accept(); handleRequest(connection); &#125; &#125;&#125; 无限创建线程的缺点 线程生命周期的开销 资源消耗量、尤其是内存 稳定性差]]></content>
      <categories>
        <category>开发者手册</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现彩色二维码]]></title>
    <url>%2F2018%2F05%2F02%2FJava%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用Zxing库实现彩色二维码的生成，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.QRCodeWriter;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import com.google.zxing.qrcode.encoder.Encoder;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.util.Hashtable;import java.util.Map;import java.util.Random;public class TexturedEncoderHandler &#123; /** * 编码 * @param contents * @param width * @param height * @param imgPath */ public void encode(String contents, int width, int height, ErrorCorrectionLevel level, String imgPath) &#123; Hashtable&lt;EncodeHintType, Object&gt; hints = new Hashtable&lt;EncodeHintType, Object&gt;(); // 指定纠错等级 hints.put(EncodeHintType.ERROR_CORRECTION, level); // 指定编码格式 hints.put(EncodeHintType.CHARACTER_SET, "GBK"); try &#123; int [][] bitMatrix = new QRCodeWriter().encode(contents, BarcodeFormat.QR_CODE, width, height, hints); int len=bitMatrix.length; width=len*12; boolean [][]matrixBoo=new boolean[width][width]; MyPic(bitMatrix,matrixBoo,imgPath); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void MyPic(int [][] bitmatrix,boolean [][] matrixboo,String pathname) throws IOException &#123; BufferedImage matrix = new BufferedImage(matrixboo.length , matrixboo[0].length, BufferedImage.TYPE_INT_ARGB); Random rand = new Random(); for(int i=0;i&lt;bitmatrix.length;i++)&#123; for(int j=0;j&lt;bitmatrix[0].length;j++)&#123; if(bitmatrix[i][j]==1)&#123; int rr= rand.nextInt(255); int gg= rand.nextInt(255); int bb= rand.nextInt(255); Color color = new Color(rr, gg, bb); int colorInt = color.getRGB(); for(int n=i*12;n&lt;(i+1)*12;n++)&#123; for(int m=j*12;m&lt;(j+1)*12;m++) &#123; matrixboo[n][m] = true; matrix.setRGB(n, m, colorInt ); &#125; &#125; &#125; &#125; &#125; ImageIO.write(matrix, "PNG", new File(pathname)); &#125; /** * @param args */ public static void main(String[] args) &#123; long startTime=System.currentTimeMillis(); String imgPath = "guangzhou.jpg"; String contents = "guangzhou"; int width = 300, height = 300; ErrorCorrectionLevel level=ErrorCorrectionLevel.L; TexturedEncoderHandler handler = new TexturedEncoderHandler(); handler.encode(contents, width, height, level, imgPath); long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间： "+(endTime-startTime)+"ms"); &#125;&#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java 二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2F2018%2F04%2F25%2FHTTP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[服务器意图 GET：获取资源，用来请求已经被URI识别的资源 POST：传输实体主体 PUT：传输文件 HEAD：获得报文首部 DELETE：删除文件 OPTIONS：询问支持的方法 状态码 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错]]></content>
      <categories>
        <category>理解计算机</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算基础]]></title>
    <url>%2F2018%2F04%2F25%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[云计算分类 IaaS 基础设施即服务 PaaS 平台即服务 SaaS 软件即服务 公有云公有云构建在互联网上，任何已付费的用户都可以访问。 私有云私有云构建在局域网内部，属于一个独立的组织。 混合云混合云由公有云和私有云共同构成]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Notes]]></title>
    <url>%2F2018%2F04%2F23%2FHexo%20Notes%2F</url>
    <content type="text"><![CDATA[遇到的小问题 关于设置页宽没错，这就是我上面提到的那个主题，这个主题有三种外观，其中我现在使用的是 Pisces Scheme ，但还是做了一些修改，因为原来那个宽度太小了，不适合展示代码块，也不太美观。修改方法如下：Pisces 的布局定义在 source/css/_schemes/Picses/_layout.styl 中，打开文件并在最后添加以下 css引用自 http://www.aidansu.com/2017/github-pages-build-blog/123456789101112131415161718192021222324252627.header&#123; width: 80%; +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125;.container .main-inner &#123; width: 80%; +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125;.content-wrap &#123; width: calc(100% - 260px); +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125;]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 运动模糊]]></title>
    <url>%2F2018%2F04%2F23%2FJava-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A%2F</url>
    <content type="text"><![CDATA[想用Java 写个运动模糊的效果，无奈本人水平有限，国内也没找到资源，于是Google到了一个文档，特地分享出来！ 本代码源自 http://www.jhlabs.com/ip/blurring.html Java运动模糊算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import java.awt.*;import java.awt.geom.*;import java.awt.image.*;public class MotionBlurOp extends AbstractBufferedImageOp &#123; private float centreX = 0.5f, centreY = 0.5f; private float distance=20.0f; //这里设置运动距离 private float angle; private float rotation; private float zoom; public MotionBlurOp() &#123; &#125; public MotionBlurOp( float distance, float angle, float rotation, float zoom ) &#123; this.distance = distance; this.angle = angle; this.rotation = rotation; this.zoom = zoom; &#125; public void setAngle( float angle ) &#123; this.angle = angle; &#125; public float getAngle() &#123; return angle; &#125; public void setDistance( float distance ) &#123; this.distance = distance; &#125; public float getDistance() &#123; return distance; &#125; public void setRotation( float rotation ) &#123; this.rotation = rotation; &#125; public float getRotation() &#123; return rotation; &#125; public void setZoom( float zoom ) &#123; this.zoom = zoom; &#125; public float getZoom() &#123; return zoom; &#125; public void setCentreX( float centreX ) &#123; this.centreX = centreX; &#125; public float getCentreX() &#123; return centreX; &#125; public void setCentreY( float centreY ) &#123; this.centreY = centreY; &#125; public float getCentreY() &#123; return centreY; &#125; public void setCentre( Point2D centre ) &#123; this.centreX = (float)centre.getX(); this.centreY = (float)centre.getY(); &#125; public Point2D getCentre() &#123; return new Point2D.Float( centreX, centreY ); &#125; private int log2( int n ) &#123; int m = 1; int log2n = 0; while (m &lt; n) &#123; m *= 2; log2n++; &#125; return log2n; &#125; public BufferedImage filter( BufferedImage src, BufferedImage dst ) &#123; if ( dst == null ) dst = createCompatibleDestImage( src, null ); BufferedImage tsrc = src; float cx = (float)src.getWidth() * centreX; float cy = (float)src.getHeight() * centreY; float imageRadius = (float)Math.sqrt( cx*cx + cy*cy ); float translateX = (float)(distance * Math.cos( angle )); float translateY = (float)(distance * -Math.sin( angle )); float scale = zoom; float rotate = rotation; float maxDistance = distance + Math.abs(rotation*imageRadius) + zoom*imageRadius; int steps = log2((int)maxDistance); translateX /= maxDistance; translateY /= maxDistance; scale /= maxDistance; rotate /= maxDistance; if ( steps == 0 ) &#123; Graphics2D g = dst.createGraphics(); g.drawRenderedImage( src, null ); g.dispose(); return dst; &#125; BufferedImage tmp = createCompatibleDestImage( src, null ); for ( int i = 0; i &lt; steps; i++ ) &#123; Graphics2D g = tmp.createGraphics(); g.drawImage( tsrc, null, null ); g.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g.setRenderingHint( RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR ); g.setComposite( AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 0.5f ) ); g.translate( cx+translateX, cy+translateY ); g.scale( 1.0001+scale, 1.0001+scale ); // The .0001 works round a bug on Windows where drawImage throws an ArrayIndexOutofBoundException if ( rotation != 0 ) g.rotate( rotate ); g.translate( -cx, -cy ); g.drawImage( dst, null, null ); g.dispose(); BufferedImage ti = dst; dst = tmp; tmp = ti; tsrc = dst; translateX *= 2; translateY *= 2; scale *= 2; rotate *= 2; &#125; return dst; &#125; public String toString() &#123; return &quot;Blur/Motion Blur...&quot;; &#125;&#125; 测试代码：1234567891011121314151617import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;/** * Created by zdmein on 2018/1/10. */public class MotionBlurOpTest &#123; public static void main(String [] args) throws IOException &#123; BufferedImage sourceImage = ImageIO.read(new File(&quot;flower.jpg&quot;)); MotionBlurOp filter=new MotionBlurOp(); BufferedImage destImage=filter.filter(sourceImage,null); ImageIO.write(destImage, &quot;PNG&quot;, new File(&quot;MotionBlurOpflower.jpg&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>图像</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀博主整理]]></title>
    <url>%2F2017%2F09%2F12%2F%E4%BC%98%E7%A7%80%E5%8D%9A%E4%B8%BB%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[优秀博主整理 Name Introduction 纯洁的微笑 资深码农博主，对Spring框架的总结非常不错，现在在一家互联网金融公司做技术经理兼技术负责人 Raysmond 复旦的计算机研究生，现在在北京工作，生活很精彩，工程能力也非常强，看到他在与我同龄时写的一些代码，非常佩服 Yikun 西电毕业的通信领域研究生，去年好像去了菊厂，手绘很棒，生活也很精彩，也是个技术牛人 酷壳 耗子叔，业内知名博主，每一篇博文都是经典，15年开发经验的老码农，曾在Amazon，阿里等处做过资深专家 王之琳 12年本科毕业前端交互工程师，能力很强，简历很炫，写的项目非常多，也特别喜欢逛各种论坛 litten 毕业于华科的前端工程师，非常文青，我这个博客主题就是他写的，现在鹅厂工作 Oilbeater 北大毕业的研究生，曾在阿里任职，现在灵雀云搞Docker，挺有想法的人 羡辙 毕业于上交的研究生，现在是一个非常出色的前端工程师，目前在百度ECharts团队做可视化的相关工作。博客非常有特点，博文质量很高，而且GITHUB的Follower高达4k DIYgod 15年毕业的前端工程师，非常二次元，博客也很另类，个人能力也是很强的，喜欢玩GITHUB很棒，也是掘金的联合小编 龙哥盟 16年毕业于上交，项目经验很丰富，而且非常喜欢搞各种教程，GITHUB的Follower也很多 闵聪 17年毕业于重邮，项目和实习经验都很丰富，现在似乎去了鹅厂 byvoid 牛x的大佬，搞NOIP进的清华，能力超强，奇闻逸事网上流传了很多，最有名的大概就是报阿里星时候的评价表。。。 谢益辉 在美帝工作的经济学PhD,双语博客从05年更到现在，文笔也牛的不行，现在在RStudio做软件工程师 MartinRGB 13年西电毕业的交互设计师以及GUI设计师，看了眼博客，没啥说的，不愧是设计师。。。 魏楚阳 18年毕业的华科研究生，webporter的开发者，爬虫和数据分析的高端玩家，BAT随便进。。。 VoidKing 16级东北师大的软件工程硕士研究生，是个很勤奋的博主，有梦想有想法。 颜开 对Java以及分布式数据库等有着非常深厚的积淀，现在任职于EMC，可惜的是博客不怎么更了 李钊 东北大学14级同届本科，能力很强，现在百度深度学习实验室。 马壮 努力高产的全栈工程师 孔令贤 11年硕士毕业，前华为 OpenStack 社区开发部技术经理，从14级破格提拔至17级，任总在总裁令中点名致歉的员工，在技术和管理的岔路口迷茫过，博客中也记录了职场中很多心路历程。现在已技术移民新西兰 余舜哲 同龄的同学，现在在多伦多大学留学，对新技术有很大的热情，很不错的博客 aneasystone 80后码农一枚。喜欢开源，喜欢读书，喜欢折腾，方向是偏信息安全的，目前应该转了java Zhisheng Tian 同一届的同学，学习的能力跟写作的条理都非常清楚，基础功很扎实，也是非常值得学习 翟永超 《Spring Cloud 微服务实战》一书作者，对Spring全家桶和微服务架构有着很深刻的理解 赵伊凡 比较喜欢总结知识的90后码农，好像写了本书叫《轻松学算法》 小草窝 很小就开始写代码的博主，自己写的emlog框架，比较喜欢搞网站安全 王爵 blade框架的作者，维护了很多开源项目，用blade写的Tale博客框架也挺不错的 并发编程网 阿里系的一帮大牛创的技术网站 aidan 雄哥的博客 云风的 BLOG 总是读成风云… 阮一峰的网络日志 非常佩服的一位，非常勤，特别能坚持 老赵 赵百万的博客 闵聪 腾讯的]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>博主</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用数据结构底层实现及源码]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ZDM–ArrayList、HashMap、Collection、LinkedList、Redis 底层实现及源码 RedisRedis简介Redis是一种key/value型数据库，其中，每个key和value都是使用对象表示的。 1SET message "Hello" 其中，字符串 “message” 这个对象 就是 key ， “Hello” 这个对象 就是 value Redis有5种对象的类型 类型常量 小写 对象名称 REDIS_STRING string 字符串对象 REDIS_LIST list 列表对象 REDIS_HASH hash 哈希对象 REDIS_SET set 集合对象 REDIS_ZSET zset 有序集合对象 Redis对象底层数据结构 编码常量 数据结构 int long类型的整数 embstr embstr编码的简单动态字符串 raw 简单动态字符串 ht 字典 linkedlist 双端链表 ziplist 压缩列表 intset 整数集合 skiplist 跳跃表和字典 字符串对象字符串对象的编码可以是int、raw、embstr 如果字符串对象的长度小于39字节，就用embstr 否则用传统的raw对象 1234567# define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39 robj *createStringObject(char *ptr, size_t len) &#123; if (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len); &#125; embstr的优点： 创建只需分配一次内存，raw为两次 释放内存也是一次 embstr的objet和sds放在一起，更好地利用缓存带来的优势 列表对象列表对象的编码可以是 ziplist or LinkedList ziplist 是一种压缩链表，好处是更能节省内存空间，存储的内容都是在连续的内存区域中的 LinkedList是一种双向链表，没增加一个node，都要重新分配一个内存 哈希对象哈希对象的底层实现用ziplist or hashtable ziplist : 对象数目不多且内容不大，这种方式效率很高 HashTable由dict这个结构实现 集合对象集合对象编码可以是 intset or HashTable 有序集合对象编码一种是 ziplist ，一种是skipList 与 dict 的结合 ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score从小到大顺序排列。它的结构不再复述。 skiplist是一种跳跃表，它实现了有序集合中的快速查找，在大多数情况下它的速度都可以和平衡树差不多。但它的实现比较简单，可以作为平衡树的替代品。 ArrayListArrayList是基于数组实现的，是一个动态数组，其容量能自动增长(1.5+1)。 非线程安全 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353package java.util; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // ArrayList基于该数组实现，用该数组保存数据 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; &#125; // ArrayList无参构造函数。默认容量是10。 public ArrayList() &#123; this(10); &#125; // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; // 将当前容量值设为实际元素个数 public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; //如果还不够，则直接将minCapacity设置为当前容量 if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素e public boolean add(E e) &#123; // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; &#125; // 返回ArrayList的实际大小 public int size() &#123; return size; &#125; // ArrayList是否包含Object(o) public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; //返回ArrayList是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 正向查找，返回元素的索引值 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回ArrayList的Object数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; // 返回ArrayList元素组成的数组 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 &gt;= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 获取index位置的元素值 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; // 设置index位置的值为element public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; // 将e添加到ArrayList中 public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 将e添加到ArrayList的指定位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 删除ArrayList指定位置的元素 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 删除ArrayList的指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 快速删除第index个元素 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; // 从"index+1"开始，用后面的元素替换前面的元素。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work &#125; // 删除元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 清空ArrayList，将全部的元素设为null public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: " + index + ", Size: " + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; &#125; private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); &#125; // 克隆函数 public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125; &#125; HashMapHashMap是基于哈希表实现，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足时，会自动增长。 非线程安全，只是用于单线程环境下，多线程用concurrentHashMap 实现了Serializable接口，因此支持序列化，实现了Cloneable接口，能被克隆。 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754package java.util; import java.io.*; public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的底层数组中已用槽的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因此不能小于0 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public HashMap() &#123; // 设置“加载因子”为默认加载因子0.75 this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); &#125; //求hash值的方法，重新计算hash值 static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; //判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; //没找到则返回null return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; // HashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; //将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; &#125; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果没有存在key为null的键值对，则直接题阿见到table[0]处! modCount++; addEntry(0, null, value, 0); return null; &#125; // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; e.value = value; return; &#125; &#125; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); &#125; // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123; // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); &#125; &#125; // 重新调整HashMap的大小，newCapacity是调整后的容量 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果就容量已经达到了最大值，则不能再扩容，直接返回 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; // 将"m"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125; &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 清空HashMap，将所有的元素设为null public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; &#125; // 克隆一个HashMap，并返回Object对象 public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; &#125; // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; // 创建Entry。将“key-value”插入指定位置。 void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; &#125; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator(); &#125; // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() &#123; return new ValueIterator(); &#125; // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator(); &#125; // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return newValueIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0(); &#125; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; &#125; private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125; &#125; // 返回“HashMap总的容量” int capacity() &#123; return table.length; &#125; // 返回“HashMap的加载因子” float loadFactor() &#123; return loadFactor; &#125; &#125; HashTable基于哈希表实现，每个元素都是key-value对，内部通过单链表解决冲突问题，容量不足时，自动增长 是线程安全的，能用于多线程 实现了Serializable接口，支持序列号 实现了Cloneable接口，能被克隆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806package java.util; import java.io.*; public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; private int hash(Object k) &#123; if (useAltHashing) &#123; if (k.getClass() == String.class) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; else &#123; int h = hashSeed ^ k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; &#125; else &#123; return k.hashCode(); &#125; &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; //注意，Hashtable中的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; //计算hash值，直接用key的hashCode代替 int hash = key.hashCode(); // 计算在数组中的索引值 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = hash(key); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() &#123; int oldCapacity = table.length; Entry[] oldMap = table; //创建新容量大小的Entry数组 int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; //将“旧的Hashtable”中的元素复制到“新的Hashtable”中 for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; //重新计算index int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // 将“修改统计数”+1 modCount++; // 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; //将新的key-value对插入到tab[index]处（即链表的头结点） Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; //从table[index]链表中找出要删除的节点，并删除该节点。 //因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return "&#123;&#125;"; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append('&#123;'); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? "(this Map)" : key.toString()); sb.append('='); sb.append(value == this ? "(this Map)" : value.toString()); if (i == max) return sb.append('&#125;').toString(); sb.append(", "); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return (Iterator&lt;T&gt;) emptyIterator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, true); &#125; &#125; // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125; // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) for (Entry e = tab[i]; e != null; e = e.next) h += e.key.hashCode() ^ e.value.hashCode(); loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table; &#125; private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+"="+value.toString(); &#125; &#125; private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException("Hashtable Enumerator"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException("Hashtable Enumerator"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125; private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException("Hashtable Enumerator"); &#125; &#125; // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator&lt;Object&gt; &#123; EmptyIterator() &#123; &#125; public boolean hasNext() &#123; return false; &#125; public Object next() &#123; throw new NoSuchElementException("Hashtable Iterator"); &#125; public void remove() &#123; throw new IllegalStateException("Hashtable Iterator"); &#125; &#125; &#125; Collection是最基本的集合接口 继承的接口：Iterable 子接口：List、Set、Queue等 遍历Collection中的每一个元素 它支持一个Iterator()方法，该方法返回一个迭代子，该迭代子可逐一访问Collection中每一个元素 12345Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) &#123; Object obj = it.next(); // 得到下一个元素 &#125; 方法： 123retainAll(Collection&lt;?extends E&gt;c); //保留，交运算addAll(Collection&lt;?extends E&gt;c); //添加，并运算removeAll(Collection&lt;?extends E&gt;c); //移除，减运算 LinkedListLinkedList是基于双向循环链表实现的，除了可以当作链表来操作外，它还可以当作栈、队列和双端队列来使用。 非线程安全，单线程下使用 LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 是一个类 实现的接口：List、Collection、Iterable、Serializable、Cloneable、Deque，Queue 子类：没有子类 添加元素方法： boolean add(E e) 添加到链表末尾 void add(int index, E e) 添加到指定位置 boolean addAll(int index, Collection&lt;? extends E&gt; c) boolean addAll(Collection&lt;? extends E&gt; c) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-3]]></title>
    <url>%2F2017%2F09%2F11%2FJava%E5%9F%BA%E7%A1%80-3%2F</url>
    <content type="text"><![CDATA[一些Java基本功的记录。 Java基础系列： Java基础-1 Java基础-2 ArrayList与LinkedList的底层实现ArrayList是List接口的一个实现类，特点是查询效率高，增删效率低，线程不安全 原因是ArrayList底层封装了一个数组，他是用数组实现的。 地址 数组空间 2000 ————-&gt; a[0] 2004 ————-&gt; a[1] 2008 ————-&gt; a[2] — ————-&gt; … 2000+（n-1）*4 ————-&gt; a[n] 定义一个int[]数组，首地址是2000，int类型占4个字节，所以a[0]的首地址2000，a[1]就是2004 每次查询只要一个偏移量就可以了，所以查询效率高 增删效率低的原因： 地址 数组空间 2000 ————-&gt; a[0] 2004 ————-&gt; (新增元素) 2008 ————-&gt; a[1] — ————-&gt; … 2000+（n-1）*4 ————-&gt; a[n] 新增元素会引起后面的元素的移动，所以增删效率低。 LinkedList 增删效率高，查询效率低 LinkedList底层采用双向循环链表实现的List，链表的存储特点是不挨着，它存储每个元素分为三段：上一项的地址，下一项的地址，元素的内容。 每个元素在内存中的排列像是随机的，得根据地址来找元素，所以很慢 增删很快是因为，删除一个元素，前后元素会自动连上，而且删除一个元素只影响前后元素，所以增删效率高。 TCP三次握手，以及为什么不是两次或四次 三次握手过程： 第一次握手：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号（Seq）里。 第二次握手：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。 第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。 如果只有2次 第二次握手后，服务端发送请求给客户端，服务端以为连接成功了，但是如果实际上客户端没收到的话，客户端会认为连接没有建立，服务端会对已建立的连接保存必要的资源，如果出现大量这种情况，服务端会崩溃。 如果是4次 无谓的第四次 二叉树深度、结点​二叉树的第 i 层至多有 2^(i-1) 个结点； 深度为 k 的二叉树至多有 2^k - 1 ​个结点； 对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。 排序算法的稳定性是指 经过排序之后,能使值相同的数据保持原顺序中的相对位置不变 HTTP方法 GET 获取接口信息 PUT 支持幂等性的POST HEAD 紧急查看接口的HTTP的头 POST 提交数据到服务器 DELETE 删除服务器上的资源 OPTIONS 查看支持的方法 常见的HTTP相应状态码1234567891xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求 12345678910111213141516171819202122232425262728293031323334353637383940414243101 – 切换协议201 – 已创建。202 – 已接受。203 – 非权威性信息。204 – 无内容。205 – 重置内容。206 – 部分内容。302 – 对象已移动。304 – 未修改。307 – 临时重定向。401 – 访问被拒绝403 – 禁止访问404 – 未找到405 – 用来访问本页面的 HTTP 谓词不被允许（方法不被允许）406 – 客户端浏览器不接受所请求页面的 MIME 类型。407 – 要求进行代理身份验证。412 – 前提条件失败。413 – 请求实体太大。414 – 请求 URI 太长。415 – 不支持的媒体类型。416 – 所请求的范围无法满足。417 – 执行失败。423 – 锁定的错误。500 – 内部服务器错误。200：请求被正常处理204：请求被受理但没有资源可以返回206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围 的资源。301：永久性重定向302：临时重定向303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上304：发送附带条件的请求时，条件不满足时返回，与重定向无关307：临时重定向，与302类似，只是强制要求使用POST方法400：请求报文语法有误，服务器无法识别401：请求需要认证403：请求的对应资源禁止被访问404：服务器无法找到对应资源500：服务器内部错误503：服务器正忙 反射机制功能 获得一个对象所属的类 获得一个类所有的成员变量和方法 运行时创建对象 运行时调用对象的方法 Java创建对象的方式 new一个 反射机制 clone()方法 反序列化的方式 Java程序初始化顺序 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类非静态变量 父类非静态代码块 父类构造函数 子类非静态变量 子类非静态代码块 子类构造函数 volatile用来修饰被不同线程访问和修改的变量 被volatile类型定义的变量，系统每次用它都是直接从内存中取，而不会利用缓存。 Java堆溢出123456789public class HeapOOM1 &#123; static class OOMObject&#123;&#125; public static void main(String [] args)&#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true)&#123; list.add(new OOMObject()); &#125; &#125;&#125; 单例模式单例模式就是在应用程序中只创建一个该类的对象。又分为饿汉模式和懒汉模式。*实现套路也就是只提供私有构造函数，然后提供公有的 getInstance 方法。* 饿汉模式：也就是一开始就创建该对象 懒汉模式：等到需要用到的时候才创建该对象 饿汉模式1234567public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; return singleton; &#125; &#125; 懒汉模式123456789public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; if(singleton == null) singleton = new Singleton(); return singleton; &#125; &#125; 多线程 synchronized12345public static synchronized Singleton getInstance()&#123; if(singleton == null) singleton = new Singleton(); return singleton; &#125; 双重检验锁123456789101112131415public class Singleton &#123; private static volatile Singleton singleton; public static Singleton getInstance() &#123; if (singleton == null) &#123; //Single Checked synchronized (Singleton.class) &#123; if (singleton == null) &#123; //Double Checked singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（字符串问题）》]]></title>
    <url>%2F2017%2F09%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[字符串问题也是老生常谈的算法问题，该书罗列的字符串问题以我做算法的经验来看，都是很好的题。 代码 Github 地址 判断两个字符串是否互为变形词给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。str1=”123”,str2=”231”,返回true。str1=”123”,str2=”2331”,返回false。 先判断长度是不是一致 再用一个长度为256的数组标记，一个加，一个减。最后看是不是互抵了。 1234567891011121314151617181920212223242526272829303132333435package String;/** * Created by zdmein on 2017/9/1. * 判断两个字符串是否互为变形词 * 给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样， * 那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。 str1="123",str2="231",返回true。 str1="123",str2="2331",返回false。 */public class isDeformation1 &#123; public static void main(String args [])&#123; String str1="54s6"; String str2="465d"; System.out.println(isDeformation(str1,str2)); &#125; public static boolean isDeformation(String str1 ,String str2)&#123; if(str1.length()!=str2.length())&#123; return false; &#125; int res[]=new int [256]; int index=0; while (index!=str1.length())&#123; res[str1.charAt(index)]++; res[str2.charAt(index++)]--; &#125; for(int i=0;i&lt;256;i++)&#123; if(res[i]!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; 字符串的调整与替换 *把 “a b c” 替换后为 “a%20b%20%20c” 开辟空间，从尾部遍历替换到头部 123456789101112131415161718192021222324252627282930313233343536373839package String;/** * Created by zdmein on 2017/9/1. * 字符串的调整与替换 *把 "a b c" 替换后为 “a%20b%20%20c” */public class replace1 &#123; public static void main(String [] args )&#123; String str="a b c"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++)&#123; chas[i]=str.charAt(i); &#125; replace(chas); &#125; public static void replace(char [] chas)&#123; int len=0; int num=0; for(;len&lt;chas.length &amp;&amp; chas[len]!=0;len++)&#123; if(chas[len]==' ')&#123; num++; &#125; &#125; int index=len+num*2; for(;index&gt;=0;index--)&#123; if (chas[len--]==' ')&#123; chas[index--]='0'; chas[index--]='2'; chas[index]='%'; &#125;else &#123; chas[index]=chas[len+1]; &#125; &#125; System.out.println(chas); &#125;&#125; 扩展： 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 12345678910111213141516171819202122232425262728293031323334353637package String;/** * Created by zdmein on 2017/9/1. * 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 */public class replace2 &#123; public static void main(String [] args )&#123; String str="12**35"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++)&#123; chas[i]=str.charAt(i); &#125; modify(chas); &#125; public static void modify(char [] chas)&#123; if(chas==null||chas.length==0)&#123; return; &#125; int j=chas.length-1; for(int i=chas.length-1;i&gt;=0;i--)&#123; if(chas[i]!='*')&#123; chas[j--]=chas[i]; &#125; &#125; for(;j&gt;=0;j--)&#123; chas[j]='*'; &#125; System.out.println(chas); &#125;&#125; 翻转字符串写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 写个函数，先整体翻转一次，然后再每个单词翻转一次。easy！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344package String;/** * Created by zdmein on 2017/9/2. * 翻转字符串 * 写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 */public class rotateWord1 &#123; public static void main(String [] args)&#123; String str= "dogs love pig."; rotateWord(str); &#125; public static void rotateWord(String str)&#123; if(str==null||str.length()==0)&#123; return ; &#125; char [] strArr = str.toCharArray(); reverse(strArr,0,strArr.length-1); int index=0; for(int i=0;i&lt;strArr.length;i++)&#123; if(strArr[i]==' ')&#123; reverse(strArr,index,i-1); index=i+1; &#125; &#125; reverse(strArr,index,strArr.length-1); System.out.println(strArr); &#125; public static void reverse(char[] strArr ,int first ,int end)&#123; while (first&lt;end)&#123; char tmp=strArr[first]; strArr[first]=strArr[end]; strArr[end]=tmp; first++; end--; &#125; &#125;&#125; 数组中两个字符串的最小距离 Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1. 用2个下标指向2个字符串，跟新位置，互相减，然后Math.min取小的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package String;/** * Created by zdmein on 2017/9/3. * 数组中两个字符串的最小距离 *Assume that words = ["practice", "makes", "perfect", "coding", "makes"]. * Given word1 = “coding”, word2 = “practice”, return 3. * Given word1 = "makes", word2 = "coding", return 1. */public class minDistance1 &#123; public static void main(String args[])&#123; String [] strs =&#123;"1","3","3","3","2","3","1"&#125;; String str1="1"; String str2="2"; minDistance(strs,str1,str2); &#125; public static void minDistance(String[] strs,String str1 , String str2)&#123; if(strs==null||strs.length==0||str1==null||str2==null)&#123; return; &#125; int index1=-1; int index2=-1; int min=Integer.MAX_VALUE; for(int i=0;i&lt;strs.length;i++)&#123; if(strs[i]==str1)&#123; index1=i; if(index2!=-1)&#123; min=Math.min(min,index1-index2); &#125; &#125;else if(strs[i]==str2)&#123; index2=i; if(index1!=-1)&#123; min=Math.min(min,index2-index1); &#125; &#125; &#125; // if(min!=Integer.MAX_VALUE)&#123; System.out.println(min); &#125;else &#123; System.out.println(-1); &#125; //上面这个渣渣代码可以这样写： // min==Integer.MAX_VALUE ? -1 : min; &#125;&#125; 替换字符串中连续出现的指定字符串题目：给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。举例：str=”123abc”，from=”abc”，to=”4567”，返回”1234567”；str=”123”，from=”abc”，to=”4567”，返回”123”；str=”123abcabc”，from=”abc”，to=”X”，返回”123X”； 思路： 把from匹配的字符，设为0，然后把0的部分全部替换掉成to，就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package String;/** * Created by zdmein on 2017/9/4. * 替换字符串中连续出现的指定字符串 题目： 给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。 举例： str="123abc"，from="abc"，to="4567"，返回"1234567"； str="123"，from="abc"，to="4567"，返回"123"； str="123abcabc"，from="abc"，to="X"，返回"123X"； */public class replace3 &#123; public static void main(String args[])&#123; String str="123abcabc"; String from="abc"; String to = "4567"; System.out.println(replace(str,from,to)); &#125; private static String replace(String str,String from ,String to)&#123; if(str==null||from==""||to=="")&#123; return str; &#125; char[] chstr=str.toCharArray(); char[] chfrom=from.toCharArray(); int match=0; for(int i=0;i&lt;str.length();i++)&#123; if(chstr[i]==chfrom[match++])&#123; if(match==chfrom.length)&#123; clear(chstr,i,chfrom.length); match=0; &#125; &#125;else &#123; match=0; &#125; &#125; String res=""; for(int i=0;i&lt;chstr.length;i++)&#123; if(chstr[i]!=0)&#123; while (chstr[i]!=0)&#123; res+=chstr[i++]; &#125; &#125; if(chstr[i]==0)&#123; while (i!=chstr.length&amp;&amp;chstr[i]==0)&#123; i++; &#125; res+=to; i--; &#125; &#125; return res; &#125; private static void clear(char[] chstr , int end ,int len)&#123; while(len--!=0)&#123; chstr[end--]=0; &#125; &#125;&#125; 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 先记录a，然后一项一项对比记录 String.valueof()的使用 1234567891011121314151617181920212223242526272829303132333435363738package String;/** * Created by zdmein on 2017/9/5. * 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 */public class getCountString1 &#123; public static void main(String [] args)&#123; String str="aaabbadddffc"; System.out.println(getCountString(str)); &#125; private static String getCountString(String str)&#123; if(str==null||str.length()==0)&#123; return ""; &#125; char [] chs=str.toCharArray(); String res=String.valueOf(chs[0]); int num=1; for(int i=1;i&lt;str.length();i++)&#123; if(chs[i]==chs[i-1])&#123; num++; &#125;else &#123; res=res+"_"+String.valueOf(num)+"_"+String.valueOf(chs[i]) ; num=1; &#125; &#125; return res+"_"+String.valueOf(num)+"" ; &#125;&#125; 判断两个字符串是否互为旋转词 题目： 如果一个字符串str，把字符串str前面任意的部分挪到后面形成的字符串叫做str的旋转词。 如str=”12345”，str的旋转词有”12345”、”23451”、”34512”、”45123”、”51234”。 给定两个字符串a和b，请判断a和b是否互为旋转词。 举例： a=”cdab”，b=”abcd”，返回true； a=”1ab2”，b=”ab12”，返回false； a=”2ab1”，b=”ab12”，返回true。 要求： 如果a和b长度不一样，那么a和b必然不互为旋转词，可以直接返回false。 当a和b长度一样，都为N时，要求解法的时间复杂度为O(N)。 1234567891011121314151617181920package String;/** * Created by zdmein on 2017/9/6. */public class isRotation &#123; public boolean isRotation(String a ,String b)&#123; if(a==null||b==null||a.length()!=b.length())&#123; return false; &#125; String b2=b+b; return KMP(b2,a)!=-1; // KMP算法 &#125; public static int KMP(String source , String pattern)&#123; // int [] N=getN(pattern); return -1; &#125;&#125; 判断是不是整体有效的括号字符串1234567891011121314151617181920212223242526272829303132333435363738package String;import java.util.Scanner;/** * Created by zdmein on 2017/9/18. * 判断是不是整体有效的括号字符串 * 括号字符串的有效性和最长有效长度 */public class isValid1 &#123; public static void main(String [] args)&#123; Scanner cin=new Scanner(System.in); String str=cin.next(); System.out.println(isValid(str)); &#125; public static boolean isValid(String str)&#123; if(str==null ||str.equals(""))&#123; return false; &#125; char [] chs=str.toCharArray(); int status=0; for(int i=0;i&lt;str.length();i++)&#123; if(chs[i]!=')'&amp;&amp;chs[i]!='(')&#123; return false; &#125; if(chs[i]==')'&amp;&amp;--status&lt;0)&#123; return false; &#125; if(chs[i]=='(')&#123; status++; &#125; &#125; return status==0; &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经-腾讯1]]></title>
    <url>%2F2017%2F08%2F30%2F%E9%9D%A2%E7%BB%8F-%E8%85%BE%E8%AE%AF1%2F</url>
    <content type="text"><![CDATA[基础查漏补缺~ 面向对象的特征 继承：联结性的层次模型，表述共性 多态：允许不同类对同一消息作出响应 抽象：过程抽象，数据抽象 封装：将客观事物抽象成类 重写和重载有什么不同 重写（override）：派生类函数覆盖 重载（overload）：多个方法有相同名字、不同参数。 区别： 重写是子类与父类之间的关系，是垂直关系；重载是同一个类中方法之间的关系，是水平关系。 重写只能由一个方法或者一对方法产生关系；重载是多个方法之间的关系。 重写要求参数列表相同；重载要求参数列表不同。 重写关系中，调用方法体是根据对象的类型来决定；重载是根据调用的实参表和形参表来选择方法体。 计算机加载程序包括哪几个区？链表和数组有什么不同？ 数组静态分配内存，链表动态分配内存 数组在内存中连续，链表不连续 数组元素在栈区，链表元素在堆区 数组利用下标定位，时间复杂度O(1)，链表定位元素时间复杂度O(n) 数组插入和删除时间复杂度O(n)，链表的时间复杂度O(1) 栈和堆的特点是什么？ 栈： 先进后出 存放的都是局部变量 使用完变量会自动在内存中释放 堆： 可以看成一棵树 存放的是实体或者成员变量 存放的实体都是有首地址值的 实体中的数据都是有初始值的 什么排序稳定性高而且效率？快排 进程间通讯的几种方式？ 文件和记录锁定 管道 有名管道 FIFO 信号量 信号 消息队列 共享内存 套接字（socket） 详解 解释 TCP/IP的三次握手协议TCP/IP有什么作用有哪些方式可以加快查询？（我答了建索引，试图存储 过程，建索引是一定对的其他两个就不知道了）然后他继续追问，建索引一般是怎么才能让查询更加快呢？ （问我怎么样才能够通过索引排除不同的数据吧，这个还真懂完全没左外连接和右外连接有什么不同左连接就是以左为主，右边的记录可能为空 右连接就是以右为主左边的可能为空]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>Java</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习指南]]></title>
    <url>%2F2017%2F08%2F28%2FLinux%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[发现学过的东西很容易忘，所以常常复习、总结还是蛮必要的。 Linux基础 输出 12echo "Hellbo"Hellbo 快捷键 快捷键 作用 Ctrl+c 终止程序 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 把当前程序放到后台运行，fg将程序恢复到前台 Ctrl+a 将光标移至输入行头 Ctrl+e 将光标移至输入行尾 Ctrl+k 删除从光标位置到行末 Alt+Backspace 向前删除一个单词 Shift+Pgup 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 创建文件 12touch adeni.txt dsaidj.txt //创建2个文件touch abc_&#123;1..10&#125;_linux.txt //创建多个文件 通配符找文件 1ls *.txt Shell通配符 字符 含义 * 匹配0或多个字符 ？ 匹配任意一个字符 [list] 匹配list中的任意单一字符 [!list] 匹配除list中的任意单一字符以外的字符 [c1-c2] 匹配c1-c2终端任意单一字符 {string1,string2,…} 匹配list中的任意单一字符 {c1..c2} 匹配list中的任意单一字符 用户及文件权限管理 创建用户 12345678sudo adduser zdm //创建用户ls /home //默认为新用户创建home目录su -l zdm //切换登陆用户groups zdm //查看自己属于哪些用户组cat /etc/group | sort //查看 /etc/group 文件// 将其他用户加入sudo用户组su -l zdmsudo ls 变更文件所有者 1234567891011touch iphonecd /home/zdmls iphonesudo chown shiyanlou iphoneecho "echo \"hello shiyanlou\"" &gt; iphone //加内容chmod 700 iphone //修改权限cp -r father family //复制目录rm test //删除 环境变量及文件查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建tmp变量$ declare tmp//使用=赋值$ tmp=zdm//输出$ echo $tmp//创建一个Shell脚本文件$ gedit hello_shell.sh--------------------------#!/bin/bashfor((i=0;i&lt;10;i++));doecho "hello shell"done exit 0 ------------------------- //为文件添加可执行权限$ chmod 755 hello_shell.sh//执行脚本$ ./hello_shell.sh//创建一个C语言程序$ gedit hello_world.c-----------------------------#include &lt;stdio.h&gt;int main(void)&#123; printf("hello world!\n"); return 0;&#125;-----------------------------//使用gcc生成可执行文件$ gcc -o hello_world hello_world.c//创建一个mybin目录，将上面2文件放入$ mkdir mybin$ mv hello_shell.sh hello_world mybin///在mybin中分别运行这两个程序$ cd mybin$ ./hello_shell.sh$ ./hello_world 磁盘管理12345678910111213//查看磁盘容量df//以磁盘块大小的方式显示容量df -h//du 命令查看目录的容量dudu -h//从/dev/zero设备创建一个容量为 256M 的空文件：dd if=/dev/zero of=virtual.img bs=1M count=256du -h virtual.img 任务计划crontab123456789101112131415161718192021//添加任务计划sudo cron -f &amp;crontab -e//查看man crontab//每分钟创建一个以当前年月日时分秒为名字的空白文件*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)//查看添加了哪些任务crontab -l//cron 是否成功的在后台启动pgrep cron//执行任务命令之后在日志中的信息反馈sudo tail -f /var/log/syslog//删除任务crontab -r 命令执行顺序控制与管道12345678910//sort排序命令//默认为字典排序cat /etc/passwd | sort//反转排序cat /etc/passwd | sort -r//按特定字段排序cat /etc/passwd | sort -t ":" -k 3 简单的文本处理1234567//tr:删除一段文本中的某些文字tr [option]...SET1 [SET2]//col: 将Tab换成等数量的空格键col [option] 常用命令 查看目录与文件：ls 切换目录：cd 显示当前目录：pwd 创建空文件：touch 创建目录：mkdir 查看文件内容：cat 分页查看文件内容：more 查看文件尾内容：tail 拷贝：cp 剪切或改名：mv 删除：rm 搜索文件：find 创建链接文件：In 显示或配置网络设备：ifconfig 显示网络相关信息：netstat 显示进程状态：ps 查看目录使用情况：du 查看磁盘空间使用情况：df 显示系统当前进程信息：top 杀死进程：kill 压缩和解压：tar 改变文件或目录的拥有者和组：chown 改变文件或目录的访问权限：chmod 文本编辑：vim 关机或重启：shutdown 帮助命令：man 20个常用问题20条Linux命令面试问答 问:1 如何查看当前的Linux服务器的运行级别？答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。 问:2 如何查看Linux的默认网关？答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。 问:3 如何在Linux上重建初始化内存盘镜像文件？答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下： # mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r) 如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下： # dracut -f 以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令： # dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64 问:4 cpio命令是什么？答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。 问:5 patch命令是什么？如何使用？答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。创建一个diff文件给patch使用， # diff -Naur old_file new_file &gt; diff_file 旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件： # patch &lt; diff_file 问:6 aspell有什么用 ?答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。 问:7 如何从命令行查看域SPF记录？答: 我们可以用dig命令来查看域SPF记录。举例如下： linuxtechi@localhost:~$ dig -t TXT http://google.com 问:8 如何识别Linux系统中指定文件(/etc/fstab)的关联包？答: # rpm -qf /etc/fstab 以上命令能列出提供“/etc/fstab”这个文件的包。 问:9 哪条命令用来查看bond0的状态？答: cat /proc/net/bonding/bond0 问:10 Linux系统中的/proc文件系统有什么用？答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。 问:11 如何在/usr目录下找出大小超过10MB的文件？答: # find /usr -size +10M 问:12 如何在/home目录下找出120天之前被修改过的文件？答: # find /home -mtime +120 问:13 如何在/var目录下找出90天之内未被访问过的文件？答: # find /var ! -atime -90 问:14 在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。答: # find / -name core -exec rm {} \; 问:15 strings命令有什么作用？答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处） 问:16 tee 过滤器有什么作用 ?答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。 linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out 在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。 问:17 export PS1 = ”$LOGNAME@hostname:\$PWD: 这条命令是在做什么？答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。 问:18 ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？答: 这条ll命令会显示这些文件的文件名和它们的拥有者。 问:19 :Linux中的at命令有什么用？答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。 问:20 linux中lspci命令的作用是什么？答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。 360Linux运维面试题奇虎360Linux运维工程师面试真题 1、写一个脚本查找最后创建时间是3天前，后缀是*.log的文件并删除。 find / -name “*.log” -ctime +3 -exec rm -f {} \; 2、写一个脚本将某目录下大于100k的文件移动至/tmp下。 for i in find /test -type f -size +100k;do cd /test &amp;&amp; mv $i /tmp;done 3、写一个脚本将数据库备份并打包至远程服务器192.168.1.1 /backup目录下。 mount 192.168.1.1:/backup /mnt cd /mnt /usr/local/mysql/bin/mysqldump -hlocalhost -uroot test &gt;test.sql tar czf test.sql.tar.gz test.sql rm -f test.sql 4、写一个防火墙配置脚本，只允许远程主机访问本机的80端口。 iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT iptables -F iptables -X iptables -A INPUT -i eth0 -p tcp –dport 80 -j ACCEPT iptables -P INPUT DROP 5、写一个脚本进行nginx日志统计，得到访问ip最多的前10个(nginx日志路径：/home/logs/nginx/default/access.log awk ‘{a[$1]++}END{for (j in a) print a[j],j}’ /home/logs/nginx/default/access.log|sort -nr|head -10 6、写出下列配置的含义 （1）MaxKeepAliveRequests 100 （2）Options FollowSymLinks Order Deny Allow Deny from all Allow from 192.168.1.1 （1）MaxKeepAliveRequests — 100 连接的最大请求数 （2）Options FollowSymLinks — 允许192.168.1.1可以列目录 Order Deny Allow Deny from all Allow from 192.168.1.1 7、写一个脚本把指定文件里的/usr/local替换为别的目录。 sed ‘s:/user/local:/tmp:g’ filename 8、简要描述Linux的启动过程？ BIOS启动引导(从mbr中装载启动管理器grub)—-GRUB启动引导(装载kernel和initrd到内存)—–内核启动参数-sys init初始化.. 9、简要叙述下列端口所运行的服务 21、22、23、25、110、143、873、3306 对应的服务是 ftp ssh telnet snmp pop3 IMAP rsync 10、TCP断头最小长度是多少字节？ 64字节 11、让某普通用户能进行cp /dir1/file1 /dir2的命令时，请说明dir1 file1最小具有什么权限？ 读取和执行权限rx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（二叉树问题）》]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 代码 Github 地址 判断二叉树是不是平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡的二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 先比较左边，再比较右边； 左子树也先比较左边再比较右边。 1234567891011121314151617181920212223242526public boolean isBalance(Node head)&#123; boolean res=true; getHeight(head,1,res); return res; &#125; public int getHeight(Node head , int level ,boolean res)&#123; if(head==null)&#123; return level; &#125; int lH=getHeight(head.left,level+1,res); if(!res)&#123; return level; &#125; int rH=getHeight(head.right,level+1,res); if(!res)&#123; return level; &#125; if(Math.abs(lH-rH)&gt;1)&#123; res=false; &#125; return Math.max(lH,rH); &#125; 根据后序数组重建搜索二叉树给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。 数组最后一个值，肯定是根节点的值 小于根节点的为左子树，大于根节点的为左子树 对应2,1,3小于4 6,5,7大于4 12345678910111213141516171819202122232425262728293031323334353637public static void main(String [] args)&#123; int [] arr=&#123;2,1,3,6,5,7,4&#125;; System.out.println(isPostArray(arr)); &#125; public static boolean isPostArray(int [] arr)&#123; if(arr==null || arr.length==0)&#123; return false; &#125; return isPost(arr,0,arr.length-1); &#125; public static boolean isPost(int [] arr, int start ,int end)&#123; if(start==end)&#123; return true; &#125; int less=-1; int more=end; for(int i=start;i&lt;end;i++)&#123; if(arr[i]&lt;arr[end])&#123; less=i; &#125;else &#123; more=more==end ? i : more; &#125; &#125; if(less==-1||more==end)&#123; return isPost(arr,start,end-1); &#125; if(less!=more-1)&#123; return false; &#125; return isPost(arr,start,less)&amp;&amp;isPost(arr,more,end-1); &#125; 二叉树的序列化和反序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package BinaryTree;import java.util.LinkedList;import java.util.Queue;/** * Created by zdmein on 2017/9/7. 12 / \ 3 null / \ null null 先序遍历：12！3！#！#！#！ */public class NodeSerial &#123; /** * 定义Node */ public class Node&#123; public int value; public Node left; public Node right; public Node(int data)&#123; this.value=data; &#125; &#125; /** * 先序遍历 */ public String serialByPre(Node head)&#123; if(head==null)&#123; return "#!"; &#125; String res=head.value+"!"; res+=serialByPre(head.left); res+=serialByPre(head.right); return res; &#125; /** * 先序遍历反序列化 */ public Node reconByPreString(String preStr)&#123; String [] values=preStr.split("!"); Queue&lt;String&gt; queue=new LinkedList&lt;String&gt;(); for(int i=0;i&lt;values.length;i++)&#123; queue.offer(values[i]); &#125; return reconPreOrder(queue); &#125; /** * Queue add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 */ public Node reconPreOrder(Queue&lt;String&gt; queue)&#123; String value = queue.poll(); if(value.equals("#"))&#123; return null; &#125; Node head=new Node(Integer.valueOf(value)); Node left=reconPreOrder(queue); Node right=reconPreOrder(queue); return head; &#125; &#125; 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package BinaryTree;/** * Created by zdmein on 2017/9/8. * 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 6 / \ 1 12 /\ / \ 0 3 10 13 / \ / \ 4 14 2 9 /\ /\ 2 5 1 6 二叉搜索树： 10 / \ 4 14 / \ / \ 2 5 1 6 要求： 如果节点数为N，要求时间复杂度为O（N） ,额外空间复杂度为O(h),h为二叉树的高度。 解： 以节点node为头的树中，最大的搜索二叉子树只可能来自一下两种情况。 1.如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树的最大搜索二叉树是以 node.right为头的；node左子树上的最大搜索二叉子树的最大值小于node.value； node右子树的最大搜索二叉子树的最小值大于node.value,那么以节点node为头的整棵树都是搜索二叉树。 2如果不满足第一中情况，说明节点node为头的整颗树不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树来自node的左子树上的最大搜索二叉子树和来自右子树上的最大搜索二叉子树之间， 节点较多的那个。 过程如下： 1，整个过程是二叉树的后序遍历。（左右根） 2，遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点（IBST） ，节点数（ISize）,最小值（IMin）,最大值（IMax）. 再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点（RBST） ，节点数（RSize）,最小值（RMin）,最大值（RMax）. 3, 根据步骤2收集的信息，判断是否满足第一种情况，如果满足第一种情况就返回cur，如果满足第二种情况，就返回IBST和RBST中较大的一个。 4，可以使用全局变量的方式实现步骤2中收集节点数，最大和最小的情况。 */public class biggestSubBST1 &#123; public class Node&#123; public int value; public Node left; public Node right; public Node(int data)&#123; this.value=data; &#125; &#125; public Node biggestSubBST(Node head)&#123; int [] record =new int[3]; return posOrder(head , record); &#125; public Node posOrder(Node head,int [] record)&#123; if(head==null)&#123; record[0]=0; record[1]=Integer.MAX_VALUE; record[2]=Integer.MIN_VALUE; return null; &#125; int value=head.value; Node left=head.left; Node right=head.right; Node lBST=posOrder(left,record); int lSize=record[0]; int lMin=record[1]; int lMax=record[2]; Node rBST=posOrder(right,record); int rSize=record[0]; int rMin=record[1]; int rMax=record[2]; record[1]=Math.min(value,lMin); record[2]=Math.max(value,rMax); if(left==lBST&amp;&amp;right==rBST&amp;&amp;lMax&lt;value&amp;&amp;rMin&gt;value)&#123; record[0]=lSize+rSize+1; return head; &#125; record[0]=Math.max(lSize,rSize); return lSize&gt;rSize?head.left:head.right; &#125;&#125; 找到二叉树中符合搜索二叉树条件的最大拓扑结构]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（链表问题）》]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。它可以根据需要开辟内存单元。链表有一个“头指针”变量，以head表示，它存放一个地址。该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：一为用户需要用的实际数据，二为下一个结点的地址。因此，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 打印两个有序链表的公共部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package LinkedList;/** * Created by zdmein on 2017/8/31. * * 打印两个有序链表的公共部分 * 给定两个有序列表的头指针head1和head2，打印两个链表的公共部分。 */public class printCommonPart1 &#123; public static class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value=data; &#125; &#125; public static void main(String args[])&#123; Node head1=new Node(2); Node head11=new Node(3); Node head12=new Node(4); Node head13=new Node(7); head1.next=head11; head11.next=head12; head12.next=head13; Node head2=new Node(1); Node head21=new Node(3); Node head22=new Node(4); Node head23=new Node(9); head2.next=head21; head21.next=head22; head22.next=head23; printCommonPart(head1,head2); &#125; public static void printCommonPart(Node head1,Node head2)&#123; System.out.println("Print Common Part: "); while(head1!=null&amp;&amp;head2!=null)&#123; if(head1.value==head2.value)&#123; System.out.println(head1.value); head1=head1.next; head2=head2.next; &#125;else if(head1.value&gt;head2.value)&#123; head2=head2.next; &#125;else &#123; head1=head1.next; &#125; &#125; &#125;&#125; 判断一个链表是否为回文结构题目：判断一个链表是否为回文结构。要求：时间复杂度为 O(n)，空间时间复杂度为O(1)。 思路分析：回文链表的特点就是对称，那么要判断是否回文，就可以用两个指针指向对称的节点，看它们的数据是否一样。由于是单向链表，不能同时用两个指针，从头尾向内部遍历取值比较。且本题对空间复杂度也有要求，所以可用如下方法实现。具体步骤如下：（1）先得到链表的中间节点；（2）从中间节点的下一个节点开始，反转链表。（3）从中间节点处，断开原链表。（4）用两个指针分别向两个端点移动，同时进行比较，数据相同则继续，数据不同则直接返回false。直到遍历完成，最后返回true。 12345678910111213141516171819202122232425262728293031323334353637383940414243class ListNode &#123; public char data; public ListNode next; public ListNode(char c)&#123; this.data=c; &#125; &#125; public static boolean isPalindrome(ListNode head )&#123; ListNode slow = head; ListNode fast= head; if(fast==null || fast.next==null)&#123; return true; &#125; //一个每次走2步，一个每次走1步，所以当fast到表尾，slow肯定把链表折半 while(fast.next!=null&amp;&amp;fast.next.next!=null)&#123; fast=fast.next.next; slow=slow.next; &#125; ListNode midNode=slow; ListNode firNode = slow.next; //后半段第一个节点 ListNode cur=firNode.next; //从第一个节点开始插入 firNode.next=null; //第一个节点最后变成最后一个节点，所以要置空 while(cur!=null)&#123; ListNode nextNode = cur.next; cur.next=midNode.next; midNode=cur; cur=nextNode; &#125; slow=head; fast=midNode.next; while (fast!=null)&#123; if(fast.data!=slow.data)&#123; return false; &#125; slow=slow.next; fast=firNode.next; &#125; return true; &#125; 反转单向反转单向链表 1–&gt;2–&gt;null 反转后 2–&gt;1–&gt;null 12345678910111213141516171819202122232425262728293031/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */public class Solution &#123; /* * @param head: n * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) &#123; // write your code here ListNode pre=null; ListNode next1=null; while(head!=null)&#123; next1=head.next; head.next=pre; pre=head; head=next1; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（位运算及大数据）》]]></title>
    <url>%2F2017%2F08%2F22%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[位运算、大数据和空间限制 不用额外变量交换两个整数的值【题目】 如何不用任何额外变量交换两个整数的值？ 【解答】 使用位运算的异或运算，或者使用加法运算 a异或b的结果是c,那么c就是a整数位信息和b整数位信息的所有不同信息。 a = a^b,当前a=c；b = a^b相当于b = c^b 当前b=a；a = a^b 相当于a = c^a 当前a=b,完成交换； 如果是加法交换的话，假设a + b结果是c，那么 a = a+b,当前a=c；b = a-b相当于b = c-b 当前b=a；a = a-b 相当于a = c-a 当前a=b,完成交换； 12345a=011b=100c=a^b=111a=a^c=011^111=100b=a^c=100^111=011 输入一个整数,求该整数的二进制表达中有多少个1题目：输入一个整数，求该整数的二进制表达中有多少个1。例如输入10，由于其二进制表示为1010，有两个1，因此输出2。 12345678910111213public int count(int n)&#123; int res=0; while(n!=0)&#123; n&amp;=(n-1); res++; &#125; return res; &#125;--- n=1010 n=1010&amp;1001=1000 res=1; n=1000&amp;0999=0000 res=2;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-操作系统]]></title>
    <url>%2F2017%2F08%2F15%2FJava%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统的一些基本概念 进程和线程的区别进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单元，他是比进程更小的能独立运行的基本单位。 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 死锁的必要条件，怎么处理死锁四个条件： 互斥条件：指进程对所分配到的资源进行排他性的使用，即在一段时间内某资源只有一个进程占用，如果此时还有其他进程请求资源，则让他先等着，直到占有资源的进程用完释放后，才可以用。意思就是一个资源只能一个进程占用，其他要用的得等着。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放。意思是一个进程占用了资源，想获得别的资源，要是那个资源被占，那自己先等，但是自己占的资源也不会释放给别的进程。 不剥夺条件：指进程占有的资源，不能被剥夺，只能自己释放。我占的资源你不能抢。 环路等待条件：指在发生死锁时，必然是有一个环路链，进程都占用资源，但是又想获得其他进程占有的资源，形成一个环，循环等待。 处理死锁的方法： 预防死锁 破坏占有并等待条件：一次性分配全部资源 or 每次申请前，必须释放自己的资源 避免死锁 检测死锁 解除死锁 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程 撤销进程：强制撤销某些、甚至全部死锁进程并剥夺这些进程的资源 进程回退：让一or多个进程回退到足以回避死锁的地步，进程回退时自愿放弃资源而不是剥夺。（设置还原点） Window内存管理方式段存储## 页存储 段页存储进程的几种状态进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。 一个进程的生命周期可以划分为一组状态。 三个：就绪、运行、阻塞 运行：进程占用CPU，并在CPU上运行 就绪：进程已经具备运行条件，但是CPU还没有分配过来 阻塞：进程因为某件事发生而暂时不能运行 IPC几种通信方式IPC是进程间的通讯 （Inter-process communication） 作用：数据传输、共享数据、通知事件、资源共享、进程控制（这些都需要通讯） 无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程间通信。管道的缓冲区是有限的，管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约好数据的格式。 命名管道（fifo）：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则是把数据添加到末尾。 消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，可以用非先进先出方式处理，消息队列是异步通信。 共享内存：共享内存是最快的IPC方式，在共享内存段中都是以字符串的默认结束符为一条信息的结尾。 信号量（semophore）：信号量是一个计数器 什么是虚拟内存 虚拟地址、逻辑地址、线性地址、物理地址的区别 物理地址 用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应 虚拟地址 这是对整个内存的抽象描述 逻辑地址 指机器语言指令中，用来指定一个操作数或者是一条指令的地址 线性地址 也是不真实的地址，对应硬件页式内存的转换前地址 推荐书籍：《深入理解现代操作系统》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（数组和矩阵问题）》]]></title>
    <url>%2F2017%2F08%2F14%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[数组和矩阵问题，这些做得比较多。 未排序正整数数组中累加和为给定值的最长子数组长度12345678910111213141516171819202122232425262728293031323334353637383940414243package Array;/** * Created by zdmein on 2017/8/30. *未排序正整数数组中累加和为给定值的最长子数组长度 * 给定一个无需数组arr,其中元素为正，给定一个整数k。求arr的所有子数组中累加和为k的最长子数组的长度。 * arr=[1,2,1,1,1],k=3 * 结果返回3 */public class getMaxLength1 &#123; public static void main(String [] args)&#123; int [] arr=&#123;1,2,1,1,1&#125;; int k=3; System.out.println(getMaxLength(arr,k)); &#125; public static int getMaxLength(int [] arr ,int k)&#123; if(arr==null||arr.length&lt;0||k&lt;0)&#123; return 0; &#125; int right =0; int left=0; int len=0; int sum=arr[0]; while (right&lt;arr.length)&#123; if(sum==k)&#123; len=Math.max(len,right-left+1); sum-=arr[left++]; &#125;else if(sum&lt;k)&#123; right++; if(right==arr.length)&#123; break; &#125; sum+=arr[right]; &#125;else &#123; sum-=arr[left++]; &#125; &#125; return len; &#125;&#125; 数组partition调整使数组的左部分单调有序给定一个有序数组arr，调整使得数组的左部分无重复元素且有序，右边部分不要求。如数组arr[]={1,2,2,2,3,3,4,5,6,9,9} ;调整过后可以为：[1, 2, 3, 4, 5, 6, 9, 2, 3, 2, 9] 。 思路：使用标记 u 其中arr[0…u] 表示已经处理过的没有重复元素且有序的区间，从arr[u+1…i-1]表示有重复元素的部分。则算法主要分为下面两部分。1. 比较 arr[i] 与 arr[u] 是否相同如果不同，则将 arr[i] 的值赋给arr[u+1],u++;2. i++遍历数组。 123456789101112131415161718192021222324252627282930import java.util.HashSet;public class Main &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 2, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 8, 9&#125;; leftUnique(arr); &#125; public static void leftUnique(int[] arr) &#123; if (arr.length == 0 || arr == null) &#123; return; &#125; int u=0; int i=1; while (i!=arr.length)&#123; if(arr[i++]!=arr[u])&#123; swap(arr,i-1,++u); &#125; &#125; for( i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125; public static int [] swap(int[] arr,int m, int n)&#123; int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; &#125;&#125; 将正方形矩阵顺时针转动90度题目：给定一个N*N的矩阵matrix,求把这个矩阵调整成顺时针转动90度后的形式。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 顺时针转动90度后为: 13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 要求：额外空间复杂度为O(1) 12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; public static void main(String[] args) &#123; int[][] m = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;, &#123;13,14,15,16&#125; &#125;; rotate(m); &#125; public static void rotate(int[][] arr) &#123; int tR=0; int tC=0; int dR=arr.length-1; int dC=arr[0].length-1; while (tR&lt;dR)&#123; rotateEdge(arr,tR++,tC++,dR--,dC--); &#125; for (int i=0;i&lt;arr.length;i++) &#123; for (int j = 0; j &lt; arr[0].length; j++) &#123; System.out.print(arr[i][j] + " "); &#125; System.out.println(" "); &#125; &#125; public static void rotateEdge(int [][] arr ,int tR,int tC ,int dR ,int dC)&#123; int times=dR-tR; int temp=0; for(int i=0;i!=times;i++)&#123; temp = arr[tR][tC+i]; arr[tR][tC+i]=arr[dR-i][tC]; arr[dR-i][tC]=arr[dR][dC-i]; arr[dR][dC-i]=arr[tR+i][dC]; arr[tR+i][dC]=temp; &#125; &#125;&#125; 找到无序数组中最小的K个数给定一个无序的整型数组arr，找到其中最小的k个数。 时间复杂度：O(nlogk) 维护一个有k个数的大根堆，这个堆代表目前选出的k个最小的数。在堆的k个元素中堆顶元素是最小的k个数中最大的那个。 接下来要遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。如果是，就把堆顶元素替换成当前数，然后调整堆。如果不是，则不做任何操作，继续遍历下一个数。在遍历完成后，堆中的k个数就是所有数组中最小的k个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main &#123; public static void main(String[] args) &#123; int[] arr = &#123;5 ,9,3,4,7,2,8,1,6&#125;; int k=3; int [] res= getMinKNumsByHeap(arr,k); for(int i=0;i&lt;res.length;i++)&#123; System.out.println(res[i]); &#125; &#125; public static int [] getMinKNumsByHeap(int[] arr,int k) &#123; if(k&lt;1&amp;&amp;k&gt;arr.length)&#123; return arr; &#125; int kHeap[]=new int [k]; for(int i=0;i!=k;i++)&#123; heapInsert(kHeap,arr[i],i); &#125; for(int i = k;i !=arr.length;i++)&#123; if(arr[i]&lt;kHeap[0])&#123; kHeap[0]=arr[i]; heapify(kHeap,0,k); &#125; &#125; return kHeap; &#125; public static void heapify(int [] arr, int index ,int heapsize)&#123; int left= index*2+1; int right=index*2+2; int largest=index; while(left&lt;heapsize)&#123; if(arr[left]&gt;arr[index])&#123; largest=left; &#125; if(right&lt;heapsize &amp;&amp; arr[right]&gt;arr[largest])&#123; largest=right; &#125; if(largest!=index)&#123; swap(arr,largest,index); &#125;else &#123; break; &#125; index=largest; left= index*2+1; right=index*2+2; &#125; &#125; public static void heapInsert(int [] kHeap ,int arri ,int i)&#123; kHeap[i]=arri; while (i!=0)&#123; int parent=(i-1)/2; if(kHeap[parent]&lt;kHeap[i])&#123; swap(kHeap,parent,i); i=parent; &#125;else &#123; break; &#125; &#125; &#125; public static void swap(int [] arr ,int m ,int n)&#123; int temp=arr[m]; arr[m]=arr[n]; arr[n]=temp; &#125; &#125; 三数排序给定一个数组，其中只有三个数0,1,2三个值，请实现arr排序。 三个颜色的球排序 用left和right标记数组头和尾，用index遍历，遇到该交换的交换，直到index==right为止。 1234567891011121314151617181920212223242526272829303132333435import java.util.HashSet;public class Main &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,0,2,0,1,2,1,0 ,2, 2,0&#125;; leftUnique(arr); &#125; public static void leftUnique(int[] arr) &#123; if (arr.length &lt;2 || arr == null) &#123; return; &#125; int left=-1; int index=0; int right=arr.length; while (index&lt;right)&#123; if(arr[index]==0)&#123; swap(arr,++left,index++); &#125;else if(arr[index]==2)&#123; swap(arr,--right,index); &#125;else &#123; index++; &#125; &#125; for(int i=0;i&lt;arr.length;i++)&#123; System.out.print(arr[i]+" "); &#125; &#125; public static int [] swap(int[] arr,int m, int n)&#123; int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; &#125;&#125; 转圈打印矩阵给一个整型矩阵matrix，按照转圈的方式打印它。 1 2 3 4 5 6 7 8 9 打印就是：1 2 3 6 9 8 7 4 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CircleDynamic &#123; public static void main(String [] args)&#123; int [][] m= &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;, &#123;13,14,15,16&#125;&#125;; spirOrderPrint(m); &#125; public static void spirOrderPrint(int [][]matrix)&#123; int tR = 0; int tC = 0; int dR=matrix.length-1; int dC=matrix[0].length-1; while (tR&lt;=dR &amp;&amp; tC&lt;=dC)&#123; printEdge(matrix,tR++,tC++,dR--,dC--); &#125; &#125; public static void printEdge(int [][] matrix ,int tR ,int tC,int dR , int dC)&#123; if(tR==dR)&#123; for(int i=0;i&lt;=dC;i++)&#123; System.out.print(matrix[tR][i]+" "); &#125; &#125;else if(tC==dC)&#123; for(int i=0;i&lt;dR ;i++)&#123; System.out.print(matrix[i][tC]+ " "); &#125; &#125;else &#123; int curC=tC; int curR=tR; while (curC != dC)&#123; System.out.print(matrix[tR][curC]+" "); curC++; &#125; while (curR!=dR)&#123; System.out.print(matrix[curR][dC]+" "); curR++; &#125; while (curC != tC)&#123; System.out.print(matrix[dR][curC]+" "); curC--; &#125; while (curR!=tR)&#123; System.out.print(matrix[curR][tC]+" "); curR--; &#125; &#125; &#125;&#125; “之”字形打印矩阵 上坐标（tR,tC）初始为（0,0），先向右走（tC++）,再向下走tR++ 下坐标类似 打印斜线方向用boolean判断 12345678910111213141516171819202122232425262728293031323334353637383940public class CircleDynamic &#123; public static void main(String [] args)&#123; int [][] m= &#123;&#123;1,2,3, 4&#125;, &#123;5,6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;; printMatrixZigZag(m); &#125; public static void printMatrixZigZag(int [][] matrix)&#123; int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length-1; int endC = matrix[0].length-1; boolean flag=false; while (tR!=matrix.length)&#123; printZigZag(matrix,tR,tC,dR,dC,flag); tC=tC==endC?tC:tC+1; tR= tC==endC ?tR+1:tR; dR=dR==endR?dR:dR+1; dC=dR==endR?dC+1:dC; flag=!flag; &#125; &#125; public static void printZigZag(int [][] matrix,int tR,int tC,int dR,int dC,boolean flag )&#123; if(flag)&#123; while (tR!=dR+1)&#123; System.out.print(matrix[tR++][tC--]+" "); &#125; &#125;else &#123; while (dR!=tC-1) &#123; System.out.print(matrix[dR--][dC++]+" "); &#125; &#125; &#125;&#125; 自然数数组的排序给定一个长度为N的整型数组arr，其中有N个互不相等的自然数1~N，请实现arr的排序，但是不要把下标0~N-1位置上的数值通过直接赋值的方式替换成1~N。 要求：时间复杂度为O(N)，额外空间复杂度为O(1)。 思路： 1.从左向右遍历arr，假设当前遍历到i位置。 2.if arr[i]==i+1,不需要调整，继续遍历。 3.if arr[i]!=i+1,进行调整。 根据调整功能的方法不同，可以有不同的实现过程。 1234567891011121314151617181920public class CircleDynamic &#123; public static void main(String [] args)&#123; int [] m= &#123;1,2,5,3, 4&#125;; m=sort(m); for(int i=0;i&lt;m.length;i++)&#123; System.out.println(m[i]); &#125; &#125; public static int [] sort(int [] matrix)&#123; for(int i=0;i&lt;matrix.length;i++)&#123; while(matrix[i]!=i+1)&#123; int temp=matrix[matrix[i]-1]; matrix[matrix[i]-1]=matrix[i]; matrix[i]=temp; &#125; &#125; return matrix; &#125;&#125; 奇数下标都是奇数或偶数下标都是偶数给定一个长度不小于2的数组arr，实现一个函数调整arr，要么使所有的偶数下标都是偶数，要么使所有的奇数下标都是奇数。 要求：时间复杂度为O(N),额外空间复杂度为O(1)。 算法解释： 最后位置的数是偶数，就替换前面的偶数下标，最后位置的是奇数，就替换前面的奇数下标，每替换一次，最后位置的数都是变化的，这样就都替换了。 12345678910111213141516171819202122232425262728293031323334public class CircleDynamic &#123; public static void main(String [] args)&#123; int [] m= &#123;1,8,3,2,4,6&#125;; modify(m); &#125; public static void modify(int [] matrix)&#123; if(matrix==null || matrix.length&lt;2)&#123; return; &#125; int even=0; int odd=1; int end=matrix.length-1; while (even&lt;=end &amp;&amp; odd&lt;=end)&#123; if((matrix[end]&amp;1)==0)&#123; swap(matrix,even,end); even+=2; &#125;else &#123; swap(matrix,odd,end); odd+=2; &#125; &#125; for(int i=0;i&lt;matrix.length;i++)&#123; System.out.println(matrix[i]); &#125; &#125; public static void swap(int [] m,int index1,int index2)&#123; int temp=m[index1]; m[index1]=m[index2]; m[index2]=temp; &#125;&#125; 子数组的最大累加和问题给定一个数组，返回子数组的最大累加和。 例如：arr=[1,-2,3,5,-2,6,-1]，所有子数组中，[3,5,-2,6]可以累加出最大的和12，return 12. 时间复杂度为O(N)，额外空间复杂度为O(1)。 如果arr中没有正数，产生的最大累加和一定是数组中的最大值。 如果arr中有正数，从左向右遍历arr，用变量cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。当cur&lt;0时，舍弃当前部分，令cur=0，表示重新从下一个数开始累加。当cur&gt;=0时，每一次的累加都可能是最大的累加和，所以，用另外一个变量max全程跟踪cur出现的最大值。 cur累加到负数就重新累加，max记录当前cur的最大值。 123456789101112131415161718192021222324public class CircleDynamic &#123; public static void main(String [] args)&#123; int [] m= &#123;1,-2,3,5,-2,6,-1&#125;; maxSum(m); &#125; public static void maxSum(int[] m)&#123; if(m==null||m.length==0)&#123; return; &#125; int cur=0; int max=0; for(int i=0;i&lt;m.length;i++)&#123; cur+=m[i]; if(max&lt;cur)&#123; max=cur; &#125; if(cur&lt;0)&#123; cur=0; &#125; &#125; System.out.println(max); &#125;&#125; 子矩阵的最大累计和问题给定一个矩阵，其中的值有正、有负、有0。返回子矩阵的最大累计和。 如果一个矩阵一共有K行且限定必须含有K行元素的情况下，只要把矩阵中每一行的K个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含有K行元素的子矩阵中的最大累加和。 用i动态测试每一层往下累计的最大值，i+1实际上是把i层之上的全部不算。实现动态遍历 j和k是普通遍历 用s[k]存每次往下加的数字 cur加s[k]如果大就保存，如果不是最大就不存，如果小于0就清零。 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; int[][] m = &#123;&#123;-90, 48, 78&#125;, &#123;64, -40, 64&#125;, &#123;-81, -7, 66&#125;&#125;; maxSum(m); &#125; public static void maxSum(int[][] m) &#123; if (m == null || m.length == 0 || m[0].length == 0) &#123; return; &#125; int cur = 0; int max = Integer.MIN_VALUE; int []s=null; for (int i = 0; i &lt; m.length; i++) &#123; s = new int[m[0].length]; for (int j = i; j &lt; m.length; j++) &#123; cur = 0; for (int k = 0; k &lt; m[0].length; k++) &#123; s[k] += m[j][k]; cur += s[k]; max = Math.max(max, cur); if (cur &lt; 0) &#123; cur = 0; &#125; &#125; &#125; &#125; System.out.println(max); &#125;&#125; 在数组中找到一个局部最小的位置定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]为局部最小。如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小。如果0&lt;i&lt;N-1，arr[i]&lt;arr[i+1]&amp;&amp;arr[i]&lt;arr[i-1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任何两个相邻的数不相等。写一个函数，只需返回arr中任何一个局部最小出现的位置即可。 利用二分查找可以做到时间复杂度O(logN)、额外空间复杂度为O(1) 12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) &#123; int[] m = &#123;90,78, 48, 78&#125;; System.out.println(getLessIndex(m)); &#125; public static int getLessIndex(int[] arr) &#123; if(arr==null || arr.length==0)&#123; return -1; &#125; if(arr[0]&lt;arr[1])&#123; return 0; &#125; if(arr[arr.length-1]&lt;arr[arr.length-2])&#123; return arr[arr.length-1]; &#125; int left = 1; int right= arr.length-2; int mid=0; while (left&lt;right)&#123; mid=(right+left)/2; if(arr[mid]&gt;arr[mid-1])&#123; right=mid-1; &#125;else if(arr[mid]&gt;arr[mid+1])&#123; left=mid+1; &#125;else &#123; return mid; &#125; &#125; return left; &#125; &#125; 不包含本位置值的累乘数组给定一个整型数组，返回不包含本位置的累乘数组。 例如：arr=[2,3,1,4],返回[12,8,24,6],即除自己外，其他位置的类乘。 1.时间复杂度为O(N). 2.除需要返回的结果数组之外，额外空间复杂度为O(1). 使用除法： 结果数组记为res，所有数的乘积记为all。如果数组中不含0，则设置res[i]=all/arr[i]。如果数组中有一个0，对唯一的arr[i]==0的位置令res[i]=all,其他位置都是0。如果数组中0的数量大于1，那么res所有位置上的值都是0。 不使用除法： 1.生成两个长度和arr一样的新数组lr[]和rl[]，lr[i]=arr[0…i],rl[i]=arr[i…N-1]。 2.res[i]=lr[i-1]*rl[i+1] 3.res[0]=rl[1],res[N-1]=lr[N-2] 这里又额外使用了两个数组，可以通过res数组复用的方式省略掉这两个数组，先把res数组作为辅助计算的数组，然后把res调整成结果数组返回。 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; int[] m = &#123;2,3, 1, 4&#125;; m= product(m); for(int i=0;i&lt;m.length;i++)&#123; System.out.println(m[i]); &#125; &#125; public static int [] product(int[] arr) &#123; if(arr==null || arr.length==0)&#123; return null; &#125; int[] res=new int [arr.length]; res[arr.length-1]=1; for(int i=arr.length-2;i&gt;=0;i--)&#123; res[i]=res[i+1]*arr[i+1]; &#125; int temp=1; for(int i=0;i&lt;arr.length;i++)&#123; res[i]*=temp; temp*=arr[i]; &#125; return res; &#125; &#125; 求最短通路值用一个整形矩阵matrix表示一个网络，1代表有路，0代表没路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。 例如： 1 0 1 1 1 1 0 1 0 1 1 1 1 0 1 0 0 0 0 1 通路只有1条，由12个1组成，所以返回12。 使用宽度优先遍历即可，如果矩阵大小为NM，时间复杂度为O(NM)， 1.开始时生成map矩阵，map[i][j]的含义是从（0,0）位置走到（i，j）位置最短的路径值。然后将左上角位置（0,0）的行坐标和列坐标放入行队列rQ、列队列 cQ。 2.不断从队列弹出一个位置（r,c）,然后看这个位置的上下左右四个位置哪些在matrix上的值是1，这些都是能走的位置。 3.将那些能走的位置设置好各自在map中的值，即map[r][c]+1。同时将这些位置加入到rQ和cQ的中，用队列完成宽度优先遍历。 4.在步骤3中，如果一个位置走过，就不要重复走，这个逻辑可以根据一个位置在map中的值来确定，比如map[i][j]!=0，就可以知道这个位置之前走过。 5.一直重复步骤2~步骤4。直到遇到右下角位置，说明已经找到终点，返回终点在map中的值即可，如果rQ和cQ已经为空都没有遇到终点位置，return 0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.LinkedList;import java.util.Queue;public class Main &#123; public static void main(String[] args) &#123; int[][] m = &#123; &#123;1,0,1,1,1&#125;, &#123;1,0,1,0,1&#125;, &#123;1,1,1,0,1&#125;, &#123;0,0,0,0,1&#125; &#125;; System.out.println(minPathValue(m)); &#125; public static int minPathValue(int [][] m)&#123; if(m==null || m.length==0|| m[0].length==0||m[0][0]!=1||m[m.length-1][m[0].length-1]!=1)&#123; return 0; &#125; int res=0; int [][] map=new int [m.length][m[0].length]; map[0][0]=1; Queue&lt;Integer&gt; rQ=new LinkedList&lt;Integer&gt;(); Queue&lt;Integer&gt; cQ=new LinkedList&lt;Integer&gt;(); rQ.add(0); cQ.add(0); int r=0; int c=0; while (!rQ.isEmpty())&#123; r=rQ.poll(); c=cQ.poll(); if( ( r==m.length-1 ) &amp;&amp; ( c==m[0].length-1))&#123; //查map路径 for(int i=0;i&lt;map.length;i++)&#123; for (int j=0;j&lt;map[0].length;j++)&#123; System.out.print(map[i][j]+" "); &#125; System.out.println(" "); &#125; //输出结果 return map[r][c]; &#125; walkTo(map[r][c],r-1,c,m,map,rQ,cQ); walkTo(map[r][c],r+1,c,m,map,rQ,cQ); walkTo(map[r][c],r,c-1,m,map,rQ,cQ); walkTo(map[r][c],r,c+1,m,map,rQ,cQ); &#125; return res; &#125; public static void walkTo(int pre,int toR,int toC ,int [][]m , int [][] map,Queue&lt;Integer&gt; rQ , Queue&lt;Integer&gt; cQ )&#123; if (toR &lt; 0 || toR == m.length || toC &lt; 0 || toC == m[0].length || m[toR][toC] != 1 || map[toR][toC] != 0) &#123; return; &#125; map[toR][toC]=pre+1; rQ.add(toR); cQ.add(toC); &#125; &#125;---res:1 0 7 8 9 2 0 6 0 10 3 4 5 0 11 0 0 0 0 12 12 最长的可整合数组的长度如果一个数组再排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6],符合每相邻两个数差的绝对值为1，所以这个数组为可整合数组。 给定一个整型数组，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3]的最大可整合子数组为[5,3,2,6,4]，所以返回5. 一个数组中如果没有重复元素，并且如果最大值减去最小值，再加上1的结果等于元素的个数（max-min+1=元素个数）,那么这个数组就是可整合数组。 这样，验证一个数组是否是可整合数组的时间复杂度可以从第一种方法的O(NlogN)减少至O(1),整个过程的时间复杂度为O(N^2) 无需排序，仅仅只需要遍历比较大小 12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) &#123; int[] m = &#123; 5,5,3,2,6,4,3&#125;; System.out.println(getLIL(m)); &#125; public static int getLIL(int [] arr)&#123; if(arr.length==0||arr==null)&#123; return 0; &#125; int max=0; int min=0; int len=0; HashSet&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;arr.length;i++)&#123; max=Integer.MIN_VALUE; min=Integer.MAX_VALUE; for(int j=i;j&lt;arr.length;j++)&#123; if(set.contains(arr[j]))&#123; break; &#125; set.add(arr[j]); max=Math.max(max,arr[j]); min=Math.min(min,arr[j]); if(max-min==j-i)&#123; len=Math.max(len,j-i+1); &#125; &#125; set.clear(); &#125; return len; &#125; &#125; 边界都是1的最大正方形大小给定一个M*N的矩阵，在这个矩阵中，只有0和1两种值，返回边框全是1的最大正方形的边长长度。 例如： ​ [0, 1, 1, 1, 1], ​ [0, 0, 1, 0, 1], ​ [0, 1, 1, 0, 1], ​ [0, 1, 1, 1, 1], ​ [0, 1, 0, 1, 1] 其中，边框全是1的最大正方形的大小为4。 解析： 1.正方形边长为0&lt;=size&lt;=Math.min(rows,cols); 2.边长为size时，左上角的坐标范围为 0&lt;=i&lt;=rows-size，0&lt;=j&lt;=cols-size; 3.使用预处理矩阵right和down，空间换时间，right[i][j]保存matrix[i][j]包括自己往右边有多少个1，同理down[i][j]。 3.对每一个左上角的边长为size的矩形判断边上是否全为1，发现有满足的直接返回当前size。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Main &#123; public static void main(String[] args) &#123; int[][] arr = &#123; &#123;0,1,1,1,1&#125;, &#123;0,1,0,0,1&#125;, &#123;0,1,0,0,1&#125;, &#123;0,1,1,1,1&#125;, &#123;0,1,0,1,1&#125;&#125;; System.out.println(getMaxSize(arr)); &#125; public static int getMaxSize(int [][]m)&#123; int [][] right=new int [m.length][m[0].length]; int [][] down= new int [m.length][m[0].length]; setBorderMap(m,right,down); for(int size=Math.min(m.length,m[0].length);size!=0;size--)&#123; if(hasSizeOfBorder(size,right,down))&#123; return size; &#125; &#125; return 0; &#125; public static void setBorderMap(int [][] m,int [][]right ,int [][]down)&#123; int r=m.length; int c=m[0].length; if(m[r-1][c-1]==1)&#123; right[r-1][c-1]=1; down[r-1][c-1]=1; &#125; for(int i=r-2;i&gt;=0;i--)&#123; if(m[i][c-1]==1)&#123; right[i][c-1]=1; down[i][c-1]=down[i+1][c-1]+1; &#125; &#125; for(int j=c-2;j&gt;=0;j--)&#123; if(m[r-1][j]==1)&#123; right[r-1][j]=right[r-1][j+1]+1; down[r-1][j]=1; &#125; &#125; for(int i=r-2;i&gt;=0;i--)&#123; for (int j=c-2;j&gt;=0;j--)&#123; right[i][j]=right[i][j+1]+1; down[i][j]=down[i+1][j]+1; &#125; &#125; &#125; public static boolean hasSizeOfBorder(int size ,int [][]right ,int [][] down)&#123; for(int i=0;i&lt;right.length-size+1;i++)&#123; for(int j=0;j&lt;right[0].length-size+1;j++)&#123; if(right[i][j]&gt;=size&amp;&amp;down[i][j]&gt;=size &amp;&amp;right[i+size-1][j]&gt;=size &amp;&amp;down[i][j+size-1]&gt;=size) return true; &#125; &#125; return false; &#125;&#125; 需要排序的最短子数组长度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package Array;/** * Created by zdmein on 2017/9/15. * 需要排序的最短子数组长度 * 思路： 用noMin 记录从右到左，可以遍历的，最左边开始需要重新排的 用noMax 记录从左到右，可以遍历的，最右边需要重新排的 1, 5,3,4,2, 6,7 返回 4 */public class getMinLength1 &#123; public static void main(String args[])&#123; int []arr=&#123;1,5,3,4,2,6,7&#125;; System.out.println(getMinLength(arr)); &#125; public static int getMinLength(int [] arr)&#123; if(arr==null||arr.length&lt;2)&#123; return 0; &#125; int min=arr[arr.length-1]; int noMin=-1; for(int i=arr.length-2;i&gt;=0;i--)&#123; if(arr[i]&gt;min)&#123; noMin=i; &#125;else &#123; min=Math.min(arr[i],min); &#125; &#125; if(noMin==-1) return 0; int max=arr[0]; int noMax=-1; for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;max)&#123; noMax=i; &#125;else &#123; max=Math.max(max,arr[i]); &#125; &#125; return noMax-noMin+1; &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-2]]></title>
    <url>%2F2017%2F08%2F11%2FJava%E5%9F%BA%E7%A1%80-2%2F</url>
    <content type="text"><![CDATA[实干兴邦 J2SE基础 九种基本数据类型的大小，以及他们的封装类。 基本类型 大小(位) 字节 最小值 最大值 封装类 boolean - 1 - - Boolean byte 8 1 -128 127 Byte char 16 2 Unicode 0 Unicode 2^16-1 Character short 16 2 -2^15 2^15-1 Short int 32 4 -2^31 2^31-1 Integer float 32 4 Float double 64 8 Double long 64 8 -2^63 2^63-1 Long void - - - Void Switch能否用string做参数？JDK1.7之前是只支持int 或char JDK1.7开始支持String JDK1.5 开始支持 Enum 类 equals与==的区别“==” 用于基本数据类型的比较，判断引用是否指向堆内存的同一快地址。 equals 用于判断两个变量是否是对同一个对象的引用，即堆中的内容是否相同，返回值为布尔类型。 可以用equals方法检测两个字符串是否相等。 一定不能使用 == 运算符检测两个字符串是否相等！== 用来确定两个字符串是否放置在同一个位置上。 如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但是实际上只有字符串常量是共享的，而+或者substring等操作产生的结果并不是共享的。 Object有哪些公用方法？ equals方法 Object类中的equals方法用于检测一个对象是否等于另外一个对象。 hashCode方法 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 toString方法 用于返回表示对象值的字符串。 Java的四种引用，强弱软虚，用到的场景 强引用 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收期绝不会回收它。 软引用 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些 对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以用来实现内存敏感的高速缓存。 弱引用 弱引用与软引用的区别在于：只具有弱引用的对象具有更短暂的生命周期。 在垃圾回收器线程扫描它所管辖的内存区域过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 不过，由于垃圾回收器是一个优先级很低的线程，因此不一样很快发现那些只有弱引用的对象。 如果你想引用一个对象，但这个对象具有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。 虚引用 虚引用不会决定对象的生命周期，如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何适合都可能被垃圾回收器回收。 总结： Java 4种引用的级别由高到低依次为： 强》软》弱》虚 Hashcode的作用hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 ArrayList、LinkedList、Vector的区别ArrayList本质上是一个数组，当更多的元素添加到ArrayList中时，其大小会动态的增长，内部元素通过get和set方式进行访问。不是线程安全的。 LinkedList是一个双链表，因此在删除和添加元素的时候优于数组形式的ArrayList，但是在get和set方面弱于ArrayList； Vector几乎和ArrayList一样，但是Vector是线程安全的，在更多元素进来时，Vector每次请求双倍的空间，而ArrayList每次对size增长50%。 String、StringBuffer与StringBuilder的区别String是不可变类 StringBuffer是可变类 StringBuilder不是线程安全的 在执行效率方面，StringBuilder最高，StringBuffer次之，String最低 如果要操作的数据量比较小，应优先用String类 如果是在单线程下操作大量数据，应优先用StringBuilder类 如果在多线程下操作大量数据，应优先考虑StringBuffer类。 Map、Set、List、Queue、Stack的特点与用法 Map 键映射到值的对象。 一个映射不能包含重复的键，每个键最多只能映射到一个值。 某些映射实现可明确保证其顺序，如TreeMap类；另一些映射实现不保证顺序，如HashMap类。 Map中元素，可以将key序列，value序列单独抽取出来。 使用keySet()抽取key序列，将map中所有keys生成一个Set。 使用 values() 抽取value序列，将map中的所有values生成一个Collection。 为什么一个是Set，一个是Collection。因为key是独一无二的，value允许重复。 Set 一个不包含重复元素的Collection。 不可随机访问包含的元素 只能用lterator实现单向遍历 Set没有同步方法 List 可随机访问包含的元素 元素是有序的 可在任意位置增删元素 不管访问多少次，元素位置不变 允许重复元素 用Iterator实现单向遍历，也可用ListIterator实现双向遍历 Queue 先进先出 用offer()来加入元素 用poll()来获取并移出元素 peek()方法查看或使用前端元素 Queue实现通常不允许插入null元素 Stack 后进先出 Stack继承自Vector，是同步的 提供了push、pop、peek、empty方法 用法 如果涉及到堆栈，队列等操作，应该考虑用List 对于需要快速插入，删除元素，应该用LinkedList 如果需要快速随机访问元素，应该用ArrayList 如果单线程环境，考虑非同步的类，效率较高。 HashMap和HashTable的区别主要区别：线程安全，同步，速度 HashMap几乎等价于HashTable，除了HashMap是非同步的，并可以接受nullHashMap和ConcurrentHashMap的区别，HashMap的底层源码 HashMap的本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来，新插入的在前面。 ConcurrentHashMap在HashMap的基础上，将数据分为多个segment，默认16个，然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。 HashMap就是一个Entry数组，Entry数组中包含了键和值，其中next也是一个Entry对象，当hash冲突时，形成一个链表。 1234567891011121314151617static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; //hash值冲突后存放在链表的下一个 key = k; hash = h; &#125; ......... &#125; HashMap存储数据的put方法 123456789101112131415161718192021public V put(K key, V value) &#123; if (key == null) //如果键为null的话，调用putForNullKey(value) return putForNullKey(value); int hash = hash(key.hashCode());//根据键的hashCode计算hash码 int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //处理冲突的，如果hash值相同，则在该位置用链表存储 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; //如果key相同则覆盖并返回旧值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 当我们往HashMap中put元素时，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了，如果这个元素的位置上已经存在其他元素了，那么在同一个位子上的元素将会以链表的形式存放，新加入的放链表头，之前加入的放后面。 从HashMap中get元素时，首先计算key的hash值，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 如果没有与key相同的键，则调用addEntry方法创建一个Entry对象： 1234567void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //如果要加入的位置有值，将该位置原先的值设置为新entry的next,也就是新entry链表的下一个节点 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) //如果大于临界值就扩容 resize(2 * table.length); //以2的倍数扩容 &#125; 扩容数据 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable);//用来将原先table的元素全部移到newTable里面 table = newTable; //再将newTable赋值给table threshold = (int)(newCapacity * loadFactor);//重新计算临界值 &#125; TreeMap、HashMap、LindedHashMap的区别。Collection包结构，与Collections的区别。try catch finally，try里有return，finally还执行么？ try中没有异常且try中有return try—finally—return try中有异常，try中有return try—catch—finally—return 总之finally永远执行 Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 Java面向对象的三个特征与含义。 Override和Overload的含义与区别 重写（Override） 重写是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值和形参都不能改变。即外壳不变，重写内在实现。 重写的好处在于子类可以根据需要，定义特定于自己的行为。 123456789101112131415161718192021public class LiftOff &#123; public static void main(String args [])&#123; Animal a= new Animal(); Animal b = new pig(); a.eat(); b.eat(); &#125; &#125; class Animal&#123; public void eat()&#123; System.out.println("Animal eat xx "); &#125; &#125; class pig extends Animal&#123; public void eat()&#123; System.out.println("pig eat siliao"); &#125; &#125; 12Animal eat xx pig eat siliao 重写规则： 参数列表必须完全与被重写方法相同（也就是说重写，不能添加写方法，不能添加参数。） 返回类型必须完全与被重写方法的返回类型相同 父类的成员方法只能被他的子类重写 声明为final的方法不能被重写 声明为static的方法不能被重写，但是能再次声明。 构造方法不能被重写 重载（Overload） 重载是在同一个类里，方法名字相同，参数不同，返回类型可相同也可不同的多个方法。 每个重载的方法都必须有一个独一无二的参数类型列表。 被重载的方法必须改变参数列表，被重载的方法可以改变返回类型，被重载的方法可以改变访问修饰符，方法能在同一个类中或在一个子类中被重载。 12345678910111213141516171819202122public class LiftOff &#123; public int test()&#123; System.out.println("Overload1"); return 1; &#125; public void test(int a)&#123; System.out.println("Overload1"+ a); &#125; public String test(String a1 , String a2)&#123; System.out.println("Overload1"+ a1+a2); return a1; &#125; public static void main(String args [])&#123; LiftOff t=new LiftOff(); System.out.println(t.test()); t.test(2); System.out.println(t.test("asd","erf")); &#125; &#125; 12345Overload11Overload12Overload1asderfasd 重载和重写区别： 重载方法（Overload） 重写方法（Override） 参数列表 必须修改 不能改 返回类型 可以修改 不能改 异常 可以修改 可以减少或删除，不能抛出新的 访问修饰符 可以修改 只能降低限制，不能变高限制 限制又低到高： public、protected、private Interface与abstract类的区别如果一个类中包含抽象方法，那么这个类就是抽象类。类或方法声明为abstract 接口就是指一个方法的集合，接口中所有方法都没有方法体，接口通过关键字interface实现。 接口和抽象类的相同点： 都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才才能被实例化。 不同点： 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法；而抽象类可以有定义和实现，即其方法可以在抽象类中被实现。 接口需要实现（用implement），但抽象类只能被继承（用extends），一个类可以实现多个接口，但是一个类只可以继承一个抽象类，因此使用接口可以间接达到多重继承的目的。 接口强调特定功能的实现，”has - a” ；抽象类强调所属关系，”is - a “ 接口中定义的成员变量默认为 public static final ， 只能够有静态的不能被修改的数据成员，而且，必须给其赋值，其所以的成员方法都是public，abstract的，而且只能被这两个关键字修饰。而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法，而且，抽象类中的成员变量默认为default，当然也可以定义为private，protected，public。所以，当功能需要累积时，用抽象类，不需要累积时，用接口。 接口被运用于实现比较常用的功能，便于以后的维护；抽象类更倾向于充当公共类的角色，不适用于日后重新修改内部代码。 Static class 与non static class的区别java多态的实现原理实现多线程的两种方法：Thread与Runable线程同步的方法：sychronized、lock、reentrantLock等 锁的等级：方法锁、对象锁、类锁 Java中锁的机制： synchronized 在修饰代码块的时候需要一个reference对象作为锁的对象。 在修饰方法的时候默认是当前对象作为锁的对象。 在修饰类的时候默认是当前的Class对象作为锁的对象。 线程同步的方法： sychronized、lock、reentrantLock分析 方法锁（synchronized修饰方法时） 通过在方法声明中加入synchronized关键字来声明synchronized方法。 对象锁（synchronized修饰方法或代码块） 当一个对象中有synchronized method 或 synchronized block 的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁，如何此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁） 写出生产者消费者模式。ThreadLocal的设计理念与作用。ThreadPool用法与优势。Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。wait()和sleep()的区别他们都是一种使线程暂停执行的方法 区别： 原理不同。sleep()是Thread类的静态方法；wait()方法是Object类的方法。 对锁的处理机制不同。sleep不放，wait释放。 使用区域不同 sleep()必须捕获异常，wait()不需要 foreach与正常for循环效率对比Java IO与NIO。反射的作用与原理反射机制能够实现在运行时对类进行装在，因此能增加程序的灵活性。 功能： 得到一个对象所属的类； 获取一个类所有的成员变量和方法； 在运行时创建对象 在运行时调用对象的方法 Java创建对象的方式有几种 通过new实例化一个对象 通过反射机制创建对象 clone() 反序列化的方式 泛型常用特点，List能否转为List。解析XML的几种方式的原理与特点：DOM、SAX、PULL。Java与C++对比。Java8新特性 Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 设计模式：单例、工厂、适配器、责任链、观察者等等JNI的使用Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。 推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》 JVM 内存模型以及分区，需要详细到每个区放什么。 堆里面的分区：Eden，survival from to，老年代，各自的特点。 对象创建方法，对象的内存分配，对象的访问定位。 GC的两种判定方法：引用计数与引用链。 GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ GC收集器有哪些？CMS收集器与G1收集器的特点。 Minor GC与Full GC分别在什么时候发生？ 几种常用的内存调试工具：jmap、jstack、jconsole。 类加载的五个过程：加载、验证、准备、解析、初始化。 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 分派：静态分派与动态分派。 JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。 推荐书籍：《深入理解java虚拟机》 TCP/IP OSI与TCP/IP各层的结构与功能，都有哪些协议。 TCP与UDP的区别。 TCP报文结构。 TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。 TCP拥塞控制。 TCP滑动窗口与回退N针协议。 Http的报文结构。 Http的状态码含义。 Http request的几种类型。 Http1.1和Http1.0的区别 Http怎么处理长连接。 Cookie与Session的作用于原理。 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。 Ping的整个过程。ICMP报文是什么。 C/S模式下使用socket通信，几个关键函数。 IP地址分类。 路由器与交换机区别。 网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。 推荐书籍：《TCP/IP协议族》 项目关于项目，这部分每个人的所做的项目不同，所以不能具体的讲。项目不再与好与不好，在于你会不会包装，有时候一个很low的项目也能包装成比较高大上的项目，多用一些专业名词，突出关键字，能使面试官能比较容易抓住重点。在聊项目的过程中，其实你的整个介绍应该是有一个大体的逻辑，这个时候是在考验你的表达与叙述能力，所以好好准备很重要。 面试官喜欢问的问题无非就几个点： XXX（某个比较重要的点）是怎么实现的？ 你在项目中遇到的最大的困难是什么，怎么解决的？ 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？ XXX（一个新功能）需要实现，你有什么思路？ 其实你应该能够预料到面试官要问的地方，请提前准备好，如果被问到没有准备到的地方，也不要紧张，一定要说出自己的想法，对不对都不是关键，主要是有自己的想法，另外，你应该对你的项目整体框架和你做的部分足够熟悉。 SpringBoot的主要特性其他你应该问的问题 面试里，最后面完之后一般面试官都会问你，你有没有什么要问他的。其实这个问题是有考究的，问好了其实是有加分的，一般不要问薪资，主要应该是：关于公司的、技术和自身成长的。 以下是我常问的几个问题，如果需要可以参考： 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？ 贵公司XXX业务发展很好，这是公司发展的重点么？ 对技术和业务怎么看？ 贵公司一般的团队是多大，几个人负责一个产品或者业务？ 贵公司的开发中是否会使用到一些最新技术？ 对新人有没有什么培训，会不会安排导师？ 对Full Stack怎么看？ 你觉得我有哪些需要提高的地方？ 知识面除了基础外，你还应该对其他领域的知识有多少有所涉猎。对于你所熟悉的领域，你需要多了解一点新技术与科技前沿，你才能和面试官谈笑风生。 软实力什么是软实力，就是你的人际交往、灵活应变能力，在面试过程中，良好的礼节、流畅的表达、积极的交流其实都是非常重要的。很多公司可能不光看你的技术水平怎么样，而更看重的是你这个人怎么样的。所以在面试过程中，请保持诚信、积极、乐观、幽默，这样更容易得到公司青睐。 很多时候我们都会遇到一个情况，就是面试官的问题我不会，这时候大多数情况下不要马上说我不会，要懂得牵引，例如面试官问我C++的多态原理，我不懂，但我知道java的，哪我可以向面试官解释说我知道java的，类似的这种可以往相关的地方迁移（但是需要注意的是一定不要不懂装懂，被拆穿了是很尴尬的），意思就是你要尽可能的展示自己，表现出你的主动性，向面试官推销自己。 还有就是遇到智力题的时候，不要什么都不说，面试官其实不是在看你的答案，而是在看你的逻辑思维，你只要说出你自己的见解，有一定的思考过程就行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（递归和动态规划）》]]></title>
    <url>%2F2017%2F08%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[递归：将问题分解成子问题求解，从较小的问题逐渐逼近原始问题，很多时候只需要在f（n-1）中加入或移除某些东西或稍作修改就可以求得f（n） 递归 是 考虑所有的情况，一般使用搜索（DFS /BFS）来实现。 一般可以使用记忆化搜索进行优化的递归算法，我们可以使用DP来进行优化。 斐波那契系列问题经典斐波那契问题代码就不写了，这个基本都会，需要注意的是： 递归方法的时间复杂度是：$O(2^N)$ 顺序计算的时间复杂度是：$O(N)$ 二阶递推数列的时间复杂度是：$O(logN)$ 大牛小牛问题假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。 第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。 每只小母牛3年之后成熟又可以生小母牛。 给定整数N，求出N年后牛的数量。 【举例】N=6，第1年1头成熟母牛记为a； 第2年a生了新的小母牛，记为b，总牛数为2； 题目最优解第3年a生了新的小母牛，记为c，总牛数为3； 第4年a生了新的小母牛，记为d，总牛数为4。 第5年b成熟了，a和b分别生了新的小母牛，总牛数为6； 第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9。 【要求】对以上所有的问题，请实现时间复杂度O(logN)的解法。 有 $F(N)=F(N-1)+F(N-3)$ 用一个矩阵乘法，且状态矩阵为$3*3$ 1234567891011public int c3(int n)&#123; if(n&lt;1)&#123; return 0; &#125; if(n==1||n==2||n=3)&#123; return n; &#125; int base[][]=&#123;&#123;1,1,0&#125;,&#123;0,0,1&#125;,&#123;1,0,0&#125;&#125;; //构造矩阵 int [][] res = matrixPower(base,n-3); //矩阵n-3次方 return 3*res[0][0]+2*res[1][0]+res[2][0]; &#125; 矩阵的最小路径和题目描述 有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。 给定一个矩阵map及它的行数n和列数m，请返回最小路径和。 EG： 1 、3 、5 、9 8 、1 、3、4 5、0、6、1 8、8、4、0 经典动态规划方法最终生成的dp矩阵如下： 1、4、9、18 9、5、8、12 14、5、11、12 22、13、15、12 因为第一行和第一列只有一条路走，就是一直沿着走； 第二行，第二列开始就是选择从上往下还是从左往右走； 每次都把每一步的最小路径加起来 时间复杂度$O(MN)$ ，空间复杂度$O(MN)$ 123456789101112131415161718192021222324252627282930313233public class CircleDynamic &#123; public static void main(String [] args)&#123; int [][] m= &#123;&#123;1,3,5,9&#125;, &#123;8,1,3,4&#125;, &#123;5,0,6,1&#125;, &#123;8,8,4,0&#125;&#125;; System.out.println(minPathSum1(m)); &#125; public static int minPathSum1(int [] []m)&#123; if (m == null || m.length == 0 || m[0]==null || m[0].length==0) &#123; return 0; &#125; int row=m.length; int col=m[0].length; int [][] dp=new int [row][col]; dp[0][0]=m[0][0]; for(int i=1;i&lt;row;i++)&#123; dp[i][0]=dp[i-1][0]+m[i][0]; &#125; for(int j=1;j&lt;col;j++)&#123; dp[0][j]=dp[0][j-1]+m[0][j]; &#125; for(int i=1;i&lt;row;i++)&#123; for(int j=1;j&lt;col;j++)&#123; dp[i][j]=Math.min(dp[i][j-1]+m[i][j],dp[i-1][j]+m[i][j]); &#125; &#125; return dp[row-1][col-1]; &#125;&#125; 压缩空间方法时间复杂度$O(M*N)$ ，空间复杂度$O(min ( M,N ))$ 123456789101112131415161718192021222324252627282930public class CircleDynamic &#123; public static void main(String [] args)&#123; int [][] m= &#123;&#123;1,3,5,9&#125;, &#123;8,1,3,4&#125;, &#123;5,0,6,1&#125;, &#123;8,8,4,0&#125;&#125;; System.out.println(minPathSum1(m)); &#125; public static int minPathSum1(int [] []m)&#123; if (m == null || m.length == 0 || m[0]==null || m[0].length==0) &#123; return 0; &#125; int more = Math.max(m.length,m[0].length); int less= Math.min(m.length,m[0].length); boolean rowmore=more==m.length; int arr[] = new int [less]; arr[0]=m[0][0]; for(int i=1;i&lt;less;i++)&#123; arr[i]=arr[i-1]+(rowmore?m[0][i]:m[i][0]); &#125; for(int i=1;i&lt;more;i++)&#123; arr[0]=arr[0]+(rowmore?m[i][0]:m[0][i]); for(int j=1;j&lt;less;j++)&#123; arr[j]=Math.min(arr[j],arr[j-1])+(rowmore?m[i][j]:m[j][i]); &#125; &#125; return arr[less-1]; &#125;&#125; 换钱的最少货币数题目： 给定数组arr, arr中所有的值都为正数且不重复。每个值代表一中面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数。 思路: 如果arr的长度为N, 则生成一个行数为N, 列数为aim+1的动态规划表dp[N][aim+1], dp[i][j]的含义为:在可以任意使用arr[0…i]货币的情况下，组成j所需的最小张数。 设: arr=[5,2,3,1] aim = 5 1.dp[0..N-1][0]的值表示找钱数为0时需要的最少张数，所以全设为0。（矩阵的第一列） 0 0 0 0 0 0 dp= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ​ 2.dp[0][0…aim]的值表示只能使用arr[0]货币也就是5的情况下，找0 ,1,2,3,4,5的钱的情况下。其中无法找开的一律设为32位的最大值，记为max. 0 max max max max 1 dp= 0 0 0 3.剩下的位置依次从左到右，再从上到下计算。假设计算到(i,j)位置，dp[i][j]的值可能来自下面的情况: 完全不使用当前货币arr[i]情况系的最少张数，即dp[i-1][j]的值 只使用一张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-arr[i]]+1 其中 j-arr[i]的值为使用了一张arr[i]后，还需要找多少钱。 i-1是指使用arr[i]之前的钱来兑换 只使用两张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-2*arr[i]]+2 只使用三张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-3*arr[i]]+3 所有情况中，取最小的纸张数。所以: dp[i][j] = min{dp[i-1][j], dp[i-1][j-k*arr[i]]} + k ==&gt; dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-x*arr[i]]+x (x &gt;= 1)}} ==&gt; 设x-1 = y &gt;= 0 ==&gt; x = y +1代入得 dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-arr[i]-y*arr[i]+y+1 (y&gt;=0)}} 又因为min{dp[i-1][j-arr[i]-y*arr[i]+ y (y&gt;=0)] =&gt; dp[i][j-arr[i]] 因为其中 dp[i-1][j-y*arr[i]+y] = dp[i][j] 最终有:dp[i][j] = min{dp[i-1][j], dp[i][j-arr[i]+1]} 如果 j-arr[i] &lt; 0,即发生越界。 说明arr[i]太大了，用一张都会超出钱数j，所以令dp[i][j]=dp[i-1][j]即可。 0 max max max max 1 dp = 0 max 1 max 2 1 0 max 1 1 2 1 0 1 1 1 2 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CircleDynamic &#123; public static void main(String [] args)&#123; int [] m= &#123;5,2,5,3&#125;; int aim = 15; System.out.println(minCoins(m,aim)); &#125; public static int minCoins(int [] arr,int aim)&#123; if(arr==null || arr.length==0|| aim&lt;0)&#123; return -1; &#125; int n=arr.length; int max=Integer.MAX_VALUE; int [][] dp=new int [n][aim+1]; for(int j=1;j&lt;aim;j++)&#123; dp[0][j]=max; if(j-arr[0]&gt;=0 &amp;&amp; dp[0][j-arr[0]]!=max)&#123; dp[0][j]=dp[0][j-arr[0]]+1; &#125; &#125; int left = 0; for(int i=1;i&lt;n ;i++)&#123; for(int j=1;j&lt;aim;j++)&#123; left=max; if(j-arr[i]&gt;=0&amp;&amp;dp[i][j-arr[i]]!=max)&#123; left=dp[i][j-arr[i]]+1; &#125; dp[i][j]=Math.min(left,dp[i-1][j]); &#125; &#125; for(int i=0;i&lt;n ;i++)&#123; for(int j=0;j&lt;aim;j++)&#123; System.out.print(dp[i][j]+ " " ); if(j==aim-1)&#123; System.out.println(" "); &#125; &#125; &#125; return dp[n-1][aim] !=max ?dp[n-1][aim-1]:-1; &#125;&#125; Result: 123450 2147483647 2147483647 2147483647 2147483647 1 2147483647 2147483647 2147483647 2147483647 2 2147483647 2147483647 2147483647 2147483647 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 1 2 1 2 2 2 3 2 3 3 3 4 4 数组中最长的连续数字序列给定一个无序的整数序列， 找最长的连续数字序列。 例如： 给定[100, 4, 200, 1, 3, 2], 最长的连续数字序列是[1, 2, 3, 4]。 输出4. 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; public static void main(String[] args) &#123; int[] arr = &#123;100,4,200,1,3,2&#125;; System.out.println(longestConsecutive(arr)); &#125; public static int longestConsecutive(int [] arr)&#123; if(arr.length==0||arr==null)&#123; return 0; &#125; int max=1; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;arr.length;i++)&#123; if(!map.containsKey(arr[i]))&#123; map.put(arr[i],1); if(map.containsKey(arr[i]-1))&#123; max=Math.max(max,merge(map,arr[i]-1,arr[i])); &#125; if(map.containsKey(arr[i]+1))&#123; max=Math.max(max,merge(map,arr[i],arr[i]+1)); &#125; &#125; &#125; return max; &#125; public static int merge(HashMap&lt;Integer,Integer&gt; map,int less,int more)&#123; //计算左边有几个数 int left=less-map.get(less)+1; //计算右边有几个数 int right=more+map.get(more)-1; //合计 int len=right-left+1; //标记 map.put(left,len); map.put(right,len); return len; &#125; &#125; 龙于地下城游戏问题给定一个二维数组map，含义是一张地图，例如： 123&#123;&#123;-2,-3,3&#125;, &#123;-5,-10,1&#125;, &#123;0,30,-5&#125;&#125; 游戏规则如下： 骑士从左上角出发，每次只能向下或者向右，直到右下才能见到公主； 每个格子代表骑士遭遇的事件，如果是负数，代表消耗血量，如果是正数，代表血瓶； 骑士走到任何一个位置，血量都不能低于1。 为了让骑士见到公主，骑士初始血量最少为多少？ 只能往下或往右，需要一个辅助数组dp[][] 来计算。那么可以逆着来计算。 12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) &#123; int[][] arr = &#123; &#123;-2,-3,3&#125;, &#123;-5,-10,1&#125;, &#123;0,30,-5&#125; &#125;; System.out.println(minHP(arr)); &#125; public static int minHP(int [] [] arr)&#123; if(arr.length==0||arr==null)&#123; return 1; &#125; int row=arr.length; int col=arr[0].length; int[][] dp=new int [row--][col--]; dp[row][col]=arr[row][col]&gt;0?1:1-arr[row][col]; for(int j=col-1;j&gt;=0;j--)&#123; dp[row][j]=Math.max(dp[row][j+1]-arr[row][j],1); //计算初步差异值 &#125; int right=0; int down=0; for(int i=row-1;i&gt;=0;i--)&#123; dp[i][col]=Math.max(dp[i+1][col]-arr[i][col],1); //计算初步上下差异值 for(int j=col-1;j&gt;=0;j--)&#123; right=Math.max(dp[i][j+1]-arr[i][j],1); //向右走 down=Math.max(dp[i+1][j]-arr[i][j],1); //向下走 dp[i][j]=Math.min(right,down); //取最小的差异值 &#125; &#125; return dp[0][0]; &#125; &#125; 最长公共子串问题所谓最长公共子串，比如 串 str1=”1AB2345CD” 串 str2=”12345EF”; 则它们的最长公共子串为串 “2345”,输出4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main &#123; public static void main(String[] args) &#123; String str1="1AB2345CD"; String str2="12345EF"; System.out.println(getdp(str1,str2)); &#125; public static int getdp(String str1,String str2)&#123; int dp[][]=new int [str1.length()][str2.length()]; for(int i=0;i&lt;str1.length();i++)&#123; if(str1.charAt(i)==str2.charAt(0))&#123; dp[i][0]=1; &#125; &#125; for(int j=1;j&lt;str2.length();j++)&#123; if(str1.charAt(0)==str2.charAt(j))&#123; dp[0][j]=1; &#125; &#125; int max=0; for(int i=1;i&lt;str1.length();i++)&#123; for(int j=1;j&lt;str2.length();j++)&#123; if(str1.charAt(i)==str2.charAt(j))&#123; dp[i][j]=dp[i-1][j-1]+1; &#125; System.out.print(dp[i][j]+" "); max=Math.max(max,dp[i][j]); &#125; System.out.println(""); &#125; return max; &#125; &#125;---0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 3 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 跳跃游戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package RecursiveAndDynamic;/** * Created by zdmein on 2017/9/14. * 跳跃游戏 给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 给出数组A = [2,3,1,1,4]，最少到达数组最后一个位置的跳跃次数是2 (从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次) 思路：贪心算法; * 从第一个数开始, 寻找可以一个可以跳最远的点; * 例1：3 1 2 4 1 0 0 * 1.从第一个位置0,可以跳到位置1和位置2和位置3; * 2.如果跳到位置1,那么最远就可以跳到位置(1+1); * 3.如果跳到位置2,那么最远就可以跳到位置(2+2); * 4.如果跳到位置3,那么最远就可以跳到位置(3+4); * 5.故选择跳到位置3 ,重复1.2.3步; * * 算法分析： * 1.如果选择跳到位置3 ,就无法跳到位置2和位置3, 那么会不会因此错过最优解？ 答：不会！ * 2.因为任意位置1和位置2能到达的位置, 位置3都可以到达; * 3.故不会错过最优解; */public class jump1 &#123; public static void main(String [] args)&#123; int [] arr=&#123;3,2,3,1,1,4&#125;; System.out.println(jump(arr)); &#125; public static int jump(int [] arr)&#123; if(arr==null||arr.length==0)&#123; return 0; &#125; int jump=0; int cur=0; int next=0; for (int i=0;i&lt;arr.length;i++)&#123; if(cur&lt;i)&#123; jump++; cur=next; &#125; next=Math.max(next,i+arr[i]); &#125; return jump; &#125;&#125; ​]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《操作系统概念》]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。 第二部分 进程管理第四章 进程进程状态 创建、运行、等待、就绪、终止 进程：一个具有单个控制线程的执行程序。 第五章 线程线程：是CPU使用的基本单元 多线程编程优点： 响应度高 资源共享 经济 多处理器体系结构的利用 多线程模型 多对一 Many-to-one 优点： 线程之间切换快 可以用用户自己的方式管理线程库 缺点： 如果一个线程执行了阻塞系统调用，那么整个系统就会阻塞。 一对一 One - to - one 优点：更好的并发能力 缺点：创建一个用户线程就需要创建一个相应的内核线程 多对多 Many-to - many 优点：没有many-to-One和 one-to -one的缺点 线程池 在进程开始时创建一定数量的线程，并放入到池中坐以等待工作。 如果池中没有可用的线程，那么服务器会一直等待直到有空线程为止。 优点： 用现有线程处理请求要比等待创建新的线程要快 线程池限制了在任何时候可存在线程的数量 第七章 进程同步多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为竞争条件。 两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。当出现这样的状态时，这些进程称为死锁（deadlocked）。 第八章 死锁 必要条件 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。 占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。 非抢占：资源不能被抢占；即，只有进程完成其任务之后，才会释放其资源。 循环等待：一组进程，循环等待下一个的资源。 所有四个条件必须同时满足才会出现死锁。 为了预防死锁，要确保这四个必要条件中的一个不成立。 死锁恢复 进程终止 终止所有死锁进程 一次只终止一个进程直到取消死锁循环为止 资源抢占 选择一个牺牲品 回滚 饥饿 从理论上来说，有三种方法可以处理死锁： 使用一些协议来预防或避免死锁，确保系统永远都不会进到死锁状态。 允许系统进入死锁状态，检测死锁，并恢复。 忽视所有问题，并假设系统中永远都不会出现死锁。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《程序员代码面试指南（栈和队列）》]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%EF%BC%88%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[第一章、栈和队列 有getMin功能的栈使用两个栈，一个用来保存当前栈中的元素，记为stackData，一个用来保存每一步的最小值，即为stackMin. 123456789101112131415161718192021222324252627282930313233public class MyStack &#123; public static void main (String [] args)&#123; int [] Arr = &#123;1,2,3&#125;; push(Arr[0]); push(Arr[1]); System.out.println(pop()+" " + getMin()); &#125; private static Stack&lt;Integer &gt; stackData=new Stack&lt;Integer&gt;(); private static Stack &lt;Integer&gt; stackMin =new Stack&lt;Integer&gt;(); public static void push(int newNum)&#123; stackData.push(newNum); if(stackMin.isEmpty())&#123; stackMin.push(newNum); &#125;else if(newNum&lt;stackMin.peek())&#123; stackMin.push(newNum); &#125; &#125; public static int pop()&#123; if(stackData.peek()==stackMin.peek())&#123; stackMin.pop(); &#125; return stackData.pop(); &#125; public static int getMin()&#123; if(stackMin.isEmpty())&#123; throw new RuntimeException("you stack is empty."); &#125; return stackMin.peek(); &#125;&#125; 由两个栈组成的队列 一个栈stackPush专门用来存数据 一个栈stackPop专门用来取数据 每次取数据前stackPop必须清空 每次stackPush压入数据到stackPop中时，必须一次性全部压入 123456789101112131415161718192021222324252627282930public class MyStack &#123; private static Stack&lt;Integer &gt; stackPush =new Stack&lt;Integer&gt;(); private static Stack &lt;Integer&gt; stackPop =new Stack&lt;Integer&gt;(); public static void add(int pushInt)&#123; stackPush.push(pushInt); &#125; public static int poll()&#123; if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty())&#123; throw new RuntimeException("Queue is Empty ！"); &#125;else if(stackPop.isEmpty())&#123; while (!stackPush.isEmpty())&#123; stackPop.push(stackPush.pop()); &#125; &#125; return stackPop.pop(); &#125; public static int peek()&#123; if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty())&#123; throw new RuntimeException("Queue is Empty ！"); &#125;else if(stackPop.isEmpty())&#123; while (!stackPush.isEmpty())&#123; stackPop.push(stackPush.pop()); &#125; &#125; return stackPop.peek(); &#125;&#125; 用栈解决汉诺塔问题修改后的汉诺塔问题不能从左直接到右，也不能从右直接到左，必须通过中间； 左、中、右三个地点依次记为LS，LM，RS； 则仅有四个动作：LS–&gt;LM 、LM–&gt;LS 、LM–&gt;RS 、RS–&gt;LM 动作：某一个栈（from）把栈顶元素弹出 ，然后压入到另一个栈里（to），作为这一个栈（to）的栈顶。 两个原则： 一个动作能发生的先决条件是不违反小压大的原则。 还一个是相邻不可逆原则。 意思是，L-&gt;M ，那么M-&gt;L，就重复了，如果要最小步法完成，必须不走重复步。 核心 游戏的第一个动作一定是L-&gt;M 在走出任何最小步数过程中，四个动作，只有一个动作不违反原则，其余三个一定会违反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyStack &#123; public enum Action &#123; No , LToM , MToL , MToR , RToM &#125; public static int hannoProblem(int num , String left , String mid ,String right)&#123; Stack&lt;Integer &gt; ls =new Stack&lt;Integer&gt;(); Stack &lt;Integer&gt; ms =new Stack&lt;Integer&gt;(); Stack &lt;Integer&gt; rs =new Stack&lt;Integer&gt;(); ls.push(Integer.MAX_VALUE); ms.push(Integer.MAX_VALUE); rs.push(Integer.MAX_VALUE); for( int i=num ;i&gt;0;i--)&#123; ls.push(i); &#125; Action [] record = &#123;Action.No&#125;; int step = 0; while (rs.size()!=num+1)&#123; step+= fStackTotStack(record,Action.MToL,Action.LToM,ls,ms , left , mid); step+= fStackTotStack(record,Action.LToM,Action.MToL,ms,ls , mid , left); step+= fStackTotStack(record,Action.RToM,Action.MToR,ms,rs , mid , right); step+= fStackTotStack(record,Action.MToR,Action.RToM,rs,ms , right, mid); &#125; return step; &#125; public static int fStackTotStack(Action [] record , Action preNoAct , Action nowAct , Stack&lt;Integer&gt; fStack , Stack&lt;Integer&gt; tStack, String from , String to)&#123; if(record[0] != preNoAct &amp;&amp; fStack.peek()&lt;tStack.peek())&#123; tStack.push(fStack.pop()); System.out.println("Move"+" "+tStack.peek()+" "+"from" +" "+ from +" "+ "to" +" "+ to); record[0]=nowAct; return 1; &#125; return 0; &#125; public static void main (String [] args)&#123; int num=2; String left="left"; String mid ="mid"; String right= "right"; System.out.println(hannoProblem(num,left,mid,right)); &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《深入理解Java虚拟机》]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[第13章 线程安全与锁优化分类1. 不可变不可变的对象一定是线程安全的 不可变带来的安全性是最简单和最纯粹的 基本数据类型：final 对象：java.lang.String 2. 绝对线程安全在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。 Java.util.Vector是一个线程安全的容器，因为它的add()、get()、size()这类方法都是被synchronized修饰的。 在多线程中，还需在调用端做额外的同步措施。 3. 相对线程安全通常意义上讲的线程安全 在Java中，大部分的线程安全类都属于这种类型，如Vector、HashTable、Collection、的synchronizedCollection()方法包装的集合等。 4. 线程兼容指对象本身并不是线程安全的，但是可以在同步端正确使用同步手段保证对象在并发环境中可以安全地使用。 Java API 中大部分的类都是属于线程兼容的，如Vector 和 HashTable相对应的集合类ArrayList 和 HashMap 等。 5. 线程对立指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 一个线程对立的例子是Thread类的 suspend() 和 resume() 方法。 线程安全实现方法互斥同步Mutual Exclusion &amp; Synchronization 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信息量的时候）线程使用。 互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信息量（Semaphore）都是主要的互斥实现方式。 互斥是因，同步是果。互斥是方法，同步是目的。 互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。 Synchronized在Java中，最基本的互斥同步手段就是synchronized关键字 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成） ReentrantLock重人锁 原生语法层面的互斥锁。 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。只需要多次调用newCondition()方法即可。 非阻塞同步乐观的并发策略 先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。 测试并设置 获取并增加 交换 比较并交换 加载链接/条件存储 1Java代码实现]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>开发者手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记之《Java编程思想》]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[17. 容器Set存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。 Set接口不保证维护元素的次序 Map映射表（关联数组）的基本思想是维护的是键-值（对）关联，因此可以用键来查找值。 基本方法 12Map.put()Map.get() 21. 并发 阻塞： 如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程阻塞了。 Java的线程机制是抢占式的。 一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务。 LiftOff任务将显示发射之前的倒计时： 1234567891011121314151617181920212223242526272829public class LiftOff implements Runnable&#123; protected int countDown = 10; private static int taskCount =0; private final int id=taskCount++; public LiftOff()&#123; this.countDown=countDown; &#125;public String status()&#123; return "#"+id +"("+(countDown&gt;0 ? countDown:"LiftOff ！")+").";&#125;public void run()&#123; while(countDown--&gt;0)&#123; System.out.println(status()); Thread.yield(); &#125; &#125;&#125;/*************************************************************/public class ThreadPro &#123; public static void main(String [] args)&#123; for(int i=0;i&lt;5;i++) new Thread(new LiftOff()).start(); System.out.println("Waiting for LiftOff !"); &#125;&#125; 执行器（Executor） Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。 优先级 线程的优先级将该线程的重要性传递给了调度器。 尽管CPU处理现有线程集的顺序使不确定的，但是调度器将倾向于让优先权最高的线程先执行。 另外会让优先级较低的线程执行的频率较低，故而优先权不会导致死锁。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-1]]></title>
    <url>%2F2017%2F08%2F07%2FJava%E5%9F%BA%E7%A1%80-1%2F</url>
    <content type="text"><![CDATA[Java基本功 Java是否存在内存泄露内存泄露是指一个不再被程序使用的对象或变量还在内存中占有存储空间。 如果开发人员忘记释放已分配的内存就会造成内存泄露。 在Java中，判断一个内存空间是否符合垃圾回收机制标准有两个： 给对象赋予了null，以后再没使用过 给对象赋予了新值，重新分配了内存空间 内存泄露主要有两种情况： 在堆中申请的空间没有被释放 对象已经不再使用，但还是在内存中保留着 Java中的垃圾回收机制可以解决情况1，所以内存泄露主要是情况2 在Java中，引起内存泄露的主要原因有： 静态集合类 各种连接，如数据库连接、网络联结以及IO连接等 监听器 变量不合理的作用域 单例模式可能会造成内存泄露 Java中的堆和栈有什么区别堆和栈都是内存中存放数据的地方 堆主要用来存放对象，栈用来执行程序 栈的存取速度比堆快 堆可以在运行中动态的分配内存 当main()方法退出后，栈中的变量会被回收 Java Collections 框架是什么Java Collections框架中包含了大量集合接口、这些接口的实现类、操作他们的算法。 Set表示数学意义上的集合概念。特点是集合中的元素不能重复 HashSet TreeSet ：容器中的元素是有序的 List又称为有序的Collection。 按对象进入的顺序保存对象，多以它能对列表中的每个元素的插入和删除位置进行精准的控制。 同时，它可以保存重复的对象。 Map提供了一个从键映射到值的数据结构。它用于保存键值对，其中值可以重复，键是唯一的。 HashMap 是基于散列表实现的，采用对象 HashCode 可以进行快速查询。 LinkedHashMap 采用列表来维护内部的顺序。 TreeMap 基于红黑树的数据结构来实现的，内部元素是按需排列的。 cookie和session区别 cookie保存在客户端，数据存放在客户的浏览器上；session机制采取保存在服务器端的方案，数据存放在服务器上。 cookie安全性不够，session信息存放在服务器，因此较为安全。 cookie性能更高 单个cookie保存的数据大小不能超过4 KB，而session不存在这个问题。 Hibernate优点 提高开发效率 可以完全采用面向对象的思想，不需要关心数据库的关系模型 有很好的移植性 支持透明持久化 使用Hibernate提高性能 延迟加载 缓存技术 优化查询语句 分页机制当数据量很大时，如果一次性的把数据取出来，不仅浪费时间，还消耗大量的内存 采用分页机制使得查询的结果集中数据量减少了，同时也降低了内存的消耗，因此可以显著降低响应时间，有助于提高系统的可用性，增强用户体验。 方法： 框架自带分页机制 SQL语句实现分页 GC自动检测对象的作用域，自动的把不再被使用的存储空间释放掉。 作用 分配内存 确保被引用的对象不被错误的回收 回收不再被引用的对象的内存空间 垃圾回收算法 引用计数法：缺点是无法处理循环引用问题 标记-清除法：标记所有从根节点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。适用于新生代（存活对象少，垃圾对象多） 标记-压缩算法：清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清除边界所有空间。适用于老年代。 分代 死锁当线程需要持有多个锁时，就有可能产生死锁。 线程A当前持有互斥锁lock1，线程B当前持有互斥锁lock2。 A想要lock2，B也想要lock1，互相试图获取对方的，又不肯先释放自己的，就陷入了无尽的等待/阻塞。 这种情况成为死锁。 ArrayList、Vector、LinkedList区别 容器 动态 扩充大小 同步？ 安全？ 效率 ArrayList 可伸缩数组 1.5倍 非同步 不是线程安全 索引or在末端增删元素效率高 Vector 可伸缩数组 2倍 绝大多数方法同步 线程安全 索引or在末端增删元素效率高、多线程 LinkedList 可伸缩数组 非线程安全 双向列表实现，插入数据高，指定位置插入or删除元素效率高 排序算法对比 排序算法 最好时间 平均时间 最坏时间 辅助存储 稳定性 备注 简单选择排序 $O（n^2）$ $O（n^2）$ $O（n^2）$ $O（1）$ 不稳定 n小时较好 直接插入排序 $O（n）$ $O（n^2）$ $O（n^2）$ $O（1）$ 稳定 大部分已有序时较好 冒泡排序 $O（n）$ $O（n^2）$ $O（n^2）$ $O（1）$ 稳定 n小时较好 希尔排序 $O（n）$ $O（nlogn）$ $O（n^s）(1&lt;s&lt;2)$ $O（1）$ 不稳定 s是所选分组 快速排序 $O（nlogn）$ $O（nlogn）$ $O（n^2）$ $O（logn）$ 不稳定 n大时较好 堆排序 $O（nlogn）$ $O（nlogn）$ $O（nlogn）$ $O（1）$ 不稳定 n大时较好 归并排序 $O（nlogn）$ $O（nlogn）$ $O（nlogn）$ $O（n）$ 稳定 n大时较好 什么是值传递和引用传递 值传递：方法调用时，实参会把它的值传递给形参，形参用实参的值初始化一个临时的存储单元，因此值一样，存储单元不一样，形参的改变不会影响实参。 引用传递：在方法调用时，传递的是对象，形参与实参指向同一块存储单元，对形参的改变就会改变实参。 面向对象的三个基本元素 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 多态： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 是否可以主动通知JVM进行垃圾回收？由于垃圾回收器的存在，Java语言没有提供给开发人员释放已分配内存的方法，开发人员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 但是开发可以调用System.gc()方法来“通知”垃圾回收器运行，当然，JVM也不会马上运行。 Java中堆和栈的区别 栈内存主要用来存放基本数据类型和引用变量；堆内存用来存放运行时创建的对象 堆主要用来存放对象，栈主要用来执行程序 线程状态有哪些，它们之间是如何转换的 New（新建）：刚创建，还没调用start方法 Runnable（可运行）：可以在Java虚拟机中运行的状态 Blocked（被阻塞）：当一个线程获取其他线程的内部对象锁而不得 Waiting（等待）：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态 Timed waiting（计时等待）：有超时参数的方法会让线程进入计时等待，如果超时或者出现通知，会切换到可运行状态 Terminated（被终止）：因为run方法正常退出或因为没有捕获的异常终止了run方法而死亡 线程与进程的区别，各有什么优缺点线程：是指程序在执行过程中，能够执行程序代码的一个执行单元。4个状态：运行，就绪，挂起，结束。 进程：是指一段正在执行的程序。 创建一个线程比创建一个进程所要的资源少。 当你在浏览器输入一个网址，如http://www.taobao.com，按回车之后发生了什么？请从技术的角度描述，如浏览器、网络（UDP、TCP、HTTP等），以及服务器等各种参与对象上由此引发的一系列活动，请尽可能的涉及到所有的关键技术点。 12345678910111213141516171819202122232425262728293031323334351.DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 2.与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 3.以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 4.获得服务器的响应，显示页面-----------------------------------------------------------1 查缓存2 DNS解析3 获取ip4 建立tcp连接5 发http数据6 接受http数据并解析7 close-------------------------------------------------------------------1、根据域名查询域名的IP。浏览器缓存-&gt;操作系统缓存-&gt;本地域名服务器缓存-&gt;域名服务器。2、得到IP后发起基于TCP的HTTP请求。如果浏览器存储了该域名下的cookie，那么会把cookie放入HTTP请求头里。3、TCP被包装为IP包，通过网络（可能经过很多路由器、交换机）发送到IP地址对应的服务器。这个服务器可能只是一个反向代理服务器，如果是，则HTTP请求被转交给内网中真实的某一个服务器（可能有多个服务器）。4、服务器分析HTTP请求，生成HTTP响应（可能是HTML、图片等）后，将响应发送给客户端浏览器。5、浏览器得到响应后，根据响应内容显示结果。如果响应的是图片，则将图片”画“在浏览器页面上；如果是HTML，则渲染HTML并”画“在浏览器页面上，在分析HTML时，若发现引用了其他资源，例如css、图片等，则发起HTTP请求，得到响应资源。 linux中cat、more、less命令区别均可用来查看文件内容 命令 区别 功能对比 cat 一次性显示整个文件的内容，还可以将多个文件连接起来显示，常与重定向符号配合使用，适用于文件内容少的情况 一般 more 一般用于显示文件内容超过一屏的内容，提供翻页的功能。提供分页显示。 强 less 一般用于显示文件内容超过一屏的内容，提供翻页的功能。翻页、跳转、查找。 更强 索引的作用及代价？如何建好索引？索引的原理 Hash算法 算法：二分查找算法，冒泡排序、选择排序算法、插入排序、归并、希尔、快排算法 锁：乐观锁和悲观锁 什么情况下会产生死锁？如何避免死锁？ JVM GC：介绍垃圾回收机制，垃圾回收算法。 JAVA的反射机制 Java集合类有哪些，分别在哪些场景使用 Linux下如何快速查找某个文件 Linux下如何设置环境变量 Linux下如何查看TCP连接状态123456789101112131415161718192021LISTEN： 侦听来自远方的TCP端口的连接请求 listen SYN-SENT： 再发送连接请求后等待匹配的连接请求 syn-sentSYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认 syn-receivedESTABLISHED： 代表一个打开的连接FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2： 从远程TCP等待连接中断请求CLOSE-WAIT： 等待从本地用户发来的连接中断请求CLOSING： 等待远程TCP对连接中断的确认LAST-ACK： 等待原来的发向远程TCP的连接中断请求的确认TIME-WAIT： 等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED： 没有任何连接状态 简述一次HTTP请求的基本流程 什么是JDBC，为什么需要什么是JDBC？实现原理是什么？ Get和Post的区别 Cookie和Session的区别，分别用于什么场景 为什么需要编码？UTF-8和GBK是如何进行编码的 分别介绍下JDK，JRE和JVM HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别 索引有什么用？如何建索引？ ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。 equals方法实现 面向对象 线程状态，BLOCKED和WAITING有什么区别 JVM如何加载字节码文件 JVM GC，GC算法。 什么情况会出现Full GC，什么情况会出现yong GC。 JVM内存模型Java内存模型，指Java程序在运行时内存的模型，而Java代码运行在Java虚拟机上，所以也就指Java虚拟机的运行时内存模型。 Java运行时数据区 事务的实现原理 技术深度 有没有看过JDK源码，看过的类实现原理是什么。 HTTP协议 TCP协议 一致性Hash算法 JVM如何加载字节码文件 类加载器如何卸载字节码 IO和NIO的区别，NIO优点 Java线程池的实现原理，keepAliveTime等参数的作用。 HTTP连接池实现原理 数据库连接池实现原理 数据库的实现原理 技术框架 看过哪些开源框架的源码 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？ Netty是如何使用线程池的，为什么这么使用 为什么要使用Spring，Spring的优缺点有哪些 Spring的IOC容器初始化流程 Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean Spring AOP实现原理 消息中间件是如何实现的，技术难点有哪些 系统架构 如何搭建一个高可用系统 哪些设计模式可以增加系统的可扩展性 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。 抽象能力，怎么提高研发效率。 什么是高内聚低耦合，请举例子如何实现 什么情况用接口，什么情况用消息 如果AB两个系统互相依赖，如何解除依赖 如何写一篇设计文档，目录是什么 什么场景应该拆分系统，什么场景应该合并系统 系统和模块的区别，分别在什么场景下使用 分布式系统 分布式事务，两阶段提交。 如何实现分布式锁 如何实现分布式Session 如何保证消息的一致性 负载均衡 正向代理（客户端代理）和反向代理（服务器端代理） CDN实现原理 怎么提升系统的QPS和吞吐量 实战能力 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。 开发中有没有遇到什么技术问题？如何解决的 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。 新浪微博是如何实现把微博推给订阅者 Google是如何在一秒内把搜索结果返回给用户的。 12306网站的订票系统如何实现，如何保证不会票不被超卖。 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。 软能力 如何学习一项新技术，比如如何学习Java的，重点学习什么 有关注哪些新的技术 工作任务非常多非常杂时如何处理 项目出现延迟如何处理 和同事的设计思路不一样怎么处理 如何保证开发质量 职业规划是什么？短期，长期目标是什么 团队的规划是什么 能介绍下从工作到现在自己的成长在那里 基础概念 多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为同步。 并发：在 操作系统 中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 处理机 上运行。其中两种并发关系分别是同步和互斥 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。 其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 constructor在一个对象被new时执行 @java中关于继承的描述：一个子类只能继承一个父类; 继承具有传递性;父类一般具有通用性，子类更具体。 当一个对象不再被引用后就成为垃圾可以被回收，但是线程就算没有被引用也可以独立运行的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Boot-之-排序算法]]></title>
    <url>%2F2017%2F08%2F06%2FSpring-Boot-%E4%B9%8B-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一些网站内容排序算法 前言-网页排序核心思想 交互越好，排名越好 时间越新，排名越好 Hacker Newshttps://news.ycombinator.com/ $$Score=(P-1)/(T+2)^G$$P：投票数，-1是把自己投的过滤掉T：发布到现在的时间间隔，单位小时，+2防止除数太小G：重力加速度，分值根据时间降低速率 Reddithttps://www.reddit.com/ t = (time of entry post) - (Dec 8, 2005)x = upvotes - downvotes y = {1 if x &gt; 0, ​ 0 if x = 0, ​ -1 if x &lt; 0)z = {1 if x &lt; 0, otherwise x} $$f(t,y,z)=log(z) + (y * t)/45000$$时间是最重要的权重，由于流量比较大，所以对于高赞文章有所优势，适合新闻类排序 StackOverflowhttp://stackoverflow.com 123(log(Qviews)*4) + ((Qanswers * Qscore)/5) + sum(Ascores)--------------------------------------------------------((QageInHours+1) - ((QageInHours - Qupdated)/2)) ^ 1.5 Qviews：问题浏览数，通过log来平滑Qanswer：问题回答数，有回答的题目才是好问题Qscore：问题赞踩差，赞的越多，问题越好sum（Ascores）：回答赞踩差，回答的越多问题越好QageInHours：题目发布时间差，时间越久排名越后Qupdated：最新的回答时间，越新关注度越高 IMDBhttp://www.imdb.com/chart/top 加权排名(WR) = (v ÷(v+m)) ×R + (m ÷(v+m)) ×C R = 某电影投票平均分 v = 有效投票人数 m = 最低投票人数，1250 C = 所有电影平均值 投票人数越多，越偏向于用户打分值，防止冷门电影小数人高分导致的高分 http://www.imdb.com/help/show_leaf?votestopfaq Marathon Match Rating System适合用于比赛中，互相排名。 https://community.topcoder.com/longcontest/?module=Static&amp;d1=support&amp;d2=ratings]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 Redis详解]]></title>
    <url>%2F2017%2F08%2F01%2FSpring-Boot-%E4%B9%8B-Redis%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Redis是目前业界使用最广泛的内存数据存储。 Redis支持丰富的数据结构，同时支持数据持久化。 Redis还提供一些类数据库的特性，比如事务，HA，主从库。 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis特点Redis支持数据的持久化，可以将内存中的数据保存到磁盘中，重启的时候可以再次加载使用 Redis不仅仅支持简单的key-value类型的数据，同时还支持list，set，zset，hash等数据结构的存储 Redis支持数据的备份 支持主从同步，数据存在内存中，性能卓越。 Redis数据结构String（字符串）String是redis最基本的类型，一个key对应一个value 1234127.0.0.1:6379&gt; set name "runoob"OK127.0.0.1:6379&gt; get name"runoob" set 和 get 命令，key为name，value为runoob。 List（列表）双向列表，适用于最新列表，关注列表 列表是最简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部 12345678910127.0.0.1:6379&gt; lpush runoob redis(integer) 1127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2127.0.0.1:6379&gt; lpush runoob damin(integer) 3127.0.0.1:6379&gt; lrange runoob 0 101) "damin"2) "mongodb"3) "redis" lpush存入链表，lrange列出链表 Set（集合）适用于无顺序的集合，点赞点踩，抽奖，已读，共同好友 Redis的Set是String类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找，都是$O(1)$ $asdd$命令：添加一个string元素命令到key对应的set集合中，成功返回1，如果元素已经存在，返回0，key对应的set不存在返回错误。 123456789101112127.0.0.1:6379&gt; SADD damin redis(integer) 1127.0.0.1:6379&gt; SADD damin mysql(integer) 1127.0.0.1:6379&gt; SADD damin mongodb(integer) 1127.0.0.1:6379&gt; SADD damin mysql(integer) 0127.0.0.1:6379&gt; SMEMBERS damin1) "mongodb"2) "mysql"3) "redis" SortedSet（有序集合）排行榜，优先队列 和set一样，zadd也是不允许重复的成员 Hash（哈希）对象属性，不定长属性数 是一个键名对集合 hash特别适合用于存储对象 123456789127.0.0.1:6379&gt; HMSET user:1 username runoob password runoob points 200OK127.0.0.1:6379&gt; HGETALL user:11) "username"2) "runoob"3) "password"4) "runoob"5) "points"6) "200" Redis HMSET , HGETALL 命令，user:1为键值 KV：单一数值，验证码，PV，缓存 启动Redis121、用cmd命令转到redis根目录下2、执行cmd命令：redis-server redis.windows.conf Redis基础基本指令功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Created by nowcoder on 2016/7/30. */@Servicepublic class JedisAdapter implements InitializingBean &#123; private static final Logger logger = LoggerFactory.getLogger(JedisAdapter.class); private JedisPool pool; public static void print(int index, Object obj) &#123; System.out.println(String.format("%d, %s", index, obj.toString())); &#125; public static void main(String[] argv) &#123; Jedis jedis = new Jedis("redis://localhost:6379/9"); jedis.flushDB(); // get set jedis.set("hello", "world"); print(1, jedis.get("hello")); //输出hello对应的world jedis.rename("hello", "newhello"); //newhello替代hello print(1, jedis.get("newhello")); //指向输出world jedis.setex("hello2", 1800, "world"); print(1,jedis.get("hello2")); jedis.set("pv","100"); //点踩功能 jedis.incr("pv"); //加1 jedis.incrBy("pv",5); //加5 print(2,jedis.get("pv")); jedis.decrBy("pv",2); //减2 print(2,jedis.get("pv")); print(3,jedis.keys("*")); //输出所有表 String listName ="list"; jedis.del(listName); for(int i=0;i&lt;10;i++)&#123; jedis.lpush(listName,"a"+String.valueOf(i)); //添加进表 &#125; print(4,jedis.lrange(listName,0,12)); //输出范围0-12的内容 print(4,jedis.lrange(listName,0,2)); //输出范围0-2的内容 print(5,jedis.llen(listName)); //输出长度 print(6,jedis.lpop(listName)); //弹出最前一个的内容 print(10,jedis.linsert(listName,BinaryClient.LIST_POSITION.AFTER,"a4","dd")); print(11,jedis.lrange(listName,0,11)); String userKey = "userxx"; jedis.hset(userKey,"name","jim"); jedis.hset(userKey,"age","12"); jedis.hset(userKey,"phone","1562225555"); print(12,jedis.hget(userKey,"name")); //取出对应信息 print(13,jedis.hgetAll(userKey)); //全部取出 jedis.hdel(userKey,"phone"); print(14,jedis.hgetAll(userKey)); //取出全部信息 print(15,jedis.hexists(userKey,"email")); //有没有email print(16,jedis.hexists(userKey,"age")); //有没有age print(17,jedis.hkeys(userKey)); //输出key print(18,jedis.hvals(userKey));// 输出值 jedis.hsetnx(userKey,"school","zju"); //添加学校属性 jedis.hsetnx(userKey,"name","yxy"); //如果存在则不改写 print(19,jedis.hgetAll(userKey)); //set String likeKey1="commentLike1"; String likeKey2="commentLike2"; for(int i=0;i&lt;10 ; ++i)&#123; jedis.sadd(likeKey1,String.valueOf(i)); jedis.sadd(likeKey2,String.valueOf(i*i)); &#125; print(20,jedis.smembers(likeKey1)); print(21,jedis.smembers(likeKey2)); print(22,jedis.sunion(likeKey1,likeKey2));//求并 print(23,jedis.sdiff(likeKey1,likeKey2));//我有你无 print(24,jedis.sinter(likeKey1,likeKey2)); //求公共的 print(25,jedis.sismember(likeKey1,"12")); print(25,jedis.sismember(likeKey2,"16")); //查询对象在不在里面 jedis.srem(likeKey1,"5"); print(27,jedis.smembers(likeKey1)); User user = new User(); user.setName("xx"); user.setPassword("ppp"); user.setHeadUrl("a.png"); user.setSalt("salt"); user.setId(1); print(46,JSONObject.toJSONString(user)); jedis.set("user1",JSONObject.toJSONString(user)); String value = jedis.get("user1"); User user2=JSON.parseObject(value,User.class); print(47,user2); int k=2; &#125; @Override public void afterPropertiesSet() throws Exception &#123; &#125;&#125; Redis事务redis事务可以一次执行多个命令，并且有以下2个属性： 事务是一个单独的隔离操作，事务中所有命令都会序列化，按顺序地执行，事务在执行的过程中，不会被其他客户端发送过来的命令请求所中断 事务是一个原子操作，事务中的命令要不全部被执行，要不都不执行 一个事务从开始到执行有三个阶段 ： 开始事务 命令入队 执行事务 实例： 先以MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务，一并执行事务中的所有命令 12345678910111213141516127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set book-name "Java Thinking in"QUEUED127.0.0.1:6379&gt; GET book-nameQUEUED127.0.0.1:6379&gt; SADD tag "JAVA" "Coding"QUEUED127.0.0.1:6379&gt; SMEMBERS tagQUEUED127.0.0.1:6379&gt; EXEC1) OK2) "Java Thinking in"3) (integer) 24) 1) "JAVA" 2) "Coding" 事务相关命令： DISCARD：取消事务discard，放弃执行事务中所有命令 EXEC：执行所有事务块内的命令 exec MULTI：标记一个事务块的开始multi UNWATCH：取消watch命令对所有key的监视 Redis脚本Redis脚本用Lua解释器来执行脚本，脚本执行的命令为EVAL 12345127.0.0.1:6379&gt; EVAL "return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;" 2 key1 key2 first second1) "key1"2) "key2"3) "first"4) "second" Redis 连接Redis连接服务器 12345127.0.0.1:6379&gt; AUTH "password"(error) ERR Client sent AUTH, but no password is set //没有密码，所以...127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; 连接命令： AUTH password：验证密码是否正确 PONG：查看服务器是否运行 ECHO message ： 打印字符串 QUIT：关闭当前连接 SELECT index ：切换到指定的数据库 Java使用Redis添加jedis.jar 包 然后就可以嗨起来了 连接服务器1234567891011121314import redis.clients.jedis.Jedis;public class RedisJava &#123; public static void main(String [] args)&#123; //连接本地的Redis服务 Jedis jedis =new Jedis("localhost"); System.out.println("连接成功"); //查看服务器是否运行 System.out.println("服务正在运行："+jedis.ping()); &#125;&#125;--- 连接成功服务正在运行：PONG 字符串1234567891011121314import redis.clients.jedis.Jedis;public class RedisJava &#123; public static void main(String [] args)&#123; //连接本地的Redis服务 Jedis jedis =new Jedis("localhost"); System.out.println("连接成功"); jedis.set("damin","zhoudm.com"); System.out.println("redis 存储的字符串为："+jedis.get("damin")); &#125;&#125;---连接成功redis 存储的字符串为：zhoudm.com Redis Java List12345678910111213141516171819202122232425import redis.clients.jedis.Jedis;import java.util.List;public class RedisJava &#123; public static void main(String [] args)&#123; //连接本地的Redis服务 Jedis jedis =new Jedis("localhost"); System.out.println("连接成功"); jedis.lpush("zhoudm","zhoudm.com"); jedis.lpush("zhoudm","baidu.com"); jedis.lpush("zhoudm","360.com"); jedis.lpush("zhoudm","google.com"); List&lt;String&gt; list=jedis.lrange("zhoudm",0,3); for(int i=0;i&lt;list.size();i++) &#123; System.out.println("列表为：" + list.get(i)); &#125; &#125;&#125;---连接成功列表为：google.com列表为：360.com列表为：baidu.com列表为：zhoudm.com Redis Java Keys1234567891011121314151617181920212223242526272829303132333435363738394041import redis.clients.jedis.Jedis;import java.util.Set;import java.util.Iterator;public class RedisJava &#123; public static void main(String [] args)&#123; //连接本地的Redis服务 Jedis jedis =new Jedis("localhost"); System.out.println("连接成功"); Set&lt;String&gt; keys=jedis.keys("*"); Iterator&lt;String&gt; it=keys.iterator(); while(it.hasNext())&#123; String key = it.next(); System.out.println(key); &#125; &#125;&#125;--- 连接成功zhoudmspring:session:sessions:7ff2fe7e-9454-48a1-b44c-9b5f6b7b1507book-namespring:session:sessions:9a02f60c-fd16-49b5-9977-08446f4ffff5spring:session:sessions:f1312270-95cf-4d19-a88d-5af26b03a61cspring:session:sessions:expires:9a02f60c-fd16-49b5-9977-08446f4ffff5spring:session:expirations:1504881480000user:1spring:session:sessions:f31624a8-b014-4768-826d-8b5b484b63a7collectorspring:session:sessions:expires:f1312270-95cf-4d19-a88d-5af26b03a61cspring:session:sessions:expires:f31624a8-b014-4768-826d-8b5b484b63a7namespring:session:expirations:1504409460000daminrunoobtagspring:session:expirations:1505295120000spring:session:expirations:1504252440000spring:session:sessions:expires:7ff2fe7e-9454-48a1-b44c-9b5f6b7b1507]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 项目业务逻辑]]></title>
    <url>%2F2017%2F08%2F01%2FSpring-Boot-%E4%B9%8B-%E9%A1%B9%E7%9B%AE%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[业务逻辑 开发流程 Database Column Model：模型定义，和数据库相匹配 DAO：数据读取 Service：服务包装 Controller：业务入口 Test 评论CommentDAO 添加评论 addComment 根据一个实体选出全部评论 selectCommentByEntity 选一个实体下有多少评论 Service 添加评论 得到评论数 删除评论-controller调用Service，Service更新状态就可以了 Controller 增加评论 POSTquestionId 是多少content 是多少评论内容也需要过滤一次( Html &amp; 自己写的算法)hostHolder！=null 说明你是登陆的没登陆？：要不登陆、要不匿名]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 Web Notes]]></title>
    <url>%2F2017%2F07%2F31%2FSpring-Boot-%E4%B9%8B-Web-Notes%2F</url>
    <content type="text"><![CDATA[一些Web的笔记！ 开发流程 Database Column Model：模型定义，和数据库匹配 Dao：数据读取 Service：服务包装 Controller：业务入口 Test solr官方网站： http://lucene.apache.org/solr/ …\bin&gt; solr -e cloud -noprompt 搜索语法： +包含关键词 -不需要某关键词 云模式solr start -e cloud –noprompt 单机solr start solr create_collection wenda 关闭 solr stop -all 核心概念： Document：每个被索引的文档 Field：文档里的各个属性值 IKAnanlyzer分词配置（managed-schema） 123456789101112131415161718192021&lt;fieldTypename="text_ik" class="solr.TextField"&gt;&lt;!--索引时候的分词器--&gt;&lt;analyzer type="index"&gt;&lt;tokenizerclass="org.wltea.analyzer.util.IKTokenizerFactory" useSmart=“false"/&gt;&lt;filter class="solr.LowerCaseFilterFactory"/&gt;&lt;/analyzer&gt;&lt;!--查询时候的分词器--&gt;&lt;analyzer type="query"&gt;&lt;tokenizerclass="org.wltea.analyzer.util.IKTokenizerFactory" useSmart=“true"/&gt;&lt;/analyzer&gt;&lt;/fieldType&gt; 12&lt;field name="question_title" type="text_ik" indexed="true" stored="true" multiValued="true"/&gt;&lt;field name="question_content" type="text_ik" indexed="true" stored="true" multiValued="true"/&gt; 数据库数据导入 123456789101112131415161718192021222324252627282930313233343536373839solrconfig.xml&lt;requestHandlername="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"&gt;&lt;lstname="defaults"&gt;&lt;strname="config"&gt;data-config.xml&lt;/str&gt;&lt;/lst&gt;&lt;/requestHandler&gt;data-config.xml&lt;dataConfig&gt;&lt;dataSource type="JdbcDataSource"driver="com.mysql.jdbc.Driver"url="jdbc:mysql://localhost/wenda"user="root"password="nowcoder"/&gt;&lt;document&gt;&lt;entity name="question" query="select id,title,content from question"&gt;&lt;field column="content" name="question_content"/&gt;&lt;field column="title" name="question_title"/&gt;&lt;/entity&gt;&lt;/document&gt;&lt;/dataConfig&gt; 敏感词前缀树• 根节点不包含字符，除根节点外每一个节点都只包含一个字符• 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串• 每个节点的所有子节点包含的字符都不相同 过滤掉符号避免敏感词中间空格就识别不出了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169@Servicepublic class SensitiveService implements InitializingBean &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveService.class); /** * 默认敏感词替换符 */ private static final String DEFAULT_REPLACEMENT = &quot;***&quot;; private class TrieNode &#123; /** * true 关键词的终结 ； false 继续 */ private boolean end = false; /** * key下一个字符，value是对应的节点 */ private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); /** * 向指定位置添加节点树 */ void addSubNode(Character key, TrieNode node) &#123; subNodes.put(key, node); &#125; /** * 获取下个节点 */ TrieNode getSubNode(Character key) &#123; return subNodes.get(key); &#125; boolean isKeywordEnd() &#123; return end; &#125; void setKeywordEnd(boolean end) &#123; this.end = end; &#125; public int getSubNodeCount() &#123; return subNodes.size(); &#125; &#125; /** * 根节点 */ private TrieNode rootNode = new TrieNode(); /** * 判断是否是一个符号 */ private boolean isSymbol(char c) &#123; int ic = (int) c; // 0x2E80-0x9FFF 东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (ic &lt; 0x2E80 || ic &gt; 0x9FFF); &#125; /** * 过滤敏感词 */ public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return text; &#125; String replacement = DEFAULT_REPLACEMENT; StringBuilder result = new StringBuilder(); TrieNode tempNode = rootNode; int begin = 0; // 回滚数 int position = 0; // 当前比较的位置 while (position &lt; text.length()) &#123; char c = text.charAt(position); // 空格直接跳过 if (isSymbol(c)) &#123; if (tempNode == rootNode) &#123; result.append(c); ++begin; &#125; ++position; continue; &#125; tempNode = tempNode.getSubNode(c); // 当前位置的匹配结束 if (tempNode == null) &#123; // 以begin开始的字符串不存在敏感词 result.append(text.charAt(begin)); // 跳到下一个字符开始测试 position = begin + 1; begin = position; // 回到树初始节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词， 从begin到position的位置用replacement替换掉 result.append(replacement); position = position + 1; begin = position; tempNode = rootNode; &#125; else &#123; ++position; &#125; &#125; result.append(text.substring(begin)); return result.toString(); &#125; private void addWord(String lineTxt) &#123; TrieNode tempNode = rootNode; // 循环每个字节 for (int i = 0; i &lt; lineTxt.length(); ++i) &#123; Character c = lineTxt.charAt(i); // 过滤空格 if (isSymbol(c)) &#123; continue; &#125; TrieNode node = tempNode.getSubNode(c); if (node == null) &#123; // 没初始化 node = new TrieNode(); tempNode.addSubNode(c, node); &#125; tempNode = node; if (i == lineTxt.length() - 1) &#123; // 关键词结束， 设置结束标志 tempNode.setKeywordEnd(true); &#125; &#125; &#125; @Override public void afterPropertiesSet() throws Exception &#123; rootNode = new TrieNode();//读取文本 try &#123; InputStream is = Thread.currentThread().getContextClassLoader() .getResourceAsStream(&quot;SensitiveWords.txt&quot;); InputStreamReader read = new InputStreamReader(is); BufferedReader bufferedReader = new BufferedReader(read); String lineTxt; while ((lineTxt = bufferedReader.readLine()) != null) &#123; lineTxt = lineTxt.trim(); addWord(lineTxt); &#125; read.close(); &#125; catch (Exception e) &#123; logger.error(&quot;读取敏感词文件失败&quot; + e.getMessage()); &#125; &#125; public static void main(String[] argv) &#123; SensitiveService s = new SensitiveService(); s.addWord(&quot;色情&quot;); s.addWord(&quot;好色&quot;); System.out.print(s.filter(&quot;你好X色情XX&quot;)); &#125;&#125; Web敏感词过滤123456789public int addQuestion(Question question) &#123; //Html过滤question.setTitle(HtmlUtils.htmlEscape(question.getTitle()));question.setContent(HtmlUtils.htmlEscape(question.getContent()));// 敏感词过滤question.setTitle(sensitiveService.filter(question.getTitle()));question.setContent(sensitiveService.filter(question.getContent()));return questionDAO.addQuestion(question) &gt; 0 ? question.getId() : 0; &#125; 多线程优势•充分利用多处理器•可以异步处理任务 挑战•数据会被多个线程访问，有安全性问题•不活跃的线程也会占用内存资源•死锁 Thread1.extends Thread，重载run()方法2.implements Runnable()，实现run()方法12345678910new Thread(new Runnable() &#123;@Overridepublic void run() &#123; Random random = new Random(); for (int i = 0; i &lt; 10; ++i) &#123; sleep(random.nextInt(1000)); System.out.println(String.format(&quot;T%d : %d&quot;, tid, i)); &#125; &#125;&#125;, String.valueOf(i)).start(); Synchronized－内置锁1.放在方法上会锁住所有synchronized方法2.synchronized(obj) 锁住相关的代码段12345678public static void testSynchronized1() &#123;synchronized (obj) &#123;Random random = new Random();for (int i = 0; i &lt; 10; ++i) &#123;sleep(random.nextInt(1000));&#125;&#125;&#125; BlockingQueue 同步队列ThreadLocal1.线程局部变量。即使是一个static成员，每个线程访问的变量是不同的。2.常见于web中存储当前用户到一个静态工具类中，在线程的任何地方都可以访问到当前线程的用户。3.参考HostHolder.java里的users Executor1.提供一个运行任务的框架。2.将任务和如何运行任务解耦。3.常用于提供线程池或定时任务服务ExecutorService service = Executors.newFixedThreadPool(2);service.submit(new Runnable() {@Overridepublic void run() {for (int i = 0; i &lt; 10; ++i) {sleep(1000);System.out.println(“Execute %d” + i);}}}); Future线程间通信1.返回异步结果2.阻塞等待返回结果3.timeout4.获取线程中的Exception12345678910111213141516public static void testFuture() &#123;ExecutorService service = Executors.newSingleThreadExecutor();Future&lt;Integer&gt; future = service.submit(new Callable&lt;Integer&gt;() &#123;@Overridepublic Integer call() throws Exception &#123;sleep(1000);//throw new IllegalArgumentException(&quot;一个异常&quot;);return 1;&#125;&#125;);service.shutdown();try &#123;System.out.println(future.get());//System.out.println(future.get(100, TimeUnit.MILLISECONDS));&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 MyBatis集成]]></title>
    <url>%2F2017%2F07%2F29%2FSpring-Boot-%E4%B9%8B-MyBatis%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis是现在业界互联网流行的数据操作层框架 流程 用注解的方法 先定义一个Dao，和数据库做交互 注解上写@Mapper： Dao和数据库做一个Mapper 把@Insert通过一个注解的方式写进去 写SQL语句，语法有点不同，导进去 增删改查 Mysql创建数据库创建表user12345678910DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `password` varchar(128) NOT NULL COMMENT &apos;密码&apos;, `salt` varchar(32) not null default &apos;&apos;, `head_url` varchar(256) not null default &apos;&apos;, PRIMARY KEY (`id`), UNIQUE KEY `name_UNIQUE` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&apos;这是用户表&apos; 创建表question12345678910CREATE TABLE `question` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` text, `user_id` int(11) NOT NULL, `created_date` datetime NOT NULL, `comment_count` int(11) NOT NULL, PRIMARY KEY (`id`), KEY `date_index` (`created_date`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 添加pom.xml依赖1234567891011&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 添加application.properties配置1234spring.datasource.url=jdbc:mysql://localhost:3306/wenda?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=1621mybatis.config-location=classpath:mybatis-config.xml Dao层先定义一个@Mapper下面就可以写SQL语句了未来扩展：独立数据语句 1234567891011@Mapperpublic interface UserDao &#123; //以后数据库有变更，就只要改这里就可以了 String TABLE_NAME=&quot; user &quot;; String INSERT_FIELDS=&quot; name , password ,salt ,head_url &quot;; String SELECT_FIELDS=&quot; id,&quot;+ INSERT_FIELDS ; @Insert(&#123;&quot;insert into &quot;, TABLE_NAME, &quot;(&quot;, INSERT_FIELDS, &quot;) values (#&#123;name&#125;,#&#123;password&#125;,#&#123;salt&#125;,#&#123;headUrl&#125;)&quot;&#125;) int addUser(User user);&#125; User层添加与读取set与get123456789101112131415161718192021222324252627public class User &#123; private int id; private String name; private String password; private String salt; private String headUrl; public User()&#123; &#125; public User(String name)&#123; this.name =name; this.password=&quot;&quot;; this.salt=&quot;&quot;; this.headUrl=&quot;&quot;; &#125; public String getName()&#123;return name;&#125; public void setName(String name) &#123;this.name=name;&#125; public String getPassword() &#123;return password;&#125; public void setPassword(String password) &#123;this.password=password;&#125; public String getSalt() &#123;return salt ;&#125; public void setSalt(String salt ) &#123;this.salt=salt;&#125; public String getHeadUrl() &#123;return headUrl;&#125; public void setHeadUrl(String headUrl) &#123;this.headUrl=headUrl;&#125; public int getId() &#123;return id;&#125; public void setId(int id) &#123;this.id=id;&#125;&#125; 测试123456789101112131415161718192021222324@RunWith( SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = WendaApplication.class)@Sql(&quot;/init-schema.sql&quot;)public class InitDatabaseTests &#123; @Autowired UserDao userDao; @Test public void contextLoads() &#123; Random random=new Random(); for(int i=0;i&lt;11;++i)&#123; User user= new User(); user.setHeadUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;,random.nextInt(1000))); user.setName(String.format(&quot;USER%d&quot;,i)); user.setPassword(&quot;&quot;); user.setSalt(&quot;&quot;); userDao.addUser(user); &#125; &#125;&#125; 数据库写入结果123456789101112id name password salt head_url 1 USER0 http://images.nowcoder.com/head/165t.png2 USER1 http://images.nowcoder.com/head/269t.png3 USER2 http://images.nowcoder.com/head/961t.png4 USER3 http://images.nowcoder.com/head/395t.png5 USER4 http://images.nowcoder.com/head/13t.png6 USER5 http://images.nowcoder.com/head/84t.png7 USER6 http://images.nowcoder.com/head/179t.png8 USER7 http://images.nowcoder.com/head/593t.png9 USER8 http://images.nowcoder.com/head/77t.png10 USER9 http://images.nowcoder.com/head/600t.png11 USER10 http://images.nowcoder.com/head/497t.png 传入多个参数12345678910111213@Mapperpublic interface QuestionDao &#123; String TABLE_NAME = &quot; question &quot;; String INSERT_FIELDS = &quot; title, content, created_date, user_id, comment_count &quot;; String SELECT_FIELDS = &quot; id, &quot; + INSERT_FIELDS; @Insert(&#123;&quot;insert into &quot;, TABLE_NAME, &quot;(&quot;, INSERT_FIELDS, &quot;) values (#&#123;title&#125;,#&#123;content&#125;,#&#123;createdDate&#125;,#&#123;userId&#125;,#&#123;commentCount&#125;)&quot;&#125;) int addQuestion(Question question); List&lt;Question&gt; selectLatestQuestions(@Param(&quot;userId&quot;) int userId, @Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit);&#125; QuestionDao.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.nowcoder.dao.QuestionDao&quot;&gt; &lt;sql id=&quot;table&quot;&gt;question&lt;/sql&gt; &lt;sql id=&quot;selectFields&quot;&gt;id, title, content, comment_count,created_date,user_id &lt;/sql&gt; &lt;select id=&quot;selectLatestQuestions&quot; resultType=&quot;com.nowcoder.model.Question&quot;&gt; SELECT &lt;include refid=&quot;selectFields&quot;/&gt; FROM &lt;include refid=&quot;table&quot;/&gt; &lt;if test=&quot;userId != 0&quot;&gt; WHERE user_id = #&#123;userId&#125; &lt;/if&gt; ORDER BY id DESC LIMIT #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt;&lt;/mapper&gt; 测试123456789Question question=new Question(); question.setCommentCount(i); Date date=new Date(); date.setTime(date.getTime()+1000*3600*i); question.setCreatedDate(date); question.setUserId(i+1); question.setTitle(String.format(&quot;TITLE&#123;%d&#125;&quot;,i)); question.setContent(String.format(&quot;Balalalalalalalala Content %d&quot; , i) ); questionDao.addQuestion(question); 结果12345678910111 TITLE&#123;0&#125; Balalalalalalalala Content 0 1 2017-07-29 20:30:33 02 TITLE&#123;1&#125; Balalalalalalalala Content 1 2 2017-07-29 21:30:33 13 TITLE&#123;2&#125; Balalalalalalalala Content 2 3 2017-07-29 22:30:33 24 TITLE&#123;3&#125; Balalalalalalalala Content 3 4 2017-07-29 23:30:33 35 TITLE&#123;4&#125; Balalalalalalalala Content 4 5 2017-07-30 00:30:33 46 TITLE&#123;5&#125; Balalalalalalalala Content 5 6 2017-07-30 01:30:33 57 TITLE&#123;6&#125; Balalalalalalalala Content 6 7 2017-07-30 02:30:33 68 TITLE&#123;7&#125; Balalalalalalalala Content 7 8 2017-07-30 03:30:33 79 TITLE&#123;8&#125; Balalalalalalalala Content 8 9 2017-07-30 04:30:33 810 TITLE&#123;9&#125; Balalalalalalalala Content 9 10 2017-07-30 05:30:33 911 TITLE&#123;10&#125; Balalalalalalalala Content 10 11 2017-07-30 06:30:33 10]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 Ioc-Aop]]></title>
    <url>%2F2017%2F07%2F29%2FSpring-Boot-%E4%B9%8B-Ioc-Aop%2F</url>
    <content type="text"><![CDATA[非常重要的特性！ Ioc依赖注入：无需关注这些变量的初始化，只需要通过注解表示 Service层服务层123456@Servicepublic class WendaService &#123; public String getMessage(int userId)&#123; return &quot;Hello Message: &quot; +String.valueOf(userId); &#125;&#125; Controller层原本是：1WendaService wendaService=new WendaService(); 在用的地方依赖注入12@AutowiredWendaService wendaService; 完整code:1234567891011@Controllerpublic class IndexController &#123; @Autowired WendaService wendaService; @RequestMapping(path = &#123;&quot;/setting&quot; &#125;,method = &#123;RequestMethod.GET&#125;) @ResponseBody public String setting(HttpSession httpSession)&#123; return &quot;Setting OK. &quot; + wendaService.getMessage(1); &#125;&#125; http://127.0.0.1:8080/setting/1Setting OK. Hello Message: 1 Aop/Log面向切面，所有业务都要处理的业务好处：关注系统性能时，可以查看每个方法调用多少次，每个方法调用时间，额外注释，数据记录统计等都非常方便！ 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; aspect123456789101112131415@Component@Aspectpublic class LogAspect &#123; private static final Logger logger= LoggerFactory.getLogger(LogAspect.class); @Before(&quot;execution(* com.nowcoder.controller.IndexController.*(..))&quot;) public void beforeMethod()&#123; logger.info(&quot;before method&quot;); &#125; @After(&quot;execution(* com.nowcoder.controller.IndexController.*(..))&quot;) public void afterMethod()&#123; logger.info(&quot;after method&quot;); &#125;&#125; 调用IndexController.class前后会执行切面代码12345678910111213 . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.3.6.RELEASE)2017-07-29 09:00:17.625 INFO 5652 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2017-07-29 09:00:17.625 INFO 5652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started2017-07-29 09:00:17.635 INFO 5652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 10 ms2017-07-29 09:00:17.655 INFO 5652 --- [nio-8080-exec-1] com.nowcoder.aspect.LogAspect : before method2017-07-29 09:00:17.657 INFO 5652 --- [nio-8080-exec-1] com.nowcoder.aspect.LogAspect : after method]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 之 HelloWorld详解]]></title>
    <url>%2F2017%2F07%2F28%2FSpring-Boot-%E4%B9%8B-HelloWorld%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot介绍~&lt;暂时假装有&gt; 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.nowcoder&lt;/groupId&gt; &lt;artifactId&gt;wenda&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;wenda&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Controller层简单Hello输出12345678@Controllerpublic class IndexController &#123;@RequestMapping(path = &#123;&quot;/&quot;,&quot;/index&quot;&#125;)@ResponseBody public String index()&#123; return &quot;Hello&quot;; &#125;&#125; 访问：12http://127.0.0.1:8080/indexhttp://127.0.0.1:8080/ 输出：1Hello 参数解析输出路径传递1234567891011121314@Controllerpublic class IndexController &#123;@RequestMapping(path = &#123;&quot;/&quot;,&quot;/index&quot;&#125;)@ResponseBody public String index()&#123; return &quot;Hello&quot;; &#125; @RequestMapping(path = &#123;&quot;/profile/&#123;userId&#125;&quot;&#125;) @ResponseBody public String profile(@PathVariable(&quot;userId&quot;) int userId )&#123; return String.format(&quot;Profile Page of %d&quot;,userId); &#125;&#125; 访问http://127.0.0.1:8080/profile/2 ：1Profile Page of 2 参数解析输出例2123456@RequestMapping(path = &#123;&quot;/profile/&#123;groupId&#125;/&#123;userId&#125;&quot;&#125;)@ResponseBodypublic String profile(@PathVariable(&quot;userId&quot;) int userId , @PathVariable(&quot;groupId&quot;) String groupId )&#123; return String.format(&quot;Profile Page of %s / %d&quot;,groupId,userId); &#125; 访问http://127.0.0.1:8080/profile/admin/100861Profile Page of admin / 10086 eg3请求参数传递12345678@RequestMapping(path = &#123;&quot;/profile/&#123;groupId&#125;/&#123;userId&#125;&quot;&#125;)@ResponseBodypublic String profile(@PathVariable(&quot;userId&quot;) int userId , @PathVariable(&quot;groupId&quot;) String groupId , @RequestParam(&quot;type&quot;) int type , @RequestParam(&quot;key&quot;) String key )&#123; return String.format(&quot;Profile Page of %s / %d , t:%d k:%s&quot;,groupId,userId,type,key);&#125; 访问http://127.0.0.1:8080/profile/admin/10086?type=2&amp;key=w1Profile Page of admin / 10086 , t:2 k:w 模板Velocity使用controller12345@RequestMapping(path = &#123;&quot;/vm&quot;&#125;,method = &#123;RequestMethod.GET&#125;)public String template(Model model)&#123; model.addAttribute(&quot;value1&quot;,&quot;vvvv1&quot;); return &quot;home&quot;;&#125; 指向home.html 渲染123456789101112&lt;html&gt;&lt;body&gt;&lt;pre&gt; #* 你看不到我~~~~ *# $!&#123;value1&#125; $!&#123;value2&#125; ## 如果不存在，强制为空 $&#123;value3&#125;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-velocity&lt;/artifactId&gt;&lt;/dependency&gt; application.properties 配置1spring.velocity.suffix=.html 访问http://127.0.0.1:8080/vm12vvvv1 $&#123;value3&#125; 总结 @Controller 注释来定义说这是一个网页入口 @RequestMapping 指定访问地址or传入参数 用@PathVariable和@RequestParam对传入参数做解析 用@ResponseBody or 模板文件 返回结果]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2017%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一些基本的数据结构与算法 数据结构12345678910111213141516171819202122232425262728293031323334353637383940(1)数组 (Array) 在程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。 这些按序排列的同类数据元素的集合称为数组。 在Ｃ语言中， 数组属于构造数据类型。 一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。 因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。(2)栈 (Stack) 是只能在某一端插入和删除的特殊线性表。 它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶， 需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。(3)队列 (Queue) 一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。(4)链表 (Linked List) 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。(5)树 (Tree) 是包含n（n&gt;0）个结点的有穷集合K，且在K中定义了一个关系N，N满足 以下条件： （1）有且仅有一个结点 k0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。 （2）除K0外，k中的每个结点，对于关系N来说有且仅有一个前驱。 （3）K中各结点，对关系N来说可以有m个后继（m&gt;=0）。(6)图 (Graph) 图是由结点的有穷集合V和边的集合E组成。 其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对， 若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 链表定义结点1234567class Node &#123; Node next=null; int data; public Node (int data)&#123; this.data=data; &#125;&#125; 找单链表中倒数第K个元素一次遍历的方法：用2个指针，第一个指针先走K步；然后2个指针一起走；直到第一个指针到达尾部。123456789101112131415public Node findElem(Node head,int k)&#123; if(k&lt;1||k&gt;this.length())&#123; return null; &#125; Node p1=head; Node p2=head; for(int i=0;i&lt;k-1;i++)&#123; p1=p1.next; &#125; while (p1!=null)&#123; p1=p1.next; p2=p2.next; &#125; return p2; &#125; 从链表中删除重复数据方法1：HashTable需要额外存储空间时间复杂度较低1234567891011121314public void deleteDuplecate(Node head)&#123; Hashtable&lt;Integer,Integer&gt; table = new Hashtable&lt;Integer,Integer&gt;(); Node tmp=head; Node pre=null; while (tmp!=null)&#123; if(table.containsKey(tmp.data))&#123; pre.next=temp.next; &#125;else &#123; table.put(tmp.data,1); pre=tmp; &#125; tmp=tmp.next; &#125;&#125; 方法2：双指针法对链表进行双重循环外循环正常遍历链表，当前设为cur内循环从cur开始遍历若遇到与cur所指向结点值相同则删除这个结点1234567891011121314public void deleteDuplecate(Node head)&#123; Node cur=head; while(cur!=null)&#123; Node q=cur; while(q.next!=null)&#123; if(cur.data==q.next.data)&#123; q.next=q.next.next; &#125;else &#123; q=q.next; &#125; &#125; cur=cur.next; &#125;&#125; 在不知道头指针的情况下删除指定结点 若待删除结点为链表尾结点，则无法删除，因为前驱next指针为空 若删除不是尾结点，则先交换该节点和后继结点，再删除！12345678910public boolean deleteNode(Node n)&#123; if(n==null || n.next==null)&#123; return false; &#125; int temp=n.data; n.data=n.next.data; n.next.data=temp; //先交换当前与后继data n.next=n.next.next; //再指向下下结点 return true;&#125; 判断两个链表是否相交如果两个链表相交，那么他们一定有着相同的尾结点。分别遍历两个链表，记录他们的尾结点，如果他们的尾结点相同，那么这两个链表相交，否则不相交。12345678910111213141516public boolean isIntersect (Node h1, Node h2)&#123; if(h1==null || h2==null)&#123; return false; &#125; //遍历链表 1 Node tail1=h1; while (tail1.next!=null)&#123; tail1=tail1.next; &#125; //遍历链表 2 Node tail2=h2; while (tail2.next!=null)&#123; tail2=tail2.next; &#125; return tail1==tail2;&#125; 检测一个链表是否有环fast每次进2slow每次进11234567891011121314151617181920public boolean isLoop(Node head)&#123; Node fast=head; Node slow=head; if(fast==null)&#123; return false; &#125; //如果无环，就总会到尾巴然后退出 //如果有环，就总会追上 while (fast!=null &amp;&amp; fast.next!=null)&#123; fast=fast.next.next; slow=slow.next; if(fast==slow)&#123; return true; &#125; &#125; return !(fast==null &amp;&amp; fast.next==null); &#125;&#125; 栈和队列实现栈123456789101112131415161718192021222324252627282930313233343536373839404142public class MyStack&lt;E&gt;&#123; private Object[] stack; private int size; public MyStack()&#123; stack=new Object[10]; &#125; //判断堆栈是否为空 public boolean isEmpty()&#123; return size==0; &#125; public E peek()&#123; if(isEmpty())&#123; return null; &#125; return (E) stack[size-1]; &#125; public E pop()&#123; E e=peek(); stack[size-1]=null; size--; return e; &#125; public E push(E item)&#123; ensureCapacity(size+1);//检查容器 stack[size++]=item; return item; &#125; //判断数组是否已满，若满，则扩容 private void ensureCapacity(int size)&#123; int len=stack.length; if(size&gt;len)&#123; int newlen=10;//每次扩容10 stack= Arrays.copyOf(stack,newlen); &#125; &#125;&#125; 用O(1)的时间复杂度求栈中最小元素栈–后进先出因此pop和push只对栈顶元素进行操作使用两个栈结构，一个栈用来存储数据另一个栈用来存储栈的最小元素 入栈当前入栈元素比之前栈中最小值还小，则压入最小栈中 出栈如果当前出栈的元素是最小值，则把最小值栈的最小值也出栈，留下的就是栈的第二小值成了最小值12345678910111213141516171819202122232425262728293031323334public class MyStack1&#123; MyStack&lt;Integer&gt; elem; MyStack&lt;Integer&gt; min; public MyStack1()&#123; elem=new MyStack&lt;Integer&gt;(); min = new MyStack&lt;Integer&gt;(); &#125; public void push(int data)&#123; elem.push(data); if(min.isEmpty())&#123; min.push(data); &#125;else if(data&lt;min.peek())&#123; min.push(data); &#125; &#125; public int pop() &#123; int topData = elem.peek(); elem.pop(); if (topData == this.min()) &#123; min.pop(); &#125; return topData; &#125; public int min()&#123; if(min.isEmpty())&#123; return Integer.MAX_VALUE; &#125;else &#123; return min.peek(); &#125; &#125;&#125; 排序位运算用移位操作实现乘法运算把一个数向左移动n位相当于把该数乘以2的n次方1234567891011121314151617181920import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("m : "); int m = scanner.nextInt(); System.out.println("n : "); int n= scanner.nextInt(); System.out.println(powerN(m,n)); &#125;public static int powerN(int m,int n)&#123; for(int i=0;i&lt;n ; i++ )&#123; m=m&lt;&lt;1; &#125; return m; &#125;&#125; 判断一个数是否为2的n次方最直观的方法—直接递增对比1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("m : "); int m = scanner.nextInt(); System.out.println(power2(m)); &#125;public static boolean power2(int m)&#123; if(m&lt;1) return false; int i=1; while (i&lt;=m)&#123; if(i==m) return true; i=i&lt;&lt;1; &#125; return false; &#125;&#125; 效率更高的方法2的n次方，二进制中只有一个1，所以用 m&amp;(m-1) 就可以判断了12int num=m&amp;(m-1)；return num==0; 二进制中1的个数首先判断最后一位是否为1，是，则计数加1；然后右移丢弃最后一位12345678910111213141516171819202122import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("m : "); int m = scanner.nextInt(); System.out.println(countOne(m)); &#125;public static int countOne(int m)&#123; int count=0; while (m&gt;0)&#123; if((m&amp;1)==1)&#123; count++; &#125; m&gt;&gt;=1; &#125; return count; &#125;&#125; 更好的方法每与一次都消除1个1eg: 11001100 &amp; 1011 = 1000 , conut = 11000 &amp; 0111 = 0000 , count = 212345678910111213141516171819202122import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("m : "); int m = scanner.nextInt(); System.out.println(countOne(m)); &#125;public static int countOne(int m)&#123; int count=0; while (m&gt;0)&#123; if(m!=0)&#123; m=m&amp;(m-1); count++; &#125; &#125; return count;&#125;&#125; 数组判断一个数组中数值是否连续相邻一个数组序列 元素取值范围为0-65535 相同数值不会重复出现 0可以反复出现 设计一种算法，从数组中随机选取5个数值，判断这5个数值是否连续相邻 注意： 5个数值允许是乱序的，如{8,7,5,0,6} 0可以通配任意数值 0可以多次出现 全0算连续，只有一个非0算连续 思路： 如果没有0的存在，最大值与最小值相差必须等于4 如果0存在，则最大和最小相差小于4 1234567891011121314151617181920212223public class Main &#123; public static boolean IsContinuous(int[] array) &#123; int min=-1; int max=-1; for(int i=0;i&lt;array.length;i++)&#123; if(array[i]!=0) &#123; if (max &lt; array[i] || max == -1) &#123; max = array[i]; &#125; if (min &gt; array[i] || min == -1) &#123; min = array[i]; &#125; &#125; &#125; return (max-min)&lt;=4; &#125; public static void main(String[] args) &#123; int[] array = &#123;8,7,5,0,6&#125;; int k=2; System.out.print(IsContinuous(array)); &#125;&#125; 寻找数组中的最小值与最大值取双元素法维持两个全局变量Max，Min每次比较相连两个数将最大与Max比将最小与Min比遍历比较次数为1.5N12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; static int Max=Integer.MIN_VALUE; static int Min=Integer.MAX_VALUE; public static void GetMaxandMin(int [] array) &#123; for (int i = 0; i &lt; array.length; i += 2) &#123; if (i + 1 &gt; array.length - 1) &#123; if (array[i] &gt; Max) Max = array[i]; if (array[i] &lt; Min) Min = array[i]; &#125; else &#123; if (array[i] &gt; array[i + 1]) &#123; if (array[i] &gt; Max) Max = array[i]; if (array[i + 1] &lt; Min) Min = array[i + 1]; &#125; if (array[i] &lt; array[i + 1]) &#123; if (array[i + 1] &gt; Max) Max = array[i + 1]; if (array[i] &lt; Min) Min = array[i]; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //int [] array= &#123;3,5,6,8,1,4,2&#125;; int [] array= &#123;3,5,6&#125;; GetMaxandMin(array); System.out.println("Max = "+ Max); System.out.println("Min = "+ Min); &#125;&#125; 求最大子数组之和连续子数组，输出最大连续子数组之和 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static int[] maxSubArray(int[] array) &#123; int begin = 0; int end = 0; int nStart = 0; int max = Integer.MIN_VALUE; int nSum = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (nSum &lt; 0) &#123; nSum = array[i]; nStart = i; &#125; else &#123; nSum += array[i]; &#125; if (nSum &gt; max) &#123; max = nSum; begin = nStart; end = i; &#125; &#125; int[] num = &#123;begin, end&#125;; return num; &#125; public static void main(String[] args) &#123; int [] array= &#123;3,5,6,-24,1,4,2&#125;; // int [] array= &#123;3,5,6&#125;; int [] num=maxSubArray(array); for (int i=num[0];i&lt;=num[1];i++) System.out.println(array[i]); &#125;&#125; 找出数组中重复元素最多的数123456789public static int findMostFreInArray(int[] array) &#123; Map&lt;Integer ,Integer &gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;array.length;i++)&#123; if (map.containsKey(array[i])) &#123; map.put(array[i],map.get(array[i])+1); &#125;else &#123; map.put(array[i],1); &#125; &#125; 找出数组中只出现一次的数字一个数组中除了一个数字外，其他数字都出现了2次。 异或运算：任何数字异或它自己都等于0 如果从头到尾异或，那么最后得到的结果就是那个单一数字，其余都被抵消！ 1234567891011121314public class Main &#123; public static int findNotDouble(int[] array) &#123; int num = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; num ^= array[i]; &#125; return num; &#125; public static void main(String[] args) &#123; int[] array = &#123;3,3,4,76,4,7,76&#125;; int num = findNotDouble(array); System.out.println(num); &#125;&#125; 求数组中两两相加等于20的组合种数先排序 begin end 同时遍历 12345678910111213141516171819202122232425public class Main &#123; public static void findNotDouble(int[] array,int p) &#123; Arrays.sort(array); int begin=0; int end=array.length-1; int num=0; while (begin&lt;end)&#123; if (array[begin]+array[end]==p) &#123; System.out.println(array[begin]+","+array[end]); begin++; end--; &#125;else if(array[begin]+array[end]&gt;p)&#123; end--; &#125;else &#123; begin++; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = &#123;3,3,4,76,4,7,17,16,76&#125;; int point=20; findNotDouble(array,point); &#125;&#125; 把一个数组循环右移k位把12345678右移2位 得到78123456 把78 和123456 看成2个整体,右移k位就是把两部分交换。 只进行三次逆序操作，时间复杂度为O（n）。 逆序数组子序列123456，变成65432178 逆序78，变成65432187 全部逆序，变成78123456 123456789101112131415161718192021222324252627public class Main &#123; public static void reverse(int[] array,int p) &#123; reverpart(array,0,array.length-p-1); reverpart(array,array.length-p,array.length-1); reverpart(array,0,array.length-1); &#125; public static void reverpart(int [] arr,int a,int b)&#123; int temp=0; while (a&lt;b)&#123; temp=arr[a]; arr[a]=arr[b]; arr[b]=temp; a++; b--; &#125; &#125; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4,5,6,7,8&#125;; int point=2; reverse(array,point); for(int i=0;i&lt;array.length;i++)&#123; System.out.print(array[i]+" "); &#125; &#125;&#125; 字符串实现字符串的反转how are you you are how 两次反转过程 how are you uoy era woh you are how 123456789101112131415161718192021222324252627282930313233public class List &#123; public static void main(String[] args)&#123; String str="how are you"; System.out.println(swapword(str)); &#125; public static String swapword(String str)&#123; char [] cStr=str.toCharArray(); swap(cStr,0,cStr.length-1); int begin=0; for (int end=1;end&lt;cStr.length;end++)&#123; if(cStr[end]==' ')&#123; swap(cStr,begin,end-1); begin=end+1; end++; &#125; if(end==cStr.length-1)&#123; swap(cStr,begin,end); &#125; &#125; return new String(cStr); &#125; public static void swap(char [] str,int n ,int m)&#123; while (n&lt;m)&#123; char temp=str[n]; str[n]=str[m]; str[m]=temp; n++; m--; &#125; &#125;&#125; 判断两个字符串是否由相同字符组成aaaabbc和abcbaaa是不是相同的字符组成 12345678910111213141516171819202122232425262728293031public class List &#123; public static void main(String[] args)&#123; String str1="aaaabbce"; String str2="abcbaaad"; System.out.println(compare(str1,str2)); &#125; public static boolean compare(String str1,String str2)&#123; int [] num=new int [256]; int str1len=str1.length()-1; int str2len=str2.length()-1; while (str1len&gt;=0)&#123; // char temp=str1.charAt(0); num[str1.charAt(str1len)]++; str1len--; &#125; while (str2len&gt;=0)&#123; // char temp=str1.charAt(0); num[str2.charAt(str2len)]--; str2len--; &#125; for (int i=0;i&lt;num.length;i++)&#123; if(num[i]!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; 删除字符串中重复的字符简单的用数组[256]去判断 12345678910111213141516171819public class List &#123; public static void main(String[] args)&#123; String str1="aaaabbce"; System.out.println(removeDuplicate(str1)); &#125; public static String removeDuplicate(String str)&#123; int [] num=new int [256]; char [] cStr=new char[str.length()]; int j=0; for(int i=0;i&lt;str.length();i++)&#123; if(num[str.charAt(i)]==0)&#123; num[str.charAt(i)]++; cStr[j++]=str.charAt(i); &#125; &#125; return new String(cStr,0,j); &#125;&#125; 统计一行字符中有多少个单词用一个count 字母前有空格，则表示单词开始 count++ 字母前还是字母，则还没结束该单词 1234567891011121314151617181920public class List &#123; public static void main(String[] args)&#123; String str1="how are you"; System.out.println(wordCount(str1)); &#125; public static int wordCount(String str)&#123; int count =0; int i=1; for(;i&lt;str.length();i++)&#123; if(str.charAt(i-1)!=' '&amp;&amp;str.charAt(i)==' ')&#123; count++; &#125; &#125; if( str.charAt(i-1)!=' ')&#123; count++; &#125; return count; &#125;&#125; 二叉树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>数据结构</tag>
        <tag>Java程序员面试笔试宝典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Draw]]></title>
    <url>%2F2017%2F07%2F23%2FJava-Draw%2F</url>
    <content type="text"><![CDATA[Java绘图基础！ 简单绘画直线矩形圆根据矩阵画图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zhoudm;import java.awt.*;import javax.swing.*;public class Draw extends JFrame&#123; MyPanel mp = null ; public static void main(String[] args) &#123; // TODO Auto-generated method stub Draw qwe = new Draw(); &#125; public Draw() &#123; mp = new MyPanel(); this.add(mp); this.setSize(400,300); this.setVisible(true); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125;class MyPanel extends JPanel //我自己的面板，用于绘图和实现绘图区域&#123; //覆盖JPanel的paint方法 //Graphics是绘图的重要类，可以理解成一支画笔 public void paint(Graphics g) &#123; //1.调用父类函数完成初始化 super.paint(g); //这句话不能少 //System.out.println(&quot;被调用&quot;); //证明别调用 //画圆 int [][] drawnum=&#123;&#123;1,0,1,1&#125;, &#123;0,1,0,1&#125;, &#123;1,0,1,1&#125;, &#123;1,1,0,1&#125;&#125;; for(int i=0;i&lt;drawnum.length;i++)&#123; for(int j=0;j&lt;drawnum[0].length;j++)&#123; if(drawnum[i][j]==1)&#123; g.drawOval(30*i+50,30*j+50,25,25); g.setColor(Color.BLUE); &#125; &#125; &#125; // g.drawOval(10, 10, 30, 30); //画直线 // g.drawLine(20, 30, 20, 80); //画出矩形边框 // g.drawRect(50, 50, 100, 50); //画填充矩形 // g.setColor(Color.BLUE); //设置颜色 // g.fillRect(80,60,40,60); &#125;&#125; Java嵌入图片123456789101112class MyPanel extends JPanel //我自己的面板，用于绘图和实现绘图区域&#123; //覆盖JPanel的paint方法 //Graphics是绘图的重要类，可以理解成一支画笔 public void paint(Graphics g) &#123; //放置图片 Image im = Toolkit.getDefaultToolkit().getImage (Panel.class.getResource(&quot;/sysu.jpg&quot;)); g.drawImage(im, 50, 50, 70, 70, this); //this代指JPanel本身，意思是把图片放这上面 &#125;&#125; 将矩形图片切成圆形周边透明！123456789101112131415161718192021222324252627282930313233343536373839import java.awt.*;import java.awt.geom.Ellipse2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedImage bi1 = ImageIO.read(new File(&quot;G:/code/Java/leetcode/src/mm.jpg&quot;)); // 根据需要是否使用 BufferedImage.TYPE_INT_ARGB BufferedImage image = new BufferedImage(bi1.getWidth(), bi1.getHeight(), BufferedImage.TYPE_INT_ARGB); Ellipse2D.Double shape = new Ellipse2D.Double(0, 0, bi1.getWidth(), bi1 .getHeight()); Graphics2D g2 = image.createGraphics(); image = g2.getDeviceConfiguration().createCompatibleImage(bi1.getWidth(), bi1.getHeight(), Transparency.TRANSLUCENT); g2 = image.createGraphics(); g2.setComposite(AlphaComposite.Clear); g2.fill(new Rectangle(image.getWidth(), image.getHeight())); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, 1.0f)); g2.setClip(shape); // 使用 setRenderingHint 设置抗锯齿 g2.drawImage(bi1, 0, 0, null); g2.dispose(); try &#123; ImageIO.write(image, &quot;PNG&quot;, new File(&quot;G:/code/Java/leetcode/src/mm2.jpg&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 保存图片但是保存不了组建图片1234567891011Dimension imageSize = qwe.getSize(); BufferedImage image = new BufferedImage(imageSize.width, imageSize.height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = image.createGraphics(); qwe.paint(g); g.dispose(); try &#123; ImageIO.write(image, &quot;png&quot;, new File(&quot;G:/code/Java/leetcode/src/sysu2.jpg&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之贪心算法]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法基本思路1.建立数学模型来描述问题。 2.把求解的问题分成若干个子问题。 3.对每一子问题求解，得到子问题的局部最优解。 4.把子问题的解局部最优解合成原来解问题的一个解。 实现该算法的过程： 从问题的某一初始解出发； while 能朝给定总目标前进一步do 求出可行解的一个解元素； 由所有解元素组合成问题的一个可行解。 排序子序列牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2输入描述:输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。输出描述:输出一个整数表示牛牛可以将A最少划分为多少段排序子序列示例1输入61 2 3 2 2 1输出2123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int m = scanner.nextInt(); int[] num = new int[m]; for (int i = 0; i &lt; m; i++) &#123; num[i] = scanner.nextInt(); &#125; System.out.println(NewSort(m, num)); &#125; public static int NewSort(int m, int[] num) &#123; if (m &lt;= 0) &#123; return -1; &#125; int count = 1; int flags = 0; for (int i = 1; i &lt; m; i++) &#123; if (num[i] &gt; num[i - 1]) &#123; if(flags==0)&#123; flags=1; &#125; if(flags==-1)&#123; flags=0; count++; &#125; &#125; else if (num[i] &lt; num[i - 1]) &#123; if(flags==0)&#123; flags=-1; &#125; if(flags==1)&#123; count++; flags=0; &#125; &#125; &#125; return count; &#125;&#125; 组队竞赛训练部队12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之模拟实现]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[平衡数 消除重复元素 奇怪的表达式求值 变换次数1Java代码实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之数学]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[超级素数幂如果一个数字能表示为p^q(^表示幂运算)且p为一个素数,q为大于1的正整数就称这个数叫做超级素数幂。现在给出一个正整数n,如果n是一个超级素数幂需要找出对应的p,q。输入描述: 输入一个正整数n(2 ≤ n ≤ 10^18) 输出描述: 如果n是一个超级素数幂则输出p,q,以空格分隔,行末无空格。如果n不是超级素数幂，则输出No示例1输入27输出3 3123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner=new Scanner(System.in); System.out.println(&quot;剩下数字个数 ：&quot;); long n=scanner.nextLong(); boolean flag=false; double p; for(int q=2;q*q&lt;n;q++)&#123; p=Math.pow((double) n,1d/q); System.out.println(1d/q); System.out.println(1/q); if((long )p==p &amp;&amp; isPrimeNum((long)p))&#123; System.out.println((long)p+&quot; &quot;+q); flag=true; break; &#125; &#125; if(!flag)&#123; System.out.println(&quot;No&quot;); &#125; &#125; public static boolean isPrimeNum(long num)&#123; if (num&lt;=1)&#123; return false; &#125; for (int i=2;i*i&lt;=num;i++)&#123; if(num%i==0)&#123; return false; &#125; &#125; return true; &#125;&#125; 用 1d 取double很关键！1234567剩下数字个数 ：270.500.333333333333333303 3 找整除牛牛想在[a, b]区间内找到一些数满足可以被一个整数c整除,现在你需要帮助牛牛统计区间内一共有多少个这样的数满足条件？输入描述: 首先输入两个整数a,b,（-510^8 ≤ a ≤ b ≤ 510^8)接着是一个正整数c（1 &lt;= c &lt;= 1000） 输出描述: 输出一个整数表示个数。示例1输入0 14 5输出31234567891011121314151617181920import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner=new Scanner(System.in); System.out.println(&quot;整数a ：&quot;); int a=scanner.nextInt(); System.out.println(&quot;整数b ：&quot;); int b=scanner.nextInt(); System.out.println(&quot;正整数c ：&quot;); int c=scanner.nextInt(); int count=0; for(int n=a/c ; n*c&lt;=b;n++ )&#123; if(c*n&gt;=a) &#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 魔力手环小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。示例1输入 3 21 2 3输出8 9 712 混合颜料最大的奇约数末尾0的个数1Java代码实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之DFS/BFS]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8BDFS-BFS%2F</url>
    <content type="text"><![CDATA[推箱子 工作安排 幸运的袋子 饥饿的小易 跳石板 地下迷宫 1Java代码实现]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之动态规划]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[猴子摘桃小猴子下山，沿着下山的路有一排桃树，每棵树都结了一些桃子。小猴子想摘桃子，但是又一些条件需要遵守，小瘦子只能沿着下山的方向走，不能回头，每棵树最多摘一个，而且一旦摘了一棵树的桃子，就不能再摘比这棵树结的桃子少的树上的桃子，那么小猴子最多能摘到几课桃子呢？距离说明，比如有五棵树，分别结了10，4，5，12，8棵桃子，那么小猴子最多能摘3颗桃子，来自于结了4，5，12颗桃子的桃树。 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; int[] m = &#123;10,4,5,12,8&#125;; int maxP[]=new int [m.length]; for(int j=0;j&lt;m.length;j++)&#123; maxP[j]=1; for (int k=0;k&lt;j;k++)&#123; if(maxP[k]+1&gt;maxP[j] &amp;&amp; m[j]&gt;m[k])&#123; maxP[j]=maxP[k]+1; &#125; &#125; &#125; int maxPeach=1; for (int k=0;k&lt;maxP.length;k++)&#123; if(maxPeach&lt;maxP[k])&#123; maxPeach=maxP[k]; &#125; &#125; System.out.println(maxPeach); &#125; &#125; 页码统计牛牛新买了一本算法书，算法书一共有n页，页码从1到n。牛牛于是想了一个算法题目：在这本算法书页码中0~9每个数字分别出现了多少次？输入描述: 输入包括一个整数n(1 ≤ n ≤ 1,000,000,000) 输出描述: 输出包括一行10个整数，即0~9这些数字在页码中出现的次数，以空格分隔。行末无空格。示例1输入1999 输出1189 300 300 300 300 300 300 300 300 300 创造新世界双核处理堆砖块不等式数列牛牛的数列牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。输入描述: 输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。 输出描述: 输出一个整数,表示最长的长度。示例1输入126 7 2 3 1 5 6 输出15 暗黑的字符串数字和为sum的方法数1Java代码实现]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常考面试算法题之暴力枚举]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[结合2017春招和秋招真题，以下几类算法题最常考，汇总了一下： 好多鱼！牛牛有一个鱼缸。鱼缸里面已经有n条鱼，每条鱼的大小为fishSize[i] (1 ≤ i ≤ n,均为正整数)，牛牛现在想把新捕捉的鱼放入鱼缸。鱼缸内存在着大鱼吃小鱼的定律。经过观察，牛牛发现一条鱼A的大小为另外一条鱼B大小的2倍到10倍(包括2倍大小和10倍大小)，鱼A会吃掉鱼B。考虑到这个，牛牛要放入的鱼就需要保证：1、放进去的鱼是安全的，不会被其他鱼吃掉2、这条鱼放进去也不能吃掉其他鱼鱼缸里面已经存在的鱼已经相处了很久，不考虑他们互相捕食。现在知道新放入鱼的大小范围minSize,maxSize,牛牛想知道有多少种大小的鱼可以放入这个鱼缸。 输入描述:输入数据包括3行.第一行为新放入鱼的尺寸范围minSize,maxSize(1 ≤ minSize,maxSize ≤ 1000)，以空格分隔。第二行为鱼缸里面已经有鱼的数量n(1 ≤ n ≤ 50)第三行为已经有的鱼的大小fishSizei，以空格分隔。 输出描述:输出有多少种大小的鱼可以放入这个鱼缸。考虑鱼的大小都是整数表示示例1输入1231 1211 输出13 12345678910111213141516171819202122232425262728293031323334import java.util.Random;import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;minSize :&quot;); int minSize = scanner.nextInt(); System.out.println(&quot;maxSize :&quot;); int maxSize = scanner.nextInt(); System.out.println(&quot;inNumber :&quot;); int inNumber = scanner.nextInt(); System.out.println(&quot;inFishSize[ ] :&quot;); int [] inFishSize = new int[inNumber]; for(int i=0;i&lt;inNumber;i++) &#123; inFishSize[i]=scanner.nextInt(); &#125; int count =0; for(int i=minSize;i&lt;=maxSize ;i++)&#123; boolean flag=false; for(int j=0;j&lt;inNumber ;j++)&#123; if(( i*2&lt;=inFishSize[j]&amp;&amp;inFishSize[j]&lt;=i*10 )||( inFishSize[j]*2&lt;=i &amp;&amp; inFishSize[j]*10&gt;=i ))&#123; flag=true; break; &#125; &#125; if(!flag)&#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; DNA合成DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。碱基互补配对原则：A和T是配对的，C和G是配对的。如果两条碱基链长度是相同的并且每个位置的碱基是配对的，那么他们就可以配对合成为DNA的双螺旋结构。现在给出两条碱基链，允许在其中一条上做替换操作：把序列上的某个位置的碱基更换为另外一种碱基。问最少需要多少次让两条碱基链配对成功输入描述:输入包括一行：包括两个字符串,分别表示两条链,两个字符串长度相同且长度均小于等于50。输出描述:输出一个整数，即最少需要多少次让两条碱基链配对成功示例1输入12ACGTTGCA 输出10 12345678910111213141516171819202122232425import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入碱基s1 :&quot;); String s1=scanner.nextLine(); System.out.println(&quot;输入碱基s2 :&quot;); String s2= scanner.nextLine(); if(s1.length()!=s2.length()||s1.isEmpty()||s2.isEmpty())&#123; return; &#125; int count =0; for(int i=0;i&lt;s1.length();i++)&#123; if(!( (s1.charAt(i)==&apos;A&apos; &amp;&amp; s2.charAt(i)==&apos;T&apos;) || (s2.charAt(i)==&apos;A&apos; &amp;&amp; s1.charAt(i)==&apos;T&apos;) || (s1.charAt(i)==&apos;C&apos; &amp;&amp; s2.charAt(i)==&apos;G&apos;) || (s2.charAt(i)==&apos;C&apos; &amp;&amp; s1.charAt(i)==&apos;G&apos;) ))&#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 连续整数牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正整数，牛牛现在要猜出所有可能是抹除掉的整数。例如：10 7 12 8 11 那么抹除掉的整数只可能是95 6 7 8 那么抹除掉的整数可能是4也可能是9输入描述:输入包括2行：第一行为整数n(1 &lt;= n &lt;= 50)，即抹除一个数之后剩下的数字个数第二行为n个整数num[i] (1 &lt;= num[i] &lt;= 1000000000)输出描述:在一行中输出所有可能是抹除掉的数,从小到大输出,用空格分割,行末无空格。如果没有可能的数，则输出mistake示例1输入1223 6 输出1mistake 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner=new Scanner(System.in); System.out.println(&quot;剩下数字个数 ：&quot;); int n=scanner.nextInt(); int [] num=new int[n]; System.out.println(&quot;输入剩下数字 :&quot;); int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; int s=0; for(int i=0;i&lt;n;i++)&#123; num[i]=scanner.nextInt(); s+=num[i]; if(num[i]&lt;min) min=num[i]; if(num[i]&gt;max) max=num[i]; &#125; if(max-min+1 == n)&#123; if(s==(max+min)*n/2)&#123; if(min&gt;1)&#123; System.out.println((min-1)+&quot; &quot;+ (max+1)); &#125;else &#123; System.out.println(max+1); &#125; &#125;else &#123; System.out.println(&quot;mistake!&quot;); &#125; &#125;else &#123; if(max-min==n)&#123; for(int j=1;j&lt;n;j++)&#123; if(num[j]==num[j-1])&#123; System.out.println(&quot;mistake!&quot;); &#125;else if (num[j]==num[j-1]+2)&#123; System.out.println(num[j]-1); &#125; &#125; &#125;else &#123; System.out.println(&quot;mistake!&quot;); &#125; &#125; &#125;&#125; 序列和01翻转最长公共连续子串 组装三角形 最小的矩形 字符串分类 优美的回文串 赶去公司 调整队形 集合 涂棋盘 小易记单词 分饼干 买帽子 度度熊回家 寻找三角形 有趣的排序 神奇数 添加字符 数组变换1Java代码实现]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经-阿里1]]></title>
    <url>%2F2017%2F07%2F20%2F%E9%9D%A2%E7%BB%8F-%E9%98%BF%E9%87%8C1%2F</url>
    <content type="text"><![CDATA[阿里面经总结，查漏补缺~ Java基础：面向对象和面向过程的区别面向过程就像一个细心的管家，什么事情都要考虑到；而面向对象就像家用电器，只需要知道他的功能，不用知道工作原理。面向过程是一种以事件为中心的编程思想，分析出解决问题所需要的步骤，然后用函数将这些步骤实现，并按顺序调用；面向对象是以对象为中心的编程思想。eg:汽车发动，汽车到站对面向过程来说，这是两个事件，关心的是事件，不是汽车本身，写两个事件函数，分别调用； Java的四个基本特性（抽象、封装、继承，多态）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：通常认为封装就是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装，我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类)；得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应。 多态的理解(实现方法)Overload和Override的区别方法重载–Overload：实现的是编译时的多态性(也称为前绑定)。 方法重写–Override：实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西。 要实现多态需要做两件事：1.方法重写子类继承父类并重写父类中已有的或抽象的方法2.对象造型用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。 项目中对多态的应用举个栗子，在实验室信息管理系统中，有两种用户，教师和学生，两个用户都可以登陆系统，他们有相同的方法Login，但登陆之后他们会进入不同的页面，也就是在登陆时会有不同的操作，两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。 构造器Constructor是否可被override 访问控制符public,protected,private,以及默认的区别 是否可以继承String类 String和StringBuffer、StringBuilder的区别 hashCode和equals方法的关系 抽象类和接口的区别 自动装箱与拆箱 什么是泛型、为什么要使用以及泛型擦除 Java中的集合类及关系图 HashMap实现原理(看源代码) HashTable实现原理(看源代码) HashMap和HashTable区别HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap；HashTable不允许null值(key 和 value都不可以)，HashMap允许null值(key 和 value 都可以)；两者的遍历方式大同小异，HashTable仅仅比HashMap多一个elements方法； HashTable和HashMap都能通过values()方法返回一个Collection，然后进行遍历处理，两者也都可以通过entrySet()方法返回一个Set，然后进行遍历处理。 HashTable使用Enumeration，HashMap使用Iterator。 哈希值的使用不同，HashTable直接使用对象的HashCode，HashMap重新计算hash值，而且用于代替求模；HashTable中hash数组默认大小是11，增加的方式是old*2+1，HashMap中hash数组的默认大小是16，而且一定是2的指数；HashTable基于Dictionary，而HashMap基于AbstractMap类。 HashTable如何实现线程安全(看源代码) ArrayList和vector区别(看源代码) ArrayList和LinkedList区别及使用场景 Collection和Collections的区别 Concurrenthashmap实现原理(看源代码) Error、Exception区别 Unchecked Exception和Checked Exception，各列举几个 Java中如何实现代理机制(JDK、CGLIB) 多线程的实现方式 线程的状态转换 如何停止一个线程 什么是线程安全某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait，sleep，join等控制方式，如果一个类在多线程访问下运转一切正常，并且访问类不需要进行额外的同步处理或协调，那么我们认为它是线程安全的。 如何保证线程安全对变量使用volitate对程序段进行加锁(synchronized,lock) Synchronized如何使用 synchronized和Lock的区别 多线程如何进行信息交互 sleep和wait的区别(考察的方向是是否会释放锁) 多线程与死锁 如何才能产生死锁 什么叫守护线程，用什么方法实现守护线程 Java线程池技术及原理线程池就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 java并发包concurrent及常用的类 volatile关键字 Java中的NIO，BIO，AIO分别是什么 IO和NIO区别 序列化与反序列化 常见的序列化协议有哪些 内存溢出和内存泄漏的区别 Java内存模型及各个区域的OOM，如何重现OOM 出现OOM如何解决 用什么工具可以查出内存泄漏 Java内存管理及回收算法 Java类加载器及如何加载类(双亲委派) xml解析方式 Statement和PreparedStatement之间的区别 JavaEE:servlet生命周期及各个方法①实例化阶段：服务器对Servlet进行实例化，调用Servlet的构造方法②初始化阶段：服务器调用Servlet的init方法进行初始化（只在第一次请求时调用）。③请求处理阶段：服务器调用Servlet的service方法，然后根据请求方式调用相应的doXXX方法。④服务终止阶段：服务器调用Servlet的destroy方法销毁Servlet实例 servlet中如何自定义filter JSP原理 JSP和Servlet的区别 JSP的动态include和静态include Struts中请求处理过程 MVC概念 8.Spring mvc与Struts区别 Hibernate/Ibatis两者的区别 Hibernate一级和二级缓存 Hibernate实现集群部署 Hibernate如何实现声明式事务 简述Hibernate常见优化策略 Spring bean的加载过程(推荐看Spring的源码) Spring如何实现AOP和IOC Spring bean注入方式 Spring的事务管理(推荐看Spring的源码) Spring事务的传播特性 springmvc原理 springmvc用过哪些注解 Restful有几种请求 Restful好处 Tomcat，Apache，JBoss的区别 memcached和redis的区别 有没有遇到中文乱码问题，如何解决的 如何理解分布式锁 你知道的开源协议有哪些 json和xml区别 设计模式：设计模式的六大原则 单一职责原则定义：不要存在多于一个导致类变更的原因。即一个类只负责一项职责。 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 常用的设计模式 用一个设计模式写一段代码或画出一个设计模式的UML 如何理解MVC 高内聚，低耦合方面的理解内聚性又称快内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素联系的越紧密，则它的内聚性就越高。耦合性也称块间联系，指软件系统结构中各模块间相互紧密程度的一种度量。模块间联系越紧密，其耦合性就越强。将软件系统化分模块时，尽量做到高内聚低耦合，提高模块的独立性。有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。 算法： 深度优先、广度优先算法 排序算法及对应的时间复杂度和空间复杂度 写一个排序算法 查找算法 B+树和二叉树查找时间复杂度 KMP算法、hash算法 常用的hash算法有哪些 如何判断一个单链表是否有环？ 给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？ 给你一个数组，如何里面找到和为K的两个数？ 100000个数找出最小或最大的10个？ 一堆数字里面继续去重，要怎么处理？ 数据结构： 队列、栈、链表、树、堆、图 编码实现队列、栈 Linux:linux常用命令 cd命令：切换目录 ls命令：查看文件与目录 grep命令：分析一行的信息 find命令：查找 cp命令：copy，复制文件 mv命令：move ，移动文件，目录或更名 rm命令: 该命令用于删除文件或目录，remove ps命令: 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意 kill命令: 该命令用于向某个工作或者是某个PID（数字）传送一个信号 killall命令: 该命令用于向一个命令启动的进程发送一个信号 file命令: 该命令用于判断接在file命令后的文件的基本数据 tar命令: 该命令用于对文件进行打包 cat命令: 该命令用于查看文本文件的内容，后接要查看的文件名 chgrp命令: 该命令用于改变文件所属用户组 chown命令: 该命令用于改变文件的所有者 chmod命令: 该命令用于改变文件的权限 vim命令: 该命令主要用于文本编辑，它接一个或多个文件名作为参数 gcc命令: 对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序 time命令: 该命令用于测算一个命令（即程序）的执行时间 如何查看内存使用情况 Linux下如何进行进程调度 操作系统： 操作系统什么情况下会死锁 产生死锁的必要条件 死锁预防 数据库： 范式 数据库事务隔离级别 数据库连接池的原理 乐观锁和悲观锁 如何实现不同数据库的数据查询分页 SQL注入的原理，如何预防 数据库索引的实现(B+树介绍、和B树、R树区别) SQL性能优化 数据库索引的优缺点以及什么时候数据库索引失效 10.Redis的存储结构 网络： OSI七层模型以及TCP/IP四层模型 HTTP和HTTPS区别 HTTP报文内容 get提交和post提交的区别 get提交是否有字节限制，如果有是在哪限制的 TCP的三次握手和四次挥手 session和cookie的区别 HTTP请求中Session实现原理 redirect与forward区别 10.DNS TCP和UDP区别 安全： 如果客户端不断的发送请求连接会怎样 DDos攻击 DDos预防 那怎么知道连接是恶意的呢？可能是正常连接 其它： 说一个你参与的项目、其中作为什么角色 遇到最困的问题是什么，怎么解决的 你认为自己有那些方面不足 平常如何学习的 如何评价自己 智力题： 给你50个红球和50个黑球，有两个一模一样的桶，往桶里放球，让朋友去随机抽，采用什么策略可以让朋友抽到红球的概率更高？ 从100个硬币中找出最轻的那个假币？ 1Java代码实现]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>Java</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SemiCode测试流程]]></title>
    <url>%2F2017%2F07%2F19%2FSemiCode%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一次写脚本测试！ 测试目的随机生成大量SemiCode，从译码检测算法完备性！ 测试结果1、第一次测试10万张码有5%的无法译出，单独调试发现是寻像算法寻像出错2、为了补充寻像算法，写了个图片旋转的算法3、第二次测试重新生成10万张码，全部译出4、第三次测试10万张，全部译出5、结论：代码的健壮性非常好！ 测试流程生成1、用随机字符串生成内容，用随机数字生成输入内容大小2、用时间戳给每张二维码命名3、将生成的二维码的名字（时间戳）保存到encode.txt文件4、将生成的二维码图片保存到encodePic文件夹5、for循环生成10万张SemiCode二维码 解码1、从encode.txt文本中分别读取每个图片的名字2、根据图片name从encodePic中调取图片3、for循环译码4、将无法译出的图片旋转测试（补充寻像算法）5、将译码结果保存到decode.txt6、从decode.txt中查找译码信息为null的二维码单独调试 关键代码生成随机字符串以及随机汉字12345678910111213public static String RandomString(int length) &#123; String str = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:/?@#$&amp;*()+&quot;; Random random = new Random(); StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; length-1; i++) &#123; int num = random.nextInt(73); if(num==72)&#123; length-=1; &#125; buf.append( num!=72? str.charAt(num):(char) (0x4e00 + (int) (Math.random() * (0x9fa5 - 0x4e00 + 1)))); &#125; return buf.toString(); &#125; 生成随机数字123456public static int suijinum(int max) &#123; int min=2; Random random = new Random(); int s = random.nextInt(max)%(max-min+1) + min; return s; &#125; 时间戳生成随机图片name123456789String pname = &quot;a&quot;;Random rand = new Random();SimpleDateFormat df = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);//设置日期格式String time = df.format(new Date());int randnum1 = rand.nextInt(900)+100;time=time.concat(String.valueOf(randnum1));int randnum2 = rand.nextInt(90)+10;time=time.concat(String.valueOf(randnum2));pname=time; 读写txt文件123456789101112131415161718192021222324252627282930313233343536import java.io.File; import java.io.InputStreamReader; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileWriter; public class cin_txt &#123; static void main(String args[]) &#123; try &#123; // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw /* 读入TXT文件 */ String pathname = &quot;D:\\twitter\\13_9_6\\dataset\\en\\input.txt&quot;; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径 File filename = new File(pathname); // 要读取以上路径的input。txt文件 InputStreamReader reader = new InputStreamReader( new FileInputStream(filename)); // 建立一个输入流对象reader BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言 String line = &quot;&quot;; line = br.readLine(); while (line != null) &#123; line = br.readLine(); // 一次读入一行数据 &#125; /* 写入Txt文件 */ File writename = new File(&quot;.\\result\\en\\output.txt&quot;); // 相对路径，如果没有则要建立一个新的output。txt文件 writename.createNewFile(); // 创建新文件 BufferedWriter out = new BufferedWriter(new FileWriter(writename)); out.write(&quot;我会写入文件啦\r\n&quot;); // \r\n即为换行 out.flush(); // 把缓存区内容压入文件 out.close(); // 最后记得关闭文件 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 计算代码时间1234long startTime=System.currentTimeMillis(); //获取开始时间 doSomeThing(); //测试的代码段 long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println(&quot;程序运行时间： &quot;+(endTime-startTime)+&quot;ms&quot;); 旋转图片测试,返回图片name1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 旋转 * * @param degree * 旋转角度 * @throws Exception */ public static String spin(int degree ,String imgPath,String line) throws Exception &#123; int swidth = 0; // 旋转后的宽度 int sheight = 0; // 旋转后的高度 int x; // 原点横坐标 int y; // 原点纵坐标 File file = new File(imgPath); if (!file.isFile()) &#123; throw new Exception(&quot;ImageDeal&gt;&gt;&gt;&quot; + file + &quot; 不是一个图片文件!&quot;); &#125; BufferedImage bi = ImageIO.read(file); // 读取该图片 // 处理角度--确定旋转弧度 degree = degree % 360; if (degree &lt; 0) degree = 360 + degree;// 将角度转换到0-360度之间 double theta = Math.toRadians(degree);// 将角度转为弧度 // 确定旋转后的宽和高 if (degree == 180 || degree == 0 || degree == 360) &#123; swidth = bi.getWidth(); sheight = bi.getHeight(); &#125; else if (degree == 90 || degree == 270) &#123; sheight = bi.getWidth(); swidth = bi.getHeight(); &#125; else &#123; swidth = (int) (Math.sqrt(bi.getWidth() * bi.getWidth() + bi.getHeight() * bi.getHeight())); sheight = (int) (Math.sqrt(bi.getWidth() * bi.getWidth() + bi.getHeight() * bi.getHeight())); &#125; x = (swidth / 2) - (bi.getWidth() / 2);// 确定原点坐标 y = (sheight / 2) - (bi.getHeight() / 2); BufferedImage spinImage = new BufferedImage(swidth, sheight, bi.getType()); // 设置图片背景颜色 Graphics2D gs = (Graphics2D) spinImage.getGraphics(); gs.setColor(Color.white); gs.fillRect(0, 0, swidth, sheight);// 以给定颜色绘制旋转后图片的背景 AffineTransform at = new AffineTransform(); at.rotate(theta, swidth / 2, sheight / 2);// 旋转图象 at.translate(x, y); AffineTransformOp op = new AffineTransformOp(at, AffineTransformOp.TYPE_BICUBIC); spinImage = op.filter(bi, spinImage); String linesp=line+degree; File sf = new File(&quot;G:/ProjectQRcode/SpringPro/Test/spanpic&quot;, linesp + &quot;.&quot; +&quot;png&quot;); ImageIO.write(spinImage, &quot;png&quot;, sf); // 保存图片 return linesp; &#125;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具代码]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一些小的小工具代码 随机字符串1234567891011/** 产生一个随机的字符串*/ public static String RandomString(int length) &#123; String str = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; Random random = new Random(); StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; length; i++) &#123; int num = random.nextInt(62); buf.append(str.charAt(num)); &#125; return buf.toString(); &#125; java生成指定范围的随机数123456789101112import java.util.Random;public class RandomTest &#123; public static void main(String[] args) &#123; int max=20; int min=10; Random random = new Random(); int s = random.nextInt(max)%(max-min+1) + min; System.out.println(s); &#125;&#125; 时间戳1234567891011String pname = &quot;a&quot;;Random rand = new Random();SimpleDateFormat df = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);//设置日期格式String time = df.format(new Date());int randnum1 = rand.nextInt(900)+100; time=time.concat(String.valueOf(randnum1));int randnum2 = rand.nextInt(90)+10; time=time.concat(String.valueOf(randnum2));pname=time;String imgPath = &quot;C:/Users/Administrator/Desktop/Timecode/&quot;+pname+&quot;.png&quot;; 读写text文件123456789101112131415161718192021222324252627282930313233343536import java.io.File; import java.io.InputStreamReader; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileWriter; public class cin_txt &#123; static void main(String args[]) &#123; try &#123; // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw /* 读入TXT文件 */ String pathname = &quot;D:\\twitter\\13_9_6\\dataset\\en\\input.txt&quot;; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径 File filename = new File(pathname); // 要读取以上路径的input。txt文件 InputStreamReader reader = new InputStreamReader( new FileInputStream(filename)); // 建立一个输入流对象reader BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言 String line = &quot;&quot;; line = br.readLine(); while (line != null) &#123; line = br.readLine(); // 一次读入一行数据 &#125; /* 写入Txt文件 */ File writename = new File(&quot;.\\result\\en\\output.txt&quot;); // 相对路径，如果没有则要建立一个新的output。txt文件 writename.createNewFile(); // 创建新文件 BufferedWriter out = new BufferedWriter(new FileWriter(writename)); out.write(&quot;我会写入文件啦\r\n&quot;); // \r\n即为换行 out.flush(); // 把缓存区内容压入文件 out.close(); // 最后记得关闭文件 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 计算代码时间1234long startTime=System.currentTimeMillis(); //获取开始时间 doSomeThing(); //测试的代码段 long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println(&quot;程序运行时间： &quot;+(endTime-startTime)+&quot;ms&quot;);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(51-67)]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%89%91%E6%8C%87Offer(51-67)%2F</url>
    <content type="text"><![CDATA[英文新增面试题！ 题51：数组中重复的数字题目： 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 思路： 1、排序 将数组排序，然后扫描排序后的数组即可。 时间复杂度：O(nlogn)，空间复杂度:O(1) 2、哈希表 从头到尾扫描数组，每扫描到一个数字，判断该数字是否在哈希表中，如果该哈希表还没有这个数字，那么加入哈希表，如果已经存在，则返回该数字； 时间复杂度：O(n)，空间复杂度:O(n) 3、交换 0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置； 从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i， 如果是，则继续扫描下一个数字； 如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置； 重复上述过程，直至找到一个重复的数字； 时间复杂度：O(n)，空间复杂度：O(1) (将每个数字放到属于自己的位置最多交换两次)123456789101112131415161718192021222324252627public class Main&#123; public static void main(String[] args)&#123; int[] nums=&#123;2,3,1,0,2,5,3&#125;; duplicate(nums); &#125; public static void duplicate(int [] nums)&#123; if(nums==null ||nums.length&lt;=0) return; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;nums.length) return ; &#125; for(int i=0;i&lt;nums.length;i++)&#123; while (nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; System.out.println(nums[i]); break; &#125; int temp=nums[nums[i]]; nums[nums[i]]=nums[i]; nums[i]=temp; &#125; &#125; &#125;&#125; 题52：构建乘积数组题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法12345678910111213141516171819202122public class Main&#123; public static void main(String[] args)&#123; int[] nums=&#123;1,2,3,4,5&#125;; ConstructAarry(nums); &#125; public static void ConstructAarry(int [] nums)&#123; int [] A =new int [nums.length] ; int [] B =new int [nums.length] ; int [] C =new int [nums.length] ; B[0]=1; C[0]=1; for(int i=1;i&lt;nums.length;i++)&#123; B[i]=B[i-1]*nums[i-1]; C[i]=C[i-1]*nums[nums.length-i]; &#125; for(int i=0;i&lt;nums.length;i++)&#123; A[i]=B[i]*C[nums.length-i-1]; System.out.println(A[i]); &#125; &#125;&#125; 题53：正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配12 题54：表示数值的字符串题目： 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); String str=sc.next(); char [] chr=str.toCharArray(); System.out.println(isNum(chr)); &#125; public static boolean isNum(char [] chr)&#123; if(chr==null) return false; int index=0; if(chr[index]==&apos;+&apos;||chr[index]==&apos;-&apos;)&#123; index++; &#125; if (index==chr.length) return false; boolean num=true; //数有多少个数字 while (index&lt;chr.length&amp;&amp;chr[index]&gt;=&apos;0&apos;&amp;&amp;chr[index]&lt;=&apos;9&apos;)&#123; index++; &#125; if(index!=chr.length)&#123; if(chr[index]==&apos;.&apos;)&#123; index++; while (index&lt;chr.length&amp;&amp;chr[index]&gt;=&apos;0&apos;&amp;&amp;chr[index]&lt;=&apos;9&apos;)&#123; index++; &#125; if(index&lt;chr.length&amp;&amp;(chr[index]==&apos;E&apos;||chr[index]==&apos;e&apos;))&#123; num=isExponential(chr,index); &#125;else num=false; &#125; &#125; return num&amp;&amp;index==chr.length; &#125; public static boolean isExponential(char[]chr ,int index)&#123; index++; if(index==chr.length) return false; if(chr[index]==&apos;+&apos;||chr[index]==&apos;-&apos;)&#123; index++; &#125; if(index==chr.length) return false; while (index&lt;chr.length&amp;&amp;chr[index]&gt;=&apos;0&apos;&amp;&amp;chr[index]&lt;=&apos;9&apos;)&#123; index++; &#125; return index==chr.length? true:false; &#125;&#125; 题55：字符流中第一个不重复的字符请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。12345678910111213141516171819202122import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); String str=sc.next(); System.out.println( FirstAppearingOnce(str)); &#125; public static char FirstAppearingOnce(String str)&#123; int [] hash=new int [256]; for(int i=0;i&lt;str.length();i++)&#123; hash[str.charAt(i)]++; &#125; int j=0; while (hash[str.charAt(j)]!=1)&#123; j++; &#125; return str.charAt(j); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(41-50)]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%89%91%E6%8C%87Offer(41-50)%2F</url>
    <content type="text"><![CDATA[题46：求1+2+3+…+n【题目描述】求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）123456789101112131415161718192021import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); int num1=sc.nextInt(); int num2=sc.nextInt(); System.out.println( add(num1,num2)); &#125; public static int add(int num1 ,int num2)&#123; int sum ,carry; do &#123; sum=num1^num2; carry=(num1&amp;num2)&lt;&lt;1; num1=sum; num2=carry; &#125;while (carry!=0); return num1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用算法手册]]></title>
    <url>%2F2017%2F07%2F10%2FJava%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[本书于黄埔图书馆（香雪馆）偶读之，算法不错！ 简单约瑟夫环算法1.算法背景:罗马人攻占了乔塔帕特，41人藏在一个山洞中躲过了这场浩劫。这41个人中，包括历史学家josephus和他的一个朋友。剩余的39个人为了表示不向罗马人屈服，决定集体自杀。大家决定了一个自杀方案，所有这41人围城一个圆圈，由第一个人开始顺时针报数，没报数为3的人就立刻自杀，然后由下一个人重新开始报数任然是每报数为3的人就立刻自杀,……,知道所有人都自杀死亡为止.约瑟夫和他的朋友并不像自杀，于是约瑟夫想到了一个计策，他们两个同样参数到自杀方案中，但是最后却躲过了自杀。请问是怎么做到的 1234567891011121314151617181920212223242526272829303132333435public class Main&#123; static final int nums=41;//总人数 static final int killMan = 3; //数到3则杀 public static void main(String[] args)&#123; Joseph(2); &#125; public static void Joseph(int alive)&#123; int []man =new int [nums]; // 存活者为0 int pos=-1; //数组角标 int i=0; //循环，与3比较 int count=1; //杀到第几个计数 while(count&lt;=nums)&#123; do &#123; pos=(pos+1)%nums; //环状处理 if(man[pos]==0) i++; if(i==killMan)&#123; i=0; break; &#125; &#125;while (true); man[pos]=count; //记录pos+1位置的是第几个挂 count++; &#125; alive=nums-alive; for(int j=0;j&lt;nums;j++)&#123; if(man[j]&gt;alive)&#123; System.out.println(&quot;不被杀的位置是：&quot;+(j+1)); //数组从0开始，所以位置是j+1 &#125; &#125; &#125;&#125; 0 = 14 1 = 36 2 = 1 3 = 38 4 = 15 5 = 2 6 = 24 7 = 30 8 = 3 9 = 16 10 = 34 11 = 4 12 = 25 13 = 17 14 = 5 15 = 40 16 = 31 17 = 6 18 = 18 19 = 26 20 = 7 21 = 37 22 = 19 23 = 8 24 = 35 25 = 27 26 = 9 27 = 20 28 = 32 29 = 10 30 = 41 31 = 21 32 = 11 33 = 28 34 = 39 35 = 12 36 = 22 37 = 33 38 = 13 39 = 29 40 = 23 背包问题–动态规划背包问题具体例子：假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。将哪些物品放入背包可使得背包中的总价值最大？]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2017%2F07%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[读书笔记~ TCP/IP详解读书笔记分层应用层：Telnet、FTP和e-mail等运输层：TCP和UDP网络层：IP、ICMP和IGMP链路层：设备驱动程序及接口卡 中国大学MOOC-计算机网络第三周超文本传输协议 HyperText Transfer Protocol使用TCP传输服务 ·服务器在80端口等待客户的请求 ·浏览器发起到服务器的TCP连接（创建套接字Socket） ·服务器接收来自浏览器的TCP连接 ·浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息 ·关闭TCP连接Email应用构成：邮件客户端：读写email消息；与服务器交互，收发email消息。邮件服务器SMTP协议 计算机网络自顶向下方法第2章 应用层1.TCP服务·面向连接服务·可靠数据传输服务2.运输层协议·可靠数据传输·吞吐量·定时·安全性 1Java代码实现]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(31-40)]]></title>
    <url>%2F2017%2F07%2F05%2F%E5%89%91%E6%8C%87Offer(31-40)%2F</url>
    <content type="text"><![CDATA[剑指Offer 题31：连续子数组的最大和题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。例子说明：例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和 18 。123456789101112131415161718192021222324252627public class Main&#123; public static void main(String[] args)&#123; int [] arr=&#123;1, -2, 3, 10, -4, 7, 2, -5&#125;; System.out.println(bigsum(arr)); &#125; private static boolean flag=true; public static int bigsum(int [] arr)&#123; if(arr==null || arr.length&lt;=0)&#123; flag=false; return 0; &#125; int bigsum=0; int sum=0; for(int i=0;i&lt;arr.length;i++)&#123; if(sum&lt;=0)&#123; sum=arr[i]; &#125;else &#123; sum+=arr[i]; &#125; if(bigsum&lt;sum)&#123; bigsum=sum; &#125; &#125; return bigsum; &#125;&#125; 题32：求从 1 到 n 的整数中 1 出现的次数题目：输入一个整数 n 求从 1 到 n 这 n 个整数的十进制表示中 1 出现的次数。举例说明： 例如输入 12 ，从 1 到 12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。12 题33：12 题34：12 题35：12 题36：12 题37：12 题38：12 题39：12 题40：12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(21-30)]]></title>
    <url>%2F2017%2F07%2F03%2F%E5%89%91%E6%8C%87Offer(21-30)%2F</url>
    <content type="text"><![CDATA[题21：包含min函数的栈题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，push及pop的时间复杂度都是O(1). 12345678910111213141516171819202122232425262728293031323334public class Main&#123; private MyStack&lt;Integer&gt; minStack = new MyStack&lt;&gt;(); private MyStack&lt;Integer&gt; dataStack = new MyStack&lt;&gt;(); public void push(Integer item)&#123; dataStack.push(item); if(minStack.length == 0 || item&lt;=minStack.head.data)&#123; minStack.push(item); &#125;else&#123; minStack.push(minStack.head.data); &#125; &#125; public Integer pop()&#123; if(dataStack.length == 0 || minStack.length == 0)&#123; return null; &#125; minStack.pop(); return dataStack.pop(); &#125; public Integer min()&#123; if(minStack.length == 0)&#123; return null; &#125; return minStack.head.data; &#125; public static void main(String[] args)&#123; E21MinInStack test = new E21MinInStack(); test.push(3); test.push(2); test.push(1); System.out.println(test.pop()); System.out.println(test.min()); &#125;&#125; 题28：字符串的排列题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args)&#123; permutation(&quot;abc&quot;); &#125; public static void permutation(String str)&#123; int count=0; if(str==null)&#123; return; &#125; char [] chs=str.toCharArray();//将字符串转换为字符数组 int point=0; System.out.print(chs); System.out.print(&quot; &quot;); count++; char temp1=chs[point]; chs[point]=chs[++point]; chs[point]=temp1; while (!String.valueOf(chs).equals(str))&#123; System.out.print(chs); System.out.print(&quot; &quot;); count++; if(point==chs.length-1)&#123; char temp=chs[point]; chs[point]=chs[0]; chs[0]=temp; point=0; &#125;else &#123; char temp=chs[point]; chs[point]=chs[++point]; chs[point]=temp; &#125; &#125; System.out.println(count); &#125;&#125; 题29：数组中出现次数超过一半的数组题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出null。1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args)&#123; int [] array=&#123;1,2,3,2,2,2,5,4,2&#125;; System.out.println(morethanhalfnumber(array)); &#125; public static Integer morethanhalfnumber(int [] array)&#123; int count=1; int temp=array[0]; for(int i=1;i&lt;array.length;i++)&#123; if(temp==array[i])&#123; count++; &#125;else &#123; count--; if(count==0)&#123; temp=array[i]; count++; &#125; &#125; &#125; int count1=0; for(int i=0;i&lt;array.length;i++)&#123; if(array[i]==temp)&#123; count1++; &#125; &#125; return count1&gt;=array.length/2 ? temp:null; &#125;&#125; 题30：最小的k个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.TreeSet;public class Main &#123; public static void main(String[] args)&#123; int [] array=&#123;4,5,1,6,2,7,3,8&#125;; int k=4; System.out.println(MinKnumber(array,k)); &#125; public static ArrayList&lt;Integer&gt; MinKnumber(int [] array, int k)&#123; if(array==null) return null; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(k); if(k&gt;array.length) return list; TreeSet&lt;Integer&gt; tree=new TreeSet&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++)&#123; tree.add(array[i]); &#125; int i=0; for (Integer elem:tree)&#123; if(i&gt;k-1) break; list.add(elem); i++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode解题思路(二)]]></title>
    <url>%2F2017%2F06%2F28%2FLeetCode%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1Java代码实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(1-10)]]></title>
    <url>%2F2017%2F06%2F28%2F%E5%89%91%E6%8C%87Offer(1-10)%2F</url>
    <content type="text"><![CDATA[剑指Offer题目解析！ 题1：赋值运算符函数 题2：实现单例模式 题3：二维数组中的查找题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。1234567891011121314151617181920212223242526public class Main &#123; public static void main(String[] args) &#123; int arr[][] =&#123;&#123;1,3,5,7,9&#125;, &#123;2,4,6,8,10&#125;, &#123;3,5,7,9,12&#125;, &#123;5,7,9,10,15&#125;&#125;; int key=5; System.out.print(&quot;Key has in arr :&quot; + find(arr,key)); &#125; public static boolean find(int [][] array,int key)&#123; if(array==null) return false; int clo=array[0].length-1; int row=0; while (clo&gt;=0&amp;&amp;row&lt;array.length)&#123; if(array[row][clo]&gt;key)&#123; clo--; &#125;else if (array[row][clo]&lt;key)&#123; row++; &#125;else &#123; return true; &#125; &#125; return false; &#125; &#125; 题4：替换空格方法1：时间复杂度为 O(n) 的解法，思路是先数空格，再倒序插值!12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; String str= &quot;we are happy.&quot;; String res=ResplaceBlank(str); System.out.println(res); &#125; public static String ResplaceBlank(String str)&#123; if(str==null) return str; int len=str.length(); int k=0; for(int i=0;i&lt;len;i++)&#123; if(str.charAt(i)==&apos; &apos;) k++; &#125; char [] strnew = new char[len+k*3]; for(int i=len+k*2-1,j=len-1;i&gt;=0;i--,j--)&#123; if(str.charAt(j)!=&apos; &apos;)&#123; strnew[i]=str.charAt(j); &#125;else&#123; strnew[i--]=&apos;0&apos;; strnew[i--]=&apos;2&apos;; strnew[i]=&apos;%&apos;; &#125; &#125; return new String(strnew); &#125;&#125; 方法2：新数组，直接append123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; String str= &quot;we are happy.&quot;; String res=ResplaceBlank(str); System.out.println(res); &#125; public static String ResplaceBlank(String str)&#123; if(str==null) return str; StringBuilder outputbuffer=new StringBuilder(); for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)!=&apos; &apos;)&#123; outputbuffer.append(str.charAt(i)); &#125;else &#123; outputbuffer.append(&apos;%&apos;); outputbuffer.append(&apos;2&apos;); outputbuffer.append(&apos;0&apos;); &#125; &#125; return new String(outputbuffer); &#125;&#125; 题5：从尾到头打印链表学会Stack的使用，Stack是一种先进后出的数据结构，pop出和push存12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class Main &#123; public static void main(String[] args) &#123; ListNode node1=new ListNode(1); ListNode node2=new ListNode(2); ListNode node3=new ListNode(3); node1.next=node2; node2.next=node3; printReverseList(node1); &#125; public static class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val=val; this.next=null; &#125; &#125; public static void printReverseList(ListNode root)&#123; if(root==null ) return ; ListNode node=root; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); while(node!=null)&#123; stack.push(node); node=node.next; &#125; while(!stack.isEmpty())&#123; int val=stack.pop().val; System.out.print(val+&quot; &quot;); &#125; &#125;&#125; 递归实现方法：12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; ListNode node1=new ListNode(1); ListNode node2=new ListNode(2); ListNode node3=new ListNode(3); node1.next=node2; node2.next=node3; printReverseList(node1); &#125; public static class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val=val; this.next=null; &#125; &#125; public static void printReverseList(ListNode root)&#123; if(root!=null)&#123; if(root.next!=null)&#123; printReverseList(root.next); &#125; &#125; System.out.println(root.val); &#125;&#125; 题6：重建二叉树题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：前序遍历序列｛ 1, 2, 4, 7, 3, 5, 6, 8｝和中序遍历序列｛4, 7, 2, 1, 5, 3, 8,6}，重建出下图所示的二叉树并输出它的头结点。函数使用：Arrays.copyOfRange(preSort, 1, i + 1)12345678910111213141516171819202122232425262728293031323334import java.util.Arrays;class BinaryTreeNode&#123; public int value=0; public BinaryTreeNode leftNode; public BinaryTreeNode rightNode;&#125;public class Main &#123; public static void main(String[] args) throws Exception&#123; int[] preSort = &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] inSort = &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; BinaryTreeNode root = constructCore(preSort, inSort); System.out.print(root.value+&quot; &quot;+root.leftNode.value+&quot; &quot;+root.rightNode.value); &#125; public static BinaryTreeNode constructCore(int[] preSort, int[] inSort) throws Exception &#123; if(preSort==null||inSort==null)&#123; return null; &#125; if(preSort.length!=inSort.length)&#123; throw new Exception(&quot;长度不一样，非法的输入！&quot;); &#125; BinaryTreeNode root = new BinaryTreeNode(); for (int i = 0; i &lt; preSort.length; i++) &#123; if (preSort[0] == inSort[i]) &#123; root.value = preSort[0]; root.leftNode = constructCore(Arrays.copyOfRange(preSort, 1, i + 1), Arrays.copyOfRange(inSort, 0, i)); root.rightNode = constructCore(Arrays.copyOfRange(preSort, i + 1, preSort.length), Arrays.copyOfRange(inSort, i + 1, inSort.length)); &#125; &#125; return root; &#125;&#125; 题7：两个栈实现队列题目：用两个栈实现一个队列。队列的生命如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。123456789101112131415161718192021222324252627282930313233import java.util.Stack;public class Main&lt;T&gt; &#123; private Stack&lt;T&gt; stack1=new Stack&lt;T&gt;(); private Stack&lt;T&gt; stack2=new Stack&lt;T&gt;(); public void appendTail(T t)&#123; stack1.push(t); &#125; public T deleteHead() throws Exception&#123; if(stack2.isEmpty())&#123; if(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; if(stack2.isEmpty())&#123; throw new Exception(&quot;队列为空，不能删除！&quot;); &#125; return stack2.pop(); &#125; public static void main(String[] args) throws Exception&#123; Main&lt;String&gt; p7=new Main&lt;&gt;(); p7.appendTail(&quot;1&quot;); p7.appendTail(&quot;2&quot;); p7.appendTail(&quot;3&quot;); System.out.println(p7.stack1); //[1, 2, 3] p7.deleteHead(); System.out.println(p7.stack1); // [1, 2] System.out.println(p7.deleteHead()); // 2 System.out.println(p7.stack1); // [1] &#125;&#125; 题8：旋转数组的最小数字题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3 ,4,5, 1, 2 ｝为｛ 1,2,3, 4,5}的一个旋转，该数组的最小值为 1。12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; // int [] array=&#123;3 ,4,5, 1, 2 &#125;; int [] array=&#123;1 ,1,1, 2, 0 &#125;; // int [] array=&#123;1 ,1,1, 0, 1 &#125;; System.out.println(findMin(array)); &#125; public static Integer findMin(int [] arr)&#123; if(arr==null) return null; int start=0; int end=arr.length-1; while (start&lt;end)&#123; int mid=(start+end)/2; if(arr[mid]&gt;arr[end])&#123; start=mid+1; &#125;else if(arr[mid]&lt;arr[end])&#123; end=mid; &#125;else&#123; start++; end--; &#125; &#125; return arr[start]; &#125;&#125; 题9：斐波那契数列写一个函数，输入n，求斐波那契（Fibonacci) 数列的第n项12345678910111213141516171819202122232425262728import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); System.out.println(Fibonacci(n)); &#125; public static long Fibonacci(int n)&#123; long res=0; long numb1=0; long numb2=1; if(n==0)&#123; return numb1; &#125; if(n==1)&#123; return numb2; &#125; while(n!=1)&#123; res=numb1+numb2; numb1=numb2; numb2=res; n--; &#125; return res; &#125;&#125; 题10：二进制中1的个数请实现一个函数， 输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001 ，有2位是1. 因此如果输入9，该出2。 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); System.out.println(numberOf1(n)); } public static int numberOf1(int n){ int count=0; while (n!=0){ n=n&amp;(n-1); count++; } return count; } }]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法与数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode解题思路(一)]]></title>
    <url>%2F2017%2F06%2F26%2FLeetCode%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[做的一些题的解题思路 Product of Array Except Self除本身之外的数组之积Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].Solve it without division and in O(n).For example, given [1,2,3,4], return [24,12,8,6]. 解题思路：拆分法[A_234 , A_134 , A_124 , A_123 ]=[1 , A_1 , A_12 , A_123 ]*[A_234 , A_34 , A_4 , 1 ]12345678910111213141516171819202122232425262728293031323334/** * Created by Administrator on 2017/5/8. */public class LeetCode &#123; public static void main(String[] args) &#123; // int [] nums=&#123;5, 7, 1, 8,3, 10&#125;; //测试 int[] nums = &#123;1, 3, 5, 6&#125;; int k = 5; int [] res = productExceptSelf(nums); for (int i=0;i&lt;res.length;i++) &#123; System.out.print(res[i]+&quot; &quot;); &#125; &#125; public static int[] productExceptSelf(int[] nums) &#123; final int [] result = new int [nums.length]; final int [] right = new int [nums.length]; final int [] left = new int [nums.length]; left[0]=1; for(int i=1;i&lt;nums.length;i++)&#123; left[i]=left[i-1]*nums[i-1]; &#125; right[nums.length-1]=1; for(int i=nums.length-2;i&gt;=0;i--)&#123; right[i]=right[i+1]*nums[i+1]; &#125; for (int i=0;i&lt;nums.length;i++)&#123; result[i]=right[i]*left[i]; &#125; return result; &#125;&#125; Increasing Triplet SubsequenceGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should:Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Your algorithm should run in O(n) time complexity and O(1) space complexity. Examples:Given [1, 2, 3, 4, 5],return true. Given [5, 4, 3, 2, 1],return false.用整数最大值去比较，x1记录第一个数，x2记录第二大的数，当出现第三大的数，则return true。 12345678910111213public class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int x1=Integer.MAX_VALUE; int x2=Integer.MAX_VALUE; for(int x: nums)&#123; if(x&lt;=x1) x1=x; else if(x&lt;=x2) x2=x; else return true; &#125; return false; &#125;&#125; Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 维护一个HashMap,key为整数，value为下标，将数组中的元素不断添加到这个Hashmap中，遇到重复时，计算下标距离；用Integer.MAX_VALUE 设置为比较的初始值；学会用HashMap是非常关键的。 12345678910111213141516171819202122public class LeetCode &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 3, 5, 1,6&#125;; int k=3; System.out.print(containsNearbyDuplicate(nums,k)); &#125; public static boolean containsNearbyDuplicate(int[] nums, int k) &#123; final Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int min=Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; final int preIndex=map.get(nums[i]); final int gap = i-preIndex; min = Math.min(min,gap); &#125; map.put(nums[i],i); &#125; return min&lt;=k; &#125;&#125; Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8主要学习怎么创建链表，怎么定义链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class LeetCode &#123; public static void main(String[] args) &#123; int[] inputl1=new int[]&#123;2,4,3&#125;; int[] inputl2=new int[]&#123;5,6,4&#125;; ListNode l1=buildListNode(inputl1); ListNode l2=buildListNode(inputl2); ListNode listNode =addTwoNumbers(l1,l2); while(listNode!=null)&#123; System.out.println(&quot;val &quot;+listNode.val); listNode=listNode.next; &#125; &#125; //定义链表 public static class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val=val; this.next=null; &#125; &#125; //创建链表 private static ListNode buildListNode(int[] input)&#123; ListNode first = null,last = null,newNode; int num; if(input.length&gt;0)&#123; for(int i=0;i&lt;input.length;i++)&#123; newNode=new ListNode(input[i]); newNode.next=null; if(first==null)&#123; first=newNode; last=newNode; &#125; else&#123; last.next=newNode; last=newNode; &#125; &#125; &#125; return first; &#125; /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy =new ListNode(-1); int carry = 0; ListNode prev = dummy; for(ListNode pa=l1 , pb=l2 ; pa!=null || pb!=null ; pa=pa==null?null : pa.next, pb=pb==null ? null : pb.next, prev=prev.next)&#123; final int ai=pa==null?0:pa.val; final int bi=pb==null?0:pb.val; final int value=(ai+bi+carry)%10; carry=(ai+bi+carry)/10; prev.next=new ListNode (value); &#125; if(carry&gt;0) prev.next=new ListNode (carry); return dummy.next; &#125;&#125; Evaluate Reverse Polish Notation计算逆波兰表达式（又叫后缀表达式）的值 ‘’ 2 ‘’,’’ 1 ‘’,’’ + ‘’, ‘’3’’, ‘’ ‘’ –&gt;(2+1)3–&gt;9 用堆栈遇到运算符则把前面两个拿出来运算 1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; String []tokens=&#123;"2", "1", "+", "3", "*"&#125;; System.out.print(evalRPN(tokens)); &#125; public static int evalRPN(String [] tokens)&#123; Stack&lt;String&gt; s = new Stack&lt;&gt;(); if(tokens.length==1)&#123; return Integer.parseInt(tokens[0]); &#125; for(String token:tokens)&#123; if(!isOperator(token))&#123; s.push(token); &#125;else &#123; int y=Integer.parseInt(s.pop()); int x=Integer.parseInt(s.pop()); switch (token.charAt(0))&#123; case '+':x+=y;break; case '-':x-=y;break; case '*':x*=y;break; case '/':x/=y;break; &#125; s.push(String.valueOf(x)); &#125; &#125; return Integer.parseInt(s.peek()); &#125; private static boolean isOperator(final String op)&#123; return op.length() == 1 &amp;&amp; OPS.indexOf(op)!=-1; &#125; private static String OPS = new String("+-*/");&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Efounds笔试]]></title>
    <url>%2F2017%2F06%2F24%2FEfounds%E7%AC%94%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Efounds的笔试~ 1.比较两个浮点数大小123456789一般不会直接用“==”或者“!=”对两个浮点数进行比较。判断两个浮点数float a 与 float b 是否相等可以根据他们的差的绝对值是否大于0来进行判断。判断相等：if（Math.abs(a-b)&lt;=0）&#123;相等&#125;或者if（!Math.abs(a-b)&gt;0）&#123;相等&#125;判断不等：if（Math.abs(a-b)&gt;0）&#123;不相等&#125; 2，用最快排序找到无序的数组里第K大的数123456789101112131415161718192021222324252627282930313233343536373839public class AlgCode &#123; public static void main(String[] args) &#123; // int [] nums=&#123;5, 7, 1, 8,3, 10&#125;; //测试 int [] nums= &#123;3,1,4,7,5,8,0&#125;; int k=5; int res= findKth(nums,0,nums.length-1,k-1); System.out.print(&quot;The Kth is: &quot;+res); &#125; private static int findKth(int [] data ,int first , int last ,int k)&#123; int kth; if(first==last) kth=data[first]; else &#123; int pivot = data[first]; int splitPoint = partition(data, first, last); if (k &lt; splitPoint) kth = findKth(data, first, splitPoint - 1, k); else if(k&gt;splitPoint) kth = findKth(data, splitPoint + 1, last, k); else kth = pivot; &#125; return kth; &#125; private static int partition(int [] data ,int first , int last)&#123; int pivot = data[first]; while(first&lt;last) &#123; while (first &lt; last &amp;&amp; data[last] &gt; pivot) last--; data[first] = data[last]; while (first &lt; last &amp;&amp; data[first] &lt; pivot) first++; data[last] = data[first]; &#125; data[first]=pivot; return first; &#125; &#125; 3，单链表是否有环并如何找到环入口首先要了解什么叫环，如图，Join.next-&gt;Pos，Pos.next-&gt;Join，那么该链表有环 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class LinkedLoop&#123; //内部静态类定义结点类 static class Node&#123; int val; Node next; public Node(int val)&#123; this.val = val; &#125;&#125; //判断单链表是否有环 public static boolean hasLoop(Node head)&#123; Node p1=head; //指向头节点 Node p2=head.next; //指向下一个节点 while(p2!=null &amp;&amp;p2.next!=null)&#123; p1=p1.next; p2=p2.next.next; if(p2==null)&#123; return false; &#125; int val1=p1.val; int val2=p2.val; if(val1==val2) return true; &#125; return false;&#125; public static void main(String [] args)&#123; Node n1=new Node(1); Node n2=new Node(3); Node n3=new Node(6); Node n4=new Node(4); Node n5=new Node(5); Node n6=new Node(10); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; n5.next = n6; n6.next = n5; System.out.println(hasLoop(n1)); &#125;&#125; 4，快排第一次排列后的顺序1234int [] nums= &#123;3,1,4,7,5,8,0&#125;; 如果基准为3；第一次快排后:nums=&#123;0,1,3,7,5,8,4&#125;; 5，Java 数据输入1234int a =0;Scanner input = new Scanner(System.in);System.out.println(&quot;输入数字:&quot;);a = input.nextInt(); 6，软件生命周期 软件生命周期(SDLC，Systems Development Life Cycle,SDLC)是软件的产生直到报废或停止使用的生命周期。软件生存周期包括： 一，问题定义。要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。 二，可行性研究。一方面在于把待开发的系统的目标以明确的语言描述出来，另一方面从经济、技术、法律等多方面进行可行性分析。 三，需求分析。弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。 四，开发阶段。开发阶段由三个阶段组成：1，设计2，实现：根据选定的程序设计语言完成源程序的编码。3，测试 五，维护：维护包括四个方面1，改正性维护：在软件交付使用后，由于开发测试时的不彻底、不完全、必然会有一部分隐藏的错误被带到运行阶段，这些隐藏的错误在某些特定的使用环境下就会暴露。2，适应性维护：是为适应环境的变化而修改软件的活动。3，完善性维护 ：是根据用户在使用过程中提出的一些建设性意见而进行的维护活动。4，预防性维护：是为了进一步改善软件系统的可维护性和可靠性，并为以后的改进奠定基础。 7,多线程和多进程的区别a.进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。 b.进程有独立的地址空间，比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的，比如在windows中用_begin threadex创建一个新进程就会在调用CreateThread的同时申请一个专属于线程的数据块（_tiddata)。 c.线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。 d.由b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。 e.线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。 8,多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明 所谓同步，表示有先有后，比较正式的解释是“线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。” 所谓互斥，比较正式的说明是“线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。”表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。 举个例子，设有一个全局变量global，为了保证线程安全，我们规定只有当主线程修改了global之后下一个子线程才能访问global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问global的时候另一个线程不能访问global，那么就需要互斥。 9,网络协议：访问某个网址都经过了哪些协议·域名解析协议DNS应用层协议，网址相当于是域名，访问DNS服务器，这个过程有域名解析协议，解析出域名对应的IP地址。 ·超文本传输协议HTTP应用层协议，基于请求和响应的协议，通过请求行、消息报头、请求正文向目的地址发送请求。目的服务器在接受请求后，返回一个状态行、消息报头、响应正文的响应。 ·传输控制协议TCP传输层协议，HTTP协议是基于TCP协议的，也就是说HTTP无论是请求还是响应都是把HTTP的内容作为TCP的正文封装到TCP的报文中的。TCP协议是传输安全，面向连接的协议，在客户端和服务端建立TCP/IP五层模型的协议 连接的过程中需要经过三次握手，发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一端执行被动打开，以及四次释放的过程才停止发送数据。 ·网际协议IP协议IP协议在整个传输过程中都起着重要的作用，网址通过DNS解析为IP地址，在TCP建立连接以及传输数据的整个过程中都在使用着IP协议。]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之查找算法]]></title>
    <url>%2F2017%2F06%2F22%2FJava%E4%B9%8B%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用Java实现一些基本查找算法。 Search for a Range描述Given a sorted array of integers, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n) .If the target is not found in the array, return [-1, -1] .For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4] .分析已经排好了序，用二分查找。重新实现 lower_bound 和 upper_boundSearch for a Range1234567891011121314151617181920212223242526272829303132// Search for a Range// 重新实现 lower_bound 和 upper_bound// 时间复杂度O(logn)，空间复杂度O(1)public class Solution&#123; private static int[] searchRange(int [] nums,int target)&#123; int lower=lower_bound(nums,0,nums.length,target); int high=upper_bound(nums,0,nums.length,target); if(lower == nums.length || nums[lower]!=target) return new int[]&#123;-1,-1&#125;; else return new int[]&#123;lower,high-1&#125;; &#125; private static int lower_bound(int [] A , int first ,int last ,int target)&#123; while(first!=last)&#123; int mid=(first+last)/2; if(target&gt;A[mid]) first=++mid; else last=mid; &#125; return first; &#125; private static int upper_bound(int [] A , int first ,int last ,int target)&#123; while(first!=last)&#123; int mid=(first+last)/2; if(target&gt;=A[mid]) first=++mid; //找到最远边界 else last=mid; &#125; return first; &#125;&#125; Search Insert Position描述Given a sorted array and a target value, return the index if the target is found. If not, return the indexwhere it would be if it were inserted in order.You may assume no duplicates in the array.Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0分析即 std::lower_bound() 。1234567891011public static int searchInsert(int [] nums , int target)&#123; int first=0; int last=nums.length; while(first!=last)&#123; int mid=(first+last)/2; if(target&gt;nums[mid]) first=mid+1; else last=mid; &#125; return first; &#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现常见排序算法]]></title>
    <url>%2F2017%2F06%2F21%2FJava%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一些常见的排序算法实现！ ·查找算法典型的二分查找对于二分查找算法要求, 查找前的数据必须是已经排好序的, 然后得到数组的开始位置start和结束位置end, 取中间位置mid的数据a[mid]跟待查找数据key进行比较, 若 a[mid] &gt; key, 则取end = mid - 1; 若 a[mid] &lt; key, 则取start = mid + 1; 若 a[mid] = key 则直接返回当前mid为查找到的位置. 依次遍历直到找到数据或者最终没有该条数据. 12345678910111213141516public static int binarySearch(int [] nums , int key )&#123; int start =0; int end = nums.length-1; while(start&lt;end)&#123; int mid = (end+start)/2; if(nums[mid]&gt;key)&#123; end=mid-1; &#125;else if(nums[mid]&lt;key)&#123; start=mid+1; &#125;else&#123; return mid; &#125; &#125; return -1; &#125; ·插入排序插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入稳定，时间复杂度 O(n^2) 12345678910111213public static void insertSort(int [] a)&#123; for(int i=2 ; i&lt; a.length ;i++ )&#123; if(a[i]&lt;a[i-1])&#123; a[0]=a[i]; a[i]=a[i-1]; int j=0; for(j= i-2;a[j]&gt;a[0];j--)&#123; a[j+1]=a[j]; &#125; a[j+1]=a[0]; &#125; &#125;&#125; ·选择排序选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。 不稳定, 时间复杂度 O(n^2)123456789101112131415161718public static void selectSort(int [] a)&#123; for(int i=1 ; i&lt;a.length ;i++)&#123; int j=selectMinKey(a,i); if(i!=j)&#123; swap(a,i,j); &#125; &#125;&#125;private static int selectMinKey(int [] a, int i)&#123; int key=i; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[j]&lt;a[key])&#123; key=j; &#125; &#125; return key;&#125; ·冒泡排序冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。 稳定，时间复杂度 O(n^2)123456789public static void bubbleSort(int [] a)&#123; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=i;j&lt;a.length;j++)&#123; if(a[j+1]&lt;a[j])&#123; swap(a,j+1,j); &#125; &#125; &#125;&#125; ·快速排序不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n^2) 快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。 12345678910111213141516171819202122232425public static void quickSort(int [] a,int low ,int high)&#123; int pivotLoc=0;//中心点 if(low&lt;high)&#123; pivotLoc=partitionLoc(a,low,high); quickSort(a,low,pivotLoc-1); quickSort(a,pivotLoc+1,high); &#125;&#125;//获取到a的下标 low ~ high 中, a[low]的应该放的位置, 即左边的数 &lt; a[low] 右边的数 &gt; a[low]private static int partitionLoc(int [] a,int low ,int high)&#123; a[0]=a[low]; while(low&lt;high)&#123; while(low&lt;high &amp;&amp; a[high]&gt;a[0])&#123; high--; &#125; a[low]=a[high]; while( low &lt; high &amp;&amp; a[low]&lt;=a[0])&#123; low++; &#125; a[high] = a[low]; &#125; a[low]=a[0]; return low;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS Notes]]></title>
    <url>%2F2017%2F05%2F20%2FJS-Notes%2F</url>
    <content type="text"><![CDATA[项目需求，初学JS Notes。1.基础常用函数12alert(&quot;提示框&quot;);document.write(&quot;输出内容&quot;); 定义变量1var 变量名=值; 内置对象123456String 对象Number 对象Boolean 对象Math 对象Date 对象Array 对象 自定义对象12Java：用class 来定义对象JS：用 function 来定义对象]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码前沿发展]]></title>
    <url>%2F2017%2F04%2F26%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%89%8D%E6%B2%BF%E5%8F%91%E5%B1%95%2F</url>
    <content type="text"><![CDATA[二维码纠错、定位、去模糊都已经研究很透了，现在很多公司都在推自己的闭源码！Facebook正努力使之用户在Messenger上更容易互相联系，所以它推出了许多新方式来让用户聊天。Messenger用户现在已经有专门的个人链接（m.me/username），让对方可以访问并且开始聊天。Facebook也推出了所谓的Messenger Codes，这相当于Snapchat的Snapcodes。 现在从安全性考虑，大家都在做自己的闭源码！]]></content>
      <categories>
        <category>二维码</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法总结]]></title>
    <url>%2F2017%2F04%2F24%2F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些常用算法分类总结1.字符串123456789101112131415161718192021222324252627282930·字符串(String) 通常把它作为字符数组 java : String内置类型，不可更改，要更改的话可考虑转StringBuffer, StringBuilder, char []之类 Java: ［0..65535]·和数组相关，内容广泛 概念理解：字典序 简单操作：插入、删除字符，旋转 规则判断 （罗马数字转换 是否是合法的整数、浮点数） 数字运算（ 大数加法、二进制加法） 排序、交换 （partition过程） 字符计数（hash)：变位词 匹配 （正则表达式、全串匹配、KMP、周期判断） 动态规划 (LCS、编辑距离、最长回文子串） 搜索 （单词变换、排列组合）总结：·我理解的in-place (原地） 本身O(1)空间 递归，堆栈空间可以不考虑·原地相关的问题 字符串循环左移、右移动 快排partition相关·滑动窗口 能达到O(n)的的时间复杂度 O(1)的空间复杂度·规则相关——细致·匹配 （暴力）：KMP比较少见·Manacher——要求比较高的笔试 2.数组12345678910111213141516171819202122232425262728293031·数组(array) java : [], ArrayList 数组下标是一种特殊的hash…做计数 理解数组与map 给数组“顺序”·查找和排序 二分查找 元素交换 排序，中位数 归并 位运算 前缀和的应用·动态规划·排列组合总结：·利用序 理解二分查找·利用前缀和 查找、计算、排序·理解数组 map·用数组实现高级数据结构 一般树： 存每个节点的父亲 （并查集） 二叉树： 下标从1开始a[i]的儿子是a[i * 2]和a[i * 2 + 1] (堆）·抓住简单题 分治法求逆序对数 有序数组归并 两个有序数组的中位数 两头扫的方法 （2-SUM, 3-SUM) 3.栈和队列简介： 堆栈和队列统称线性表 简单的线性结构 数组和链表可以实现这两种数据结构 堆栈 后进先出 (Last In First Out) 队列 先进先出 (First In First Out) 面试题总体分析： 堆栈 基本理解 DFS 深度优先——按深度遍历 递归转非递归 队列 基本理解 BFS 广度优先——按层序遍历]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上交会防伪展总结]]></title>
    <url>%2F2017%2F04%2F24%2F%E4%B8%8A%E4%BA%A4%E4%BC%9A%E9%98%B2%E4%BC%AA%E5%B1%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[防伪，是企业在目前社会诚信缺失、假冒伪劣商品扰乱企业正常经营和损害企业、消费者利益的情况下，为保护企业品牌、保护市场、保护广大消费者合法权益而采取的一种防范性技术措施。 这次博览会主要学习到了几类防伪技术： 激光防伪材料用特殊材料做成全息图案，达到人眼辨别真假的目的，如恒大冰泉的瓶盖贴标；缺点：全息材料防伪技术发展很成熟，防伪材料容易被仿制。 纸张防伪纸张防伪技术主要用于纸币、贵重物品包装防伪。该防伪技术关键在于复制印刷版的难度大。该技术首先需要根据需求图案刻板，然后印刷出有图案的纸张，用该纸张印刷纸币或者用该纸张包装商品，以达到防伪目的，难点在于，如果没有源板，无法印刷出相同图案的纸张，如果按照纸张图案仿制印刷板，难度很大。 三阖追溯提出该方案的公司为珠海三纬码信息技术有限公司，该技术主要服务对象为中高端产品，流程如下：1）首先生产厂家对每一个产品提供一个编号和密码，编号存入二维码中，密码存入系统数据库中。然后物流信息根据扫描二维码得到商品编号存入数据库中。2）当商品到达专卖店时，专卖店扫描二维码入库，可以从系统得到编号以及密码；3）当客户去专卖店买该商品时，专卖店根据系统查询编号，给客户密码，客户可根据二维码中的编号和密码去官网查询，如果编号和密码正确，则显示该商品所有信息，信息包括商品信息、商品状态及溯源信息；4）当专卖店出售该商品时，扫描二维码会传递信息回到系统，将商品状态：待售改为售出！故该商品无法再二次销售，避免了掉包商品二次销售的风险！ 公众号扫描防伪用公司公众号扫描商品二维码，进入页面溯源，优点是公司公众号是唯一的，从公众号进入，避免了进入假页面的风险！该方案是为了解决一般溯源扫描二维码进入假页面，欺骗消费者的风险！]]></content>
      <categories>
        <category>防伪</category>
      </categories>
      <tags>
        <tag>二维码防伪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2017%2F04%2F13%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表基础总结。 1.遍历123for(Node x=first ; x!=null ; x=x.next)&#123; //处理x.item&#125; 2.定义链表1234567private class Data&#123; private object obj; private Data next=null; Data(Object obj)&#123; this.obj=obj; &#125; &#125; 3.首节点为空1private Data first=null; 4.insertFirst ： 在表头插入一个新的链接点，时间复杂度为O(1)12345public void insertFirst(Object obj)&#123; Data data=new Data(obj); data.next=first; first=data; &#125; 5.deleteFirst :删除表头首节点，时间复杂度为O(1)12345678public Object deleteFirst() throws Exception&#123; if(first==null)&#123; throw new Exception(&quot;empty!&quot;); &#125; Data temp=first; first=first.next; return temp.obj; &#125; 6.find: 查找包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N)12345678910111213public Object find (Object obj) throws Exception&#123; if(first ==null)&#123; throw new Exception(&quot;LinkedList is empty!&quot;); &#125; Data cur=first; while (cur!=null)&#123; if(cur.obj.equals(obj))&#123; return cur.obj; &#125; cur=cur.next; &#125; return null; &#125; 7.remove ：删除包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N)1234567891011121314151617public void remove(Object obj) throws Exception&#123; if(first == null) throw new Exception(&quot;LinkedList is empty!&quot;); if(first.obj.equals(obj))&#123; first=first.next; &#125;else&#123; Data pre = first; Data cur = first.next; while(cur!=null)&#123; if(cur.obj.equals(obj))&#123; pre.next=cur.next; &#125; pre=cur; cur=cur.next; &#125; &#125; &#125; 8.isEmpt123public boolean isEmpty()&#123; return (first==null);&#125; 9.打印链表12345678910public void display()&#123; if(first==null) System.out.println(&quot;empty&quot;); Data cur=first; while(cur!=null)&#123; System.out.print(cur.obj.toString()+&quot;-&gt;&quot;); cur=cur.next; &#125; System.out.print(&quot;\n&quot;); &#125; 10.删除指定节点123456public void deleteNode(ListNode node) &#123; if(node!=null&amp;&amp;node.next!=null)&#123; node.val=node.next.val; node.next=node.next.next; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2017%2F04%2F05%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java笔记 动态数组123456ArrayList&lt;String&gt; List = new ArrayList&lt;String&gt;(); //定义动态数组List.add(temp); //添加字符串List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;();ret.add(i+1); 分割字符串单词123456789101112String.Trim 方法·Trim() 从当前 String 对象移除所有前导空白字符和尾部空白字符。java.lang.string.split split 方法 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。String[] res = s.trim().split(&quot;\\s+&quot;); 将头尾空格去掉，并且切割成单词sb.append(res[i]).append(&quot; &quot;); //每次添加 单词+“ ” 组合return sb.toString().trim(); //将字符串头尾空格去掉 数字转化成字母，存在字符串中1arr.insert(0,(char)(&apos;A&apos;+n%26)); 进制转换函数123456789101112十进制转成十六进制： Integer.toHexString(int i) 十进制转成八进制 Integer.toOctalString(int i) 十进制转成二进制 Integer.toBinaryString(int i) 十六进制转成十进制 Integer.valueOf(&quot;FFFF&quot;,16).toString() 八进制转成十进制 Integer.valueOf(&quot;876&quot;,8).toString() 二进制转十进制 Integer.valueOf(&quot;0101&quot;,2).toString() 数组·整数转为二进制 Integer.toBinaryString(i)； 数组排序· Arrays.sort(nums); Set：Set s=new HashSet(); contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。 add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。 remove如果指定元素存在于此 set 中，则将其移除。 clear从此 set 中移除所有元素。 Java.lang.Character.getNumericValue()方法12345·java.lang.Character.getNumericValue(char ch) 返回指定Unicode字符表示的int值。例如，字符&apos;\ u216C&apos;（罗马数字50）将返回一个int值50。·字母的大写的AZ（&apos;\ u0041&apos;到&apos;\ u005A&apos;），小写字母（&apos;\ u0061&apos;到&apos;\ u007A&apos;），全宽度变体（&apos;\ uFF21“的通过&apos;\ uFF3A&apos;和&apos;\ uFF41”通过&apos;\ uFF5A&apos;）的形式从10到35的数值。这是独立的Unicode规范，这些字符的值不分配数值。·如果该字符没有一个数字值，则返回-1。如果字符具有一个数字值，该值不能被表示为一个非负整数（例如，一个分数值），则返回-2。 基础123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class Main&#123; public static void print(int index ,Object obj)&#123; System.out.println(String.format(&quot;&#123;%d&#125;,%s&quot;,index,obj.toString())); &#125; public static void main(String[] args)&#123; //demoString(); demoList(); &#125; public static void demoList()&#123; List&lt;String&gt; strList=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;4;i++)&#123; strList.add(String.valueOf(i)); &#125; print(1,strList); List&lt;String&gt; strListB=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;4;i++)&#123; strListB.add(String.valueOf(i*i)); &#125; strList.addAll(strListB); print(2,strList); strList.remove(0); print(3,strList); strList.remove(String.valueOf(1)); print(4,strList); print(5,strList.get(1)); Collections.sort(strList); print(6,strList); Collections.sort(strList, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125; &#125;); print(7,strList); &#125; /* &#123;1&#125;,[0, 1, 2, 3]&#123;2&#125;,[0, 1, 2, 3, 0, 1, 4, 9]&#123;3&#125;,[1, 2, 3, 0, 1, 4, 9]&#123;4&#125;,[2, 3, 0, 1, 4, 9]&#123;5&#125;,3&#123;6&#125;,[0, 1, 2, 3, 4, 9]&#123;7&#125;,[9, 4, 3, 2, 1, 0] */ public static void demoString()&#123; String str=&quot;Hello nowcoder&quot;; print(1,&quot;Hello!&quot;); print(2,str.charAt(6)); print(3,str.codePointAt(1)); print(4,str.compareTo(&quot;Hello mewcoder&quot;)); print(5,str.compareTo(&quot;Hello pewcoder&quot;)); print(6,str.contains(&quot;Hello&quot;)); print(7,str.indexOf(&apos;e&apos;)); print(8,str.compareToIgnoreCase(&quot;Hello Nowcoder&quot;)); print(9,str.concat(&quot;!!&quot;)); print(10,str.endsWith(&quot;nowcoder&quot;)); print(11,str.startsWith(&quot;Hello&quot;)); print(12,str.lastIndexOf(&apos;o&apos;)); print(13,str.toUpperCase()); print(14,str.replace(&apos;o&apos;,&apos;a&apos;)); print(15,str.replaceAll(&quot;o|l&quot;,&quot;a&quot;)); print(16,str.replaceAll(&quot;Hello&quot;,&quot;hi&quot;)); StringBuilder sb =new StringBuilder(); sb.append(true); sb.append(1); sb.append(2.2); print(17,sb.toString()); print(18,&quot;a&quot;+&quot;b&quot;+String.valueOf(12)); &#125; /*&#123;1&#125;,Hello!&#123;2&#125;,n&#123;3&#125;,101&#123;4&#125;,1&#123;5&#125;,-2&#123;6&#125;,true&#123;7&#125;,1&#123;8&#125;,0&#123;9&#125;,Hello nowcoder!!&#123;10&#125;,true&#123;11&#125;,true&#123;12&#125;,10&#123;13&#125;,HELLO NOWCODER&#123;14&#125;,Hella nawcader&#123;15&#125;,Heaaa nawcader&#123;16&#125;,hi nowcoder&#123;17&#125;,true12.2&#123;18&#125;,ab12*/&#125; 数组随机打乱12List&lt;Integer&gt; array = Arrays.asList(new Integer[]&#123;1,2,3,4,5&#125;);Collections.shuffle(array);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms code]]></title>
    <url>%2F2017%2F04%2F03%2FAlgorithms-code%2F</url>
    <content type="text"><![CDATA[一些值得回看的小算法。 最长的连续子数组子数组数字不重复 12int [] arr=&#123;1,2,3,4,7&#125;; //输出4int [] arr1=&#123;1,2,3,4,1,2,3,4,5,1&#125;; //输出5 12345678910111213141516171819202122232425262728293031323334package RecursiveAndDynamic;/** * Created by zdmein on 2017/9/2. * 最长的连续子数组（子数组数字不重复） * int [] arr=&#123;1,2,3,4,7&#125;; 输出4 * int [] arr1=&#123;1,2,3,4,1,2,3,4,5,1&#125;; 输出5 */public class longestSubArr1 &#123; public static void main(String [] args)&#123; int [] arr=&#123;1,2,3,4,7&#125;; int [] arr1=&#123;1,2,3,4,1,2,3,4,5,1&#125;; longestSubArr(arr1); &#125; public static void longestSubArr(int [] arr)&#123; if(arr==null||arr.length==0)&#123; return; &#125; int len=1; int maxlen=1; for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]==arr[i-1]+1)&#123; len++; maxlen=Math.max(len,maxlen); &#125;else &#123; len=1; &#125; &#125; System.out.println(maxlen); &#125;&#125; 删除链表中的元素样例给出链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3, 和 val = 3, 你需要返回删除3之后的链表：1-&gt;2-&gt;4-&gt;5。 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) &#123; // Write your code here if(head==null) return head; ListNode p=head,q=head.next; while(q!=null)&#123; if(q.val==val)&#123; p.next=q.next; q=q.next; &#125;else&#123; p=p.next; q=q.next; &#125; &#125; if(head.val==val) head=head.next; return head; &#125;&#125; 求n的阶乘结果后有几个零123456789101112//结果后的零是由n中的5组成的，多少个5就有多少个0，所以只需要统计有多少5就可以了public class Solution &#123; public int trailingZeroes(int n) &#123; int rs=0; while(n!=0)&#123; rs+=n/5; n/=5; &#125; return rs; &#125;&#125; 统计小于n的素数个数我写的用 n/2;改进为 Math.sqrt(n)；复杂度还是高了点；123456789101112131415public class Solution &#123; public int countPrimes(int n) &#123; boolean [] notPrimes = new boolean[n]; int count =0; for(int i=2;i&lt;n;i++)&#123; if(notPrimes[i]==false)&#123; count++; for(int j=2;i*j&lt;n;j++)&#123; notPrimes[i*j]=true; &#125; &#125; &#125; return count; &#125;&#125; 这个算法降低了复杂度，值得学习！！ 同构字符串Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true.即结构相同我的123456789101112131415161718192021public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; int [] count=new int [s.length()]; for(int i=0;i&lt;s.length();i++)&#123; count[i]=s.charAt(i)-t.charAt(i); for(int j=0;j&lt;i;j++)&#123; if(s.charAt(i)==s.charAt(j))&#123; if(count[i]!=count[j])&#123; return false; &#125; &#125; if(t.charAt(i)==t.charAt(j))&#123; if(count[i]!=count[j])&#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 降低复杂度,用数组装字符，很重要的思想！1234567891011121314public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; int [] m=new int [256]; int [] n=new int [256]; for(int i=0;i&lt;s.length();i++)&#123; if(m[s.charAt(i)]!=n[t.charAt(i)])&#123; return false; &#125; m[s.charAt(i)]=i+1; //关键部分，通过i，实现错位 n[t.charAt(i)]=i+1; //不同位置加的值不同 &#125; return true; &#125;&#125; 组合成最大的数given [3, 30, 34, 5, 9], the largest formed number is 9534330.[0,0]，输出0.1234567891011121314151617181920212223242526public class Solution &#123; public String largestNumber(int[] nums) &#123; String [] rs=new String[nums.length]; String sb=new String(); for(int i=0;i&lt;nums.length;i++)&#123; rs[i]=String.valueOf(nums[i]); &#125; for(int j=0;j&lt;nums.length-1;j++)&#123; for(int i=0;i&lt;nums.length-j-1;i++)&#123; String s1=rs[i]+rs[i+1]; String s2=rs[i+1]+rs[i]; if(s2.compareTo(s1)&gt;0)&#123; String temp=rs[i]; rs[i]=rs[i+1]; rs[i+1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;nums.length;i++)&#123; sb+=rs[i]; &#125; if(sb.charAt(0) == &apos;0&apos;) return &quot;0&quot;; return sb; &#125;&#125; 判断n是不是2的幂只需要将n转化为二进制，然后计算二进制位里面有多少个1，如果计数为1，那么n是2的幂 快乐数写一个算法来判断一个数是不是”快乐数”。 一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。 您在真实的面试中是否遇到过这个题？ Yes样例19 就是一个快乐数。 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 123456789101112131415161718192021222324252627public class Solution &#123; /** * @param n an integer * @return true if this is a happy number or false */ public boolean isHappy(int n) &#123; // Write your code here Set&lt;Integer&gt; inLoop = new HashSet&lt;Integer&gt;(); int squareSum,remain; while (inLoop.add(n)) &#123; squareSum = 0; while (n &gt; 0) &#123; remain = n%10; squareSum += remain*remain; n /= 10; &#125; if (squareSum == 1) return true; else n = squareSum; &#125; return false; &#125;&#125; Add BinaryGiven two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”.123456789101112131415161718192021222324252627282930313233package leetCode;public class Temp&#123; public static void main(String [] args) &#123; String a=&quot;11&quot;; String b=&quot;1&quot;; System.out.print(addBinary(a,b)); &#125; public static String addBinary(String a, String b) &#123; if(a == null || a.isEmpty()) return b; if(b == null || b.isEmpty()) return a; StringBuilder stb = new StringBuilder(); int i = a.length() - 1; int j = b.length() - 1; int aBit; int bBit; int carry = 0; int result; while(i &gt;= 0 || j &gt;= 0 || carry == 1) &#123; aBit = (i &gt;= 0) ? Character.getNumericValue(a.charAt(i--)) : 0; bBit = (j &gt;= 0) ? Character.getNumericValue(b.charAt(j--)) : 0; result = aBit ^ bBit ^ carry; carry = ((aBit + bBit + carry) &gt;= 2) ? 1 : 0; stb.append(result); &#125; return stb.reverse().toString(); &#125;&#125; 徒手开平方·牛顿法-直线逼近原理1234567891011121314151617181920package leetCode;public class Temp&#123; public static void main(String [] args) &#123; int a=7; System.out.print(mySqrt(a)); &#125; public static int mySqrt(int x) &#123; long rs=x; while(rs*rs&gt;x)&#123; rs=(rs+x/rs)/2; &#125; return (int)rs; &#125;&#125;# 数学之美 —— 0x5f375a86 float InvSqrt(float x){ float xhalf = 0.5fx; int i = (int)&x; // get bits for floating VALUE i = 0x5f375a86- (i&gt;&gt;1); // gives initial guess y0 x = (float)&i; // convert bits BACK to float x = x(1.5f-xhalfxx); // Newton step, repeating increases accuracy return x;}12345678910# 两数字字符串相加Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.Note:The length of both num1 and num2 is &lt; 5100.Both num1 and num2 contains only digits 0-9.Both num1 and num2 does not contain any leading zero.You must not use any built-in BigInteger library or convert the inputs to integer directly. package leetCode; public class Temp{ public static void main(String [] args) { String a=”1001”; String b=”1341”; System.out.print(addStrings(a,b)); } public static String addStrings(String num1, String num2) { StringBuilder sb=new StringBuilder(); int carry=0; for(int i=num1.length()-1,j=num2.length()-1;i&gt;=0||j&gt;=0||carry==1;i--,j--){ int x=i&lt;0?0:num1.charAt(i)-&apos;0&apos;; int y=j&lt;0?0:num2.charAt(j)-&apos;0&apos;; sb.append((x+y+carry)%10); carry=(x+y+carry)/10; } return sb.reverse().toString(); } }123# 字符串中出现多少字母存一下有多少个非0次出现的 int nonZero = 0; for (int i = 0; i &lt; lenb; ++i) if (++num[b[i] – ‘a’] == 1) ++nonZero;123``12.单词翻转`` 翻转句子中全部的单词，单词内容不变例如I’m a student. 变为student. a I’m in-place翻转 字符串第i位到第j位while (i &lt; j) swap(s[i++], s[j–]);有什么用？翻转整个句子 ： .tneduts a m’I每个单词单独翻转： student. a I’m难点？ 如何区分单词？找空格，split1# HashSet public static int[] intersection(int[] nums1, int [] nums2){ Set set= new HashSet&lt;&gt;(); Set interset=new HashSet&lt;&gt;(); for(int i=0;i&lt;nums1.length;i++){ set.add(nums1[i]); //存入不重复的值 } for(int i=0;i&lt;nums2.length;i++){ if(set.contains(nums2[i])){ //如果重复上个set数组里的值 interset.add(nums2[i]); //添加上个数组里有的值 } } int [] res=new int [interset.size()]; int i=0; for(Integer num:interset){ res[i++]=num; } return res; } }123456789101112# 350. Intersection of Two Arrays IIGiven two arrays, write a function to compute their intersection.Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.先排序，一个一个对比，相等的才存，不等就小的数组指针加1。 public static int[] intersection(int[] nums1, int [] nums2){ Arrays.sort(nums1); Arrays.sort(nums2); int p1=0; int p2=0; ArrayList myList= new ArrayList (); while((p1&lt;nums1.length)&amp;&amp;(p2&lt;nums2.length)){ if(nums1[p1]&lt;nums2[p2]){ p1++; }else{ if(nums1[p1]&gt;nums2[p2]){ p2++; }else{ myList.add(nums1[p1]); p1++; p2++; } } } int[] res= new int [myList.size()]; for(int i=0;i&lt;res.length;i++){ res[i]=myList.get(i); //ArrayList取值方法 } return res; //转化成正常数组输出 }1# 将字符数组转化为字符串 public static String reverseString(String s) { char [] rs= new char[s.length()]; for(int i=0;i&lt;s.length();i++){ rs[i]=s.charAt(i); } for(int i=0;i&lt;s.length()/2;i++){ char temp=rs[i]; rs[i]=rs[s.length()-i-1]; rs[s.length()-i-1]=temp; } return new String(rs); //转化 }12# 不用加号实现两数相加 public int getSum(int a, int b) { return b == 0 ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);} 合并排序数组合并两个排序的整数数组A和B变成一个新的数组。 给出A=[1,2,3,4]，B=[2,4,5,6]，返回 [1,2,2,3,4,4,5,6] 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /* * @param A: sorted integer array A * @param B: sorted integer array B * @return: A new sorted integer array */ public int[] mergeSortedArray(int[] A, int[] B) &#123; // write your code here int indexA=0; int indexB=0; int []C =new int [A.length+B.length]; int indexC=0; while(indexA!=A.length &amp;&amp; indexB!=B.length) &#123; if (A[indexA] &lt; B[indexB]) &#123; C[indexC++]=A[indexA++]; &#125;else if (A[indexA] &gt; B[indexB]) &#123; C[indexC++]=B[indexB++]; &#125;else &#123; C[indexC++]=A[indexA++]; C[indexC++]=B[indexB++]; &#125; &#125; if(indexA==A.length &amp;&amp; indexB!=B.length)&#123; for(int i=indexB;i&lt;B.length;i++)&#123; C[indexC++]=B[i]; &#125; &#125; if(indexA!=A.length &amp;&amp; indexB==B.length)&#123; for(int i=indexA;i&lt;A.length;i++)&#123; C[indexC++]=A[i]; &#125; &#125; return C; &#125;&#125; 写代码：多线程实现从A,B,C三个文件中读取文件放到D文件中，优化：如何同步实现。 写一个单例模式，什么时候用到在某些情况下，有些对象只需要一个就可以了，即每个类只需要一个实例。单例模式的作用就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。实现一个单例模式： 1234567public class Test&#123; private Test()&#123;&#125; private static Test uniqueInstance = new Test(); public static Test getInstence()&#123; return uniqueInstance; &#125;&#125; 由于在使用前就创建好了对象，因此，可以在多线程环境下使用这种方法。 装饰者模式是什么，举例装饰者模式通过组合的方式扩展对象的特性，这种方式允许我们在任何时候对对象的功能进行扩展，甚至是运行时扩展，而若我们用继承来完成对类的扩展，则只能在编译阶段实现，所以在某些时候装饰者模式比继承更灵活。 特征： 装饰者和被装饰者的对象有着共同的超类 我们可以用多个装饰者修饰一个对象 可以用修饰过的对象替代代码中的原对象 一个对象在任何时候都可以被装饰，甚至是运行时 应用场景：一家奶茶店，一杯奶茶是10元；如果加糖+2、加奶+3、加葡萄+5元…如果写类去继承，会要写n多个如果用装饰就直接在类里加价钱 123456789101112return mTea.getPrice()+2;return mTea.getPrice()+15;return mTea.getPrice()+20;-----mTea = new SimpleTea();mTea = new SugarDecorator(mTea);mTea = new MilkDecorator(mTea);int price1 = mTea.getPrice();System.out.println("price1="+price1); 写代码：找出字符数组中第一次只出现三次的字符1234567891011121314151617181920212223242526272829303132333435package Array;/** * Created by zdmein on 2017/9/6. * 找出字符数组中第一次只出现三次的字符 思路： 1、统计各字符出现次数 2、遍历字符串，如果出现字符次数为3则输出该字符并跳出循环；否则如果不存在则输出" . " */public class ThreeChar1 &#123; public static void main(String [] args)&#123; String str="abesabjdwsjibuhfrsadfesdsferewh"; char [] chars=str.toCharArray(); ThreeChar(chars); &#125; public static void ThreeChar(char [] chars)&#123; if(chars==null||chars.length==0)&#123; System.out.println("."); &#125; int [] res=new int[256]; for(int i=0;i&lt;chars.length;i++)&#123; res[chars[i]]++; &#125; for(int i=0;i&lt;chars.length;i++)&#123; if(res[chars[i]]==3)&#123; System.out.println(chars[i]); break; &#125; &#125; &#125;&#125; 验证身份证是否正确12345678910111213141516171819202122身份证号码验证 1、号码的结构 公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码， 八位数字出生日期码，三位数字顺序码和一位数字校验码。 2、地址码(前六位数） 表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按GB/T2260的规定执行。 3、出生日期码（第七位至十四位） 表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。 4、顺序码（第十五位至十七位） 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号， 顺序码的奇数分配给男性，偶数分配给女性。 5、校验码（第十八位数） （1）十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 （2）计算模 Y = mod(S, 11) （3）通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 功能：身份证的有效验证 网易笔试：一个合法的括号匹配 给一个合法的括号匹配序列s，找到同样长的所有的括号匹配序列t， 1.t和s不同，但是长度相同 2.t也合法 3.LCS（s,t） 是满足上面两个条件的t中最大的。 eg: s=”(())()” 匹配的有： “()(())”、”((()))”、”()()()”、”(()())” 其中 LCS（”(())()”,”()(())”）为4，其余都是5，所以输出3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package ProgrammingWritten;import java.util.ArrayList;import java.util.HashMap;import java.util.Map.Entry;import java.util.Scanner;/** * Created by zdmein on 2017/9/10. */public class NetEase1 &#123; public static int cnt; public static HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); public static void main(String[] args) &#123; HashMap&lt;Integer,Integer&gt; map2 = new HashMap&lt;&gt;(); Scanner input = new Scanner(System.in); String str1 = input.nextLine(); // int n = Integer.parseInt(str); int n2 = str1.length(); int n = (int) n2 / 2; // StringBuffer bf = new StringBuffer(""); // String str1 = bf.append(str).reverse().toString(); // n += Integer.parseInt(str1); // System.out.println(n); ArrayList&lt;String&gt; list = getBracketsOfN(n); for (String str2 : list) &#123; if (str1.equals(str2)) &#123; continue; &#125;else &#123; int[][] re = longestCommonSubsequence(str1, str2); cnt=0; print(re, str1, str2, str1.length(), str2.length()); map.put(str2, cnt); &#125; &#125; for (Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; if (map2.containsKey(entry.getValue())) &#123; int count=map2.get(entry.getValue()); map2.put(entry.getValue(), ++count); &#125; else &#123; map2.put(entry.getValue(), 1); &#125; &#125; int result = 0; int max= 0; for(Entry&lt;Integer, Integer&gt; entry : map2.entrySet()) &#123; if (max&lt;entry.getKey()) &#123; result = entry.getValue(); &#125; &#125; System.out.println(result); &#125; /** * Given the number N, return all of the correct brackets. * * @param n * @return */ @SuppressWarnings("unchecked") public static ArrayList&lt;String&gt; getBracketsOfN(int n) &#123; @SuppressWarnings("rawtypes") ArrayList[] dp = new ArrayList[n + 1]; for (int i = 0; i &lt; dp.length; i++) dp[i] = new ArrayList&lt;String&gt;(); dp[0].add(""); dp[1].add("()"); if (n == 0) return dp[0]; if (n == 1) return dp[1]; int count = 2; while (count &lt; n + 1) &#123; ArrayList&lt;String&gt; lcount = dp[count]; for (int i = 0; i &lt; count; i++) &#123; ArrayList&lt;String&gt; l1 = dp[i]; ArrayList&lt;String&gt; l2 = dp[count - i - 1]; for (int j = 0; j &lt; l1.size(); j++) &#123; for (int k = 0; k &lt; l2.size(); k++) &#123; StringBuffer sb = new StringBuffer(); sb.append(l1.get(j)); sb.append("("); sb.append(l2.get(k)); sb.append(")"); lcount.add(sb.toString()); &#125; &#125; &#125; dp[count++] = lcount; &#125; return dp[n]; &#125; // 假如返回两个字符串的最长公共子序列的长度 public static int[][] longestCommonSubsequence(String str1, String str2) &#123; int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵 // 初始化边界条件 for (int i = 0; i &lt;= str1.length(); i++) &#123; matrix[i][0] = 0;//每行第一列置零 &#125; for (int j = 0; j &lt;= str2.length(); j++) &#123; matrix[0][j] = 0;//每列第一行置零 &#125; // 填充矩阵 for (int i = 1; i &lt;= str1.length(); i++) &#123; for (int j = 1; j &lt;= str2.length(); j++) &#123; if (str1.charAt(i - 1) == str2.charAt(j - 1)) &#123; matrix[i][j] = matrix[i - 1][j - 1] + 1; &#125; else &#123; matrix[i][j] = (matrix[i - 1][j] &gt;= matrix[i][j - 1] ? matrix[i - 1][j] : matrix[i][j - 1]); &#125; &#125; &#125; return matrix; &#125; //根据矩阵输出LCS public static void print(int[][] opt, String X, String Y, int i, int j) &#123; if (i == 0 || j == 0) &#123; return; &#125; if (X.charAt(i - 1) == Y.charAt(j - 1)) &#123; print(opt, X, Y, i - 1, j - 1); cnt++;// System.out.print(X.charAt(i - 1)); &#125; else if (opt[i - 1][j] &gt;= opt[i][j]) &#123; print(opt, X, Y, i - 1, j); &#125; else &#123; print(opt, X, Y, i, j - 1); &#125; &#125; &#125; 滴滴笔试：求解第n个丑数我们把只包含因子2,3和5的数称为丑数（Ugly Number),求从小到大的顺序第n的丑数，例如6,8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第1个丑数 12345678910111213141516171819202122232425262728293031323334353637383940414243package ProgrammingWritten;import java.util.Scanner;/** * Created by zdmein on 2017/9/10. */public class didi2 &#123; public static void main(String args[]) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(); System.out.println(getugly(n)); &#125; public static int getugly(int n) &#123; if(n==0) return 0; int[] a = new int[n]; int count = 1; a[0] = 1; int num2 = 0; int num3 = 0; int num5 = 0; while(count&lt;n)&#123; int min = min(a[num2]*2,a[num3]*3,a[num5]*5); a[count] = min; while(a[num2]*2&lt;=a[count]) num2++; while(a[num3]*3&lt;=a[count]) num3++; while(a[num5]*5&lt;=a[count]) num5++; count++; &#125; int result = a[n-1]; return result; &#125; public static int min(int a,int b,int c)&#123; int tmp = a&gt;b?b:a; return tmp&gt;c?c:tmp; &#125;&#125;]]></content>
      <categories>
        <category>算法与数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程]]></title>
    <url>%2F2017%2F04%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基础创建线程：1.通过继承线程类Thread来创建线程类；2.建立一个实现Runnable接口的类来运行线程。 通过继承Thread创建一个子类，在主控程序中同时运行两个线程。123456789101112131415161718192021222324class Thread1&#123; public static void main(String args[])&#123; testThread t1 = new testThread(&quot;thread1&quot;); testThread t2 = new testThread(&quot;thread2&quot;); t1.start(); t2.start(); &#125; &#125;class testThread extends Thread&#123; public testThread(String str)&#123; super(str); &#125; public void run()&#123; for(int i=0;i&lt;3;i++)&#123; System.out.println(getName()+&quot;在运行&quot;)； try&#123; sleep(1000); &#125;catch(InterruptedException e)&#123;&#125; &#125; System.out.println(getName()+&quot;已结束&quot;)； &#125;&#125; 线程的生命周期·创建（New Thread）·运行（Runnable）·挂起（Not Runnable）·结束（Dead） 以下三种情况会使线程转入Not Runnable状态1.调用sleep方法时，延时结束，重新转入Runnable状态；2.调用wait方法等待一个特定状态发生时，状态发生后，其他对象必须调用notify或notifyAll方法向等待中的线程发出通知，才能唤醒这个线程；3.当线程被I/O阻塞时，I/O完成后可唤醒线程。 售票系统之多线程买火车票是大家春节回家最为关注的事情，我们就简单模拟一下火车票的售票系统：有500张从广州到长沙的火车票，在8个窗口同时出售，保证系统的稳定性和数据的原子性。 show my code . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Service&#123; private String ticketName; private int totalCount; private int remaining; public Service(String ticketName , int totalCount)&#123; this.ticketName=ticketName; this.totalCount=totalCount; this.remaining=totalCount; &#125; public synchronized int saleTicket(int ticketNum)&#123; if(remaining&gt;0)&#123; remaining-=ticketNum; try&#123; Thread.sleep(1000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; if(remaining&gt;=0)&#123; return remaining; &#125;else&#123; remaining+=ticketNum; return -1; &#125; &#125; return -1; &#125; public synchronized int getRemaining()&#123; return remaining; &#125; public String getTicketName()&#123; return this.ticketName; &#125;&#125;class TicketSaler implements Runnable&#123; private String name; private Service service; public TicketSaler(String windowName , Service service)&#123; this.name=windowName; this.service=service; &#125; @Override public void run()&#123; while(service.getRemaining()&gt;0)&#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+"出售第"+service.getRemaining()+"张票，"); int remaining =service.saleTicket(1); if(remaining&gt;=0)&#123; System.out.println("出票成功！剩余"+remaining+"张票。"); &#125;else &#123; System.out.println("出票失败！ 该票已售完 。"); &#125; &#125; &#125; &#125;&#125;public class MyThreadTests&#123; public static void main(String [] args)&#123; //testThread(); Service service=new Service("广州 --&gt; 长沙",500); TicketSaler ticketSaler=new TicketSaler("售票系统" , service); Thread threads []=new Thread[8]; for(int i=0;i&lt;threads.length;i++)&#123; threads[i]=new Thread(ticketSaler,"窗口"+(i+1)); System.out.println("窗口"+(i+1)+"开始出售"+service.getTicketName()+"的票..."); threads[i].start(); &#125; &#125;&#125; 部分结果： 1234567891011121314151617181920窗口1开始出售广州 --&gt; 长沙的票...窗口2开始出售广州 --&gt; 长沙的票...窗口3开始出售广州 --&gt; 长沙的票...窗口4开始出售广州 --&gt; 长沙的票...窗口5开始出售广州 --&gt; 长沙的票...窗口6开始出售广州 --&gt; 长沙的票...窗口7开始出售广州 --&gt; 长沙的票...窗口8开始出售广州 --&gt; 长沙的票...窗口1出售第500张票，出票成功！剩余499张票。窗口3出售第499张票，出票成功！剩余498张票。窗口3出售第498张票，......窗口7出售第0张票，出票失败！ 该票已售完 。窗口2出售第0张票，出票失败！ 该票已售完 。窗口1出售第0张票，出票失败！ 该票已售完 。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习笔记]]></title>
    <url>%2F2017%2F04%2F02%2FJSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JSP : Java Server Pages ,是一个简化的Servlet设计，实现了在Java中使用HTML标签。 JSP基础语法：1.JSP指令·page指令：通常位于Jsp页面的顶端，同一个页面可以有多个page指令。·include指令：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。·taglib指令：使用标签库定义新的自定义标签，在JSP页面中启动定制行为。 2.JSP注释·HTML的注释：&lt; !–heml注释–&gt; //客户端可见·JSP的注释：&lt;%–html注释–%&gt; //客户端不可见·JSP脚本注释：//单行注释/**/多行注释 3.JSP脚本&lt;%Java代码%&gt; 4.JSP声明在JSP页面中定义变量或者方法。&lt;%!JAVA代码%&gt;5.Java 表达式在JSP页面中执行的表达式。&lt;% =表达式 %&gt; //注意:表达式不以分号结束 6.JSP页面生命周期·用户发出请求index.jsp·是否是第一次请求—&gt;·是–&gt;JSP引擎把该JSP文件转换成为一个Servlet，生成字节码文件，并执行jspInit()–&gt;再访问生成的字节码文件·否–&gt;直接访问生成的字节码文件·解析执行，jspService() 当用户第一次请求一个jsp页面时，首先被执行的方法是构造方法。 JSP内置对象12345678910111213141516171.内置对象简介JSP内置对象是Web容器创建的一组对象，不使用new关键就可以使用的内置对象。2.四种作用域范围3.out4.request5.session6.application7.其他内置对象缓冲区：Buffer缓冲区就是内存的一块区域用来保存临时数据。 8.ContextConfig 的 init 方法将会主要完成以下工作：·创建用于解析 xml 配置文件的 contextDigester 对象·读取默认 context.xml 配置文件，如果存在解析它·读取默认 Host 配置文件，如果存在解析它·读取默认 Context 自身的配置文件，如果存在解析它·设置 Context 的 DocBase 9.ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：·创建读取资源文件的对象·创建 ClassLoader 对象·设置应用的工作目录·启动相关的辅助类如：logger、realm、resources 等·修改启动状态，通知感兴趣的观察者（Web 应用的配置）·子容器的初始化·获取 ServletContext 并设置必要的参数·初始化“load on startup”的 Servlet 10.与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>框架 JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 笔记]]></title>
    <url>%2F2017%2F03%2F31%2FSpring-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Spring 是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 框架与类库的区别：-框架一般是封装了逻辑、搞内聚的，类库则是松散的工具组合；-框架专注于某一领域，类库则是更通用的。 接口实体把自己提供给外界的一种抽象化的说明；接口是对外的一种说明，说明了我会提供哪些功能，然后至于内部的实现，对外是不公开的；对应java接口即声明，声明了哪些方法是对外公开提供的；123接口：只能有声明，不能有实现抽象类：既能有声明，也有实现普通类：只能有完全的实现 在Java8中，接口可以拥有方法体。 面向接口编程‘面向接口编程’中的’接口’是用于隐藏具体实现和实现多态性的组件。 什么是IOCIOC:控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护DI（依赖注入）是其一种实现方式目的：创建对象并且组装对象之间的关系1234IOC ·找IOC容器·容器返回对象·使用对象 在Spring 中的bean应满足如下几个原则：（1）每个bean实现类都应提供无参数的构造器。（2）接受构造注入的bean，则应提供对应的构造函数。（3）接受设值注入的bean，则应提供对应的setter方法，并不强制要求提供对应的getter方法。 Bean 的作用域·singleton ： 单例，指一个Bean容器中只存在一份·prototype ： 每次请求（每次使用）创建新的实例，destroy方式不生效·request ： 每次http请求创建一个实例且仅在当前request内有效·session ： 同上，每次http请求创建，当前session内有效·global session：基于portlet的web中有效（portlet定义了global session ），如果是在web中，同session 关于bean初始化和销毁同时使用的注意情况：1，默认全局的初始化和销毁方法；2，实现接口的初始化和销毁方法；3，配置文件中配置初始化和销毁方法；这三个方法同时使用时，1默认的则不执行，而23两种都会执行，并且是2实现接口的方式先于配置中3的执行。1默认的全局初始化和销毁方法可以有可以没有，有没有对配置都没有太大影响，当然如果一个bean没有采取23初始化销毁方法，而有1默认的方法的话，这两个方法还是会执行的。即使没有，系统也不会报错。 学习关键点：1.依赖注入2.面向切面3.Spring MVC4.Spring对jdbc的支持]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer(11-20)]]></title>
    <url>%2F2017%2F03%2F26%2F%E5%89%91%E6%8C%87Offer(11-20)%2F</url>
    <content type="text"><![CDATA[关于剑指Offer的一些解题思路 题11：数值的整数次方实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;public class Main &#123; public static void main(String[] args)throws Exception &#123; Scanner sc=new Scanner(System.in); double n=sc.nextDouble(); int exp=sc.nextInt(); System.out.println(power(n,exp)); &#125; public static double power(double base ,int exponent)throws Exception&#123; if(equal(base,0.0) &amp;&amp; exponent&lt;0)&#123; throw new Exception(&quot;0的负次数幂无意义&quot;); // 1/0 没意义 &#125; if(exponent&lt;0)&#123; return 1.0/powerWithExponent(base,-exponent); &#125;else &#123; return powerWithExponent(base,exponent); &#125; &#125; public static double powerWithExponent(double base , int exponent)&#123; if(base==0) return 1; if(exponent==1) return base; double res =1; for(int i=0;i&lt;exponent;i++)&#123; res=res*base; &#125; return res; &#125; public static boolean equal(double base , double none)&#123; if((base-none&gt;-0.0000001)&amp;&amp;base-none&lt;0.0000001)&#123; //在0附近，误差0.0000001 return true; &#125;else &#123; return false; &#125; &#125;&#125; 题12：打印1到最大的n位数输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3 一直到最大的3位数即999。12 题13： 题14：调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args)throws Exception &#123; int[] array = &#123;1, 4, 2, 5, 21, 67, 21, 66, 23, 77, 68&#125;; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(order(array)[i]); &#125; &#125; public static int [] order(int [] array)&#123; if(array.length==0||array==null) return array; int start=0; int end=array.length-1; while (start&lt;end)&#123; while (start&lt;end &amp;&amp; !isEven(array[start]))&#123; start++; &#125; while (start&lt;end&amp;&amp; isEven(array[end]))&#123; end--; &#125; if(start&lt;end)&#123; int temp=array[start]; array[start]=array[end]; array[end]=temp; &#125; &#125; return array; &#125; public static boolean isEven(int n)&#123; return n%2==0; &#125;&#125; 题15：链表中倒数第k个结点题目：输入一个链表，输出该链表中倒数第k 个结点．为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾结点是倒数第 1 个结点．例如一个链表有 6 个结点，从头结点开始它们的值依次是 1 、2、3、4、5 、6。这个个链表的倒数第 3 个结点是值为 4 的结点。1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; public static void main(String[] args)&#123; ListNode head=new ListNode(); ListNode second=new ListNode(); ListNode third= new ListNode(); ListNode forth=new ListNode(); head.next=second; second.next=third; third.next=forth; head.val=1; second.val=2; third.val=3; forth.val=4; System.out.println(findKToTail(head,3).val); &#125; public static ListNode findKToTail(ListNode head , int k)&#123; if (head==null&amp;&amp;k==0)&#123; return null; &#125; int count=0; ListNode resNode = new ListNode(); ListNode headNode=head; while (headNode!=null)&#123; headNode=headNode.next; count++; &#125; for(int i=0;i&lt;=count-k;i++)&#123; head=head.next; &#125; return head.next; &#125; public static class ListNode&#123; int val; ListNode next; &#125;&#125; 题16：反转链表 题17：合并两个排序的链表题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的递归的方法真是好用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Main &#123; public static void main(String[] args)&#123; ListNode head1=new ListNode(); ListNode second1=new ListNode(); ListNode third1= new ListNode(); ListNode forth1=new ListNode(); head1.next=second1; second1.next=third1; third1.next=forth1; head1.val=1; second1.val=5; third1.val=8; forth1.val=13; ListNode head2=new ListNode(); ListNode second2=new ListNode(); ListNode third2= new ListNode(); ListNode forth2=new ListNode(); head2.next=second2; second2.next=third2; third2.next=forth2; head2.val=2; second2.val=4; third2.val=7; forth2.val=9; ListNode resNode=mergeList(head1,head2); while (resNode!=null) &#123; System.out.println(resNode.val); resNode = resNode.next; &#125; &#125; public static ListNode mergeList(ListNode head1 , ListNode head2)&#123; if(head1==null)&#123; return head2; &#125; if(head2==null)&#123; return head1; &#125; ListNode mergeNode=null; if(head1.val&lt;head2.val)&#123; mergeNode=head1; mergeNode.next=mergeList(head1.next,head2); &#125;else &#123; mergeNode=head2; mergeNode.next=mergeList(head1,head2.next); &#125; return mergeNode; &#125; public static class ListNode&#123; int val; ListNode next; &#125;&#125; 题18：树的子结构 题19：二叉树的镜像题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。输入描述: 二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 512345678910111213141516171819202122public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; */ public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null ) return ; TreeNode temp; temp=root.left; root.left=root.right; root.right=temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 题20：顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 45 6 7 89 10 11 1213 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList; public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if (matrix == null) return null; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); int start = 0; while(matrix[0].length &gt; start *2 &amp;&amp; matrix.length &gt; start *2)&#123; printMatrixInCircle(matrix,result,start); start++; &#125; return result; &#125; public static void printMatrixInCircle(int [][]matix,ArrayList&lt;Integer&gt;result,int start)&#123; int endX = matix[0].length - start -1; int endY = matix.length - start -1; //从左向右打印一行 for(int i = start;i &lt;=endX;i++)&#123; result.add(matix[start][i]); &#125; //从上到下 for(int i = start+1; i &lt;=endY;i++) result.add(matix[i][endX]); //从右到左 if(start &lt; endX &amp;&amp;start &lt; endY) for(int i = endX -1;i&gt;= start;i--) result.add(matix[endY][i]); //从下到上 if(start &lt; endX &amp;&amp; start &lt; endY-1) for(int i = endY - 1;i &gt;=start+1;i--) result.add(matix[i][start]); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易笔试]]></title>
    <url>%2F2017%2F03%2F26%2F%E7%BD%91%E6%98%93%E7%AC%94%E8%AF%95%2F</url>
    <content type="text"><![CDATA[网易2017年校招 java1.下厨房每组输入多行，每行有多种食材，求每组共多少食材，用hashtable不添加重复的特性解决。 1234567891011121314import java.util.Hashtable;import java.util.Scanner;public class 下厨房&#123; public static void main(String [] args)&#123; Scanner sc=new Scanner(System.in); Hashtable&lt;String,Integer&gt; set = new Hashtable&lt;String .Integer&gt;(); while(sc.hasNext())&#123; String str = sc.next(); set.put(str,1); &#125; System.out.println(set.size()); &#125;&#125; 注：在Iterator类中，我们经常用到两个方法：hasNext(),next()。具体含义：next(),是返回当前元素，并指向下一个元素。 hasNext(),是判断当前元素是否存在，并指向下一个元素（即索引）。 Java代码实现 12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>网易</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2017%2F03%2F16%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于MySQL学习过程中的一些总结！ 基础知识MySQL默认的端口号是3306；MySQL中的超级用户叫 root；创建数据库： create database ；修改数据库： alter database ；删除数据库： drop database ； 登陆MySQL客户端 : mysql -uroot -p16213018 -P3306 -h127.0.0.1 查看数据库 ： SHOW DATABASES； 打开test数据库 : USE test ; 创建数据表： CREATE TABLE tb1(1234username VARCHAR(20),age TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED ); 查看数据表： SHOW TABLES ； 查看数据表结构： SHOW COLUMNS FROM tb1 ; 插入记录： INSERT tb1 VALUES(‘Tom’,25,6843.34); 记录查找： SELECT * FROM tb1;空值与非空：CREATE TABLE(20) tb2(username VARCHAR(20) NOT NULL,age TINYINT UNSIGNED NULL); 查表： SHOW COLUMNS tb2; 事务事务是数据库中一个单独的执行单元（Unit） 事务必须满足4个属性： 原子性：事务必须被完整执行 一致性：执行前和执行后，数据库数据必须保持一致的状态 隔离性：也称为独立性，当两个或多个事务并发执行时，为了保证数据的安全性，将事务隔离，不被其他正在进行的事务看到 持久性：永久性，事务完成后，对数据库的更改是永久的 创建用户表以及问题表如果存在则先删除再创建123456789101112131415161718192021DROP TABLE IF EXISTS `question`;CREATE TABLE `question` (`id` INT NOT NULL AUTO_INCREMENT,`title` VARCHAR(255) NOT NULL,`content` TEXT NULL,`user_id` INT NOT NULL,`created_date` DATETIME NOT NULL,`comment_count` INT NOT NULL,PRIMARY KEY (`id`),INDEX `date_index` (`created_date` ASC));DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL DEFAULT ‘’, `password` VARCHAR(128) NOT NULL DEFAULT ‘’ , ‘salt’ VARCHAR(32) NOT NULL DEFAULT ‘’ , ‘head_url’ VARCHAR(256) NOT NULL DEFAULT ‘’ , PRIMARY KEY (`id`) UNIQUE KEY ‘name’ (‘name’)) ENGINE=INNODB DEFAULT CHARSET=utf8 查询表格1SELECT * FROM question; 删除数据库cache1DROP DATABASE CACHE; 创建数据库cache1CREATE DATABASE CACHE; // 创建一个数据库 创建表格1234567891011121314151617CREATE TABLE SYS_ROLE( ID INTEGER, NAME VARCHAR(255) NOT NULL);CREATE TABLE SYS_ROLE_USER( SYS_USER_ID INTEGER, ROLES_ID INTEGER);INSERT INTO SYS_ROLE(id,NAME) VALUES(1,&apos;ROLE_ADMIN&apos;);INSERT INTO SYS_ROLE(id,NAME) VALUES(2,&apos;ROLE_USER&apos;);INSERT INTO SYS_ROLE_USER(SYS_USER_ID,ROLES_ID) VALUES(1,1);INSERT INTO SYS_ROLE_USER(SYS_USER_ID,ROLES_ID) VALUES(2,2); 1234567891011DROP TABLE IF EXISTS `city`;CREATE TABLE `city` ( `id` INT(10) UNSIGNED NOT NULL , `province_id` INT(10) UNSIGNED NOT NULL , `city_name` VARCHAR(25) DEFAULT NULL , `description` VARCHAR(25) DEFAULT NULL , PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO city(id,province_id,city_name,description) VALUES(2 ,2,&apos;长沙&apos;,&apos;我家在长沙&apos;); 123456789CREATE DATABASE Persion; CREATE TABLE `persion` ( `id` INT(10) UNSIGNED NOT NULL , `persion_id` INT(10) UNSIGNED NOT NULL , `persion_name` VARCHAR(25) DEFAULT NULL , `description` VARCHAR(25) DEFAULT NULL , PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实验楼学习笔记开发准备12345# 打开 MySQL 服务sudo service mysql start #使用 root 用户登录，密码为空mysql -u root 新建数据库123456CREATE DATABASE mysql_shiyan;CREATE DATABASE name1;create database name2;CREATE database name3;create DAtabaSE name4; 连接数据库1use mysql_shiyan 新建数据表1CREATE TABLE employee (id int(10),name char(20),phone int(12)); 插入数据12345INSERT INTO employee(id,name,phone) VALUES(01,&apos;Tom&apos;,110110110);INSERT INTO employee VALUES(02,&apos;Jack&apos;,119119119);INSERT INTO employee(id,name) VALUES(03,&apos;Rose&apos;); 主键12345create table abc(id int(10) primary key, name char(20)); 对数据库修改123SHOW DATABASES;DROP DATABASE test_01;ALTER TABLE 表名字 DROP COLUMN 列名字; 索引12345ALTER TABLE employee ADD INDEX idx_id (id); #在employee表的id列上建立名为idx_id的索引CREATE INDEX idx_name ON employee (name); #在employee表的name列上建立名为idx_name的索引show index from employee; 视图12CREATE VIEW v_emp(v_name,v_age,v_phone) AS SELECT name,age,phone FROM employee;select * from v_emp; 操作命令12345mysql&gt; SELECT VERSION(), CURRENT_DATE; //查时间mysql&gt; SELECT SIN(PI()/4), (4+1)*5; //计算mysql&gt; SELECT VERSION(); SELECT NOW(); //现在的时间 MySQL操作12345678910111213141516171819202122232425262728293031323334mysql&gt; SHOW DATABASES;mysql&gt; CREATE DATABASE test;mysql&gt; USE test//创建表mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20), -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE); mysql&gt; SHOW TABLES; //描述mysql&gt; DESCRIBE pet; //装载文本到表中mysql&gt; LOAD DATA INFILE &apos;/home/shiyanlou/Desktop/pet.txt&apos; INTO TABLE pet;//检索表mysql&gt; SELECT * FROM pet;//选择特点行mysql&gt; SELECT * FROM pet WHERE name = &apos;Bowser&apos;;//选择条件mysql&gt; SELECT * FROM pet WHERE birth &gt; &apos;1998-1-1&apos;;//选择特殊列mysql&gt; SELECT name, birth FROM pet;//选择行与列mysql&gt; SELECT name, species, birth FROM pet -&gt; WHERE species = &apos;dog&apos; OR species = &apos;cat&apos;;//计算行数mysql&gt; SELECT COUNT(*) FROM pet; MySQL笔试的4个问题问题来源 问题1：如何删除mysql表中的重复数据，只保留一条记录？先添加唯一性字段，若有则直接删除 1234567ALTER TABLE city1 ADD id int default 0;alter table city1 modify id int auto_increment primary key delete from city2where id not in(select * from (select min(id) from city2 group by name having count (name)&gt;1 ) as a ) 问题2：找出表中的出现次数最多的某条记录（或某个字段）1234SELECT sid ,count (sid) FROM city2group by sidorder by count(sid) DESClimit 1 问题3：用一条SQL语句查询出grade表中每门课都大于80分的学生姓名1234567891011121314name course score 张三 语文 81张三 数学 75李四 语文 76李四 数学 90王五 语文 81王五 数学 100王五 英语 90------select name from gradegroup by namehaving min(分数)&gt;80 问题4：将表city1中num_person字段根据人数进行重新编码要求:0&lt;=x&lt;500,000编码为1500,000&lt;=x&lt;1,000,000编码为21,000,000&lt;=x编码为3 123456select name,case when num_persion &gt;=0 and num_persion &lt;500000 then 1 when num_persion &gt;=500000 and num_persion &lt;1000000 then 2 when num_persion &gt;=1000000 then 3 end as mark from city1 运算符案例1234567891011121314151617181920212223242526272829303132mysql -h localhost -u root -p16213018mysql&gt; CREATE DATABASE db1;mysql&gt; use db1;mysql&gt; CREATE TABLE tmp ( note VARCHAR(100),price INT);mysql&gt; INSERT INTO tmp VALUES (&quot;this is good&quot; , 50);mysql&gt; SELECT price ,price +10,price-10,price*2,price /2,price %2 FROM tmp;+-------+-----------+----------+---------+----------+----------+| price | price +10 | price-10 | price*2 | price /2 | price %2 |+-------+-----------+----------+---------+----------+----------+| 50 | 60 | 40 | 100 | 25.0000 | 0 |+-------+-----------+----------+---------+----------+----------+mysql&gt; SELECT price ,price BETWEEN 30 AND 80 , GREATEST(price ,70,30),price IN(20,50,35) , price IN(10,20,35) FROM tmp;+-------+-------------------------+------------------------+-----------------------+--------------------+| price | price BETWEEN 30 AND 80 | GREATEST(price ,70,30) | price IN(20,50,35) | price IN(10,20,35) |+-------+-------------------------+------------------------+-----------------------+--------------------+| 50 | 1 | 70 | 1 | 0 |+-------+-------------------------+------------------------+-----------------------+--------------------+mysql&gt; SELECT price ,price&amp;2 ,price|4 ,~price FROM tmp;+-------+---------+---------+----------------------+| price | price&amp;2 | price|4 | ~price |+-------+---------+---------+----------------------+| 50 | 2 | 54 | 18446744073709551565 |+-------+---------+---------+----------------------+ 查找数据 GROUP BY 和 ORDER BY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- 建表show databases;use db1;create table orderitems(o_num int not null,o_item int not null ,f_id char(10) NOT NULL,quantity int NOT NULL,item_price decimal(8,2) NOT NULL,PRIMARY KEY (o_num , o_item));-- 插入数据Insert into orderitems (o_num,o_item , f_id , quantity , item_price)values (30001,1,&apos;a1&apos;,10,5.2),(30001,2,&apos;b2&apos;,3,7.6),(30001,3,&apos;bs1&apos;,5,11.2),(30001,4,&apos;bs2&apos;,15,9.2),(30002,1,&apos;b3&apos;,2,20.0),(30003,1,&apos;c0&apos;,100,10),(30004,1,&apos;o2&apos;,50,2.50),(30005,1,&apos;c0&apos;,5,10),(30005,2,&apos;b1&apos;,10,8.99),(30005,3,&apos;a2&apos;,10,2.2),(30005,4,&apos;m1&apos;,10,14.99);-- 查看下表select * from orderitems;-- 查找订单价格大于100的订单号和总订单价格select o_num ,sum(quantity*item_price) AS orderTotal -- 选列FROM orderitems -- 目标表group by o_num -- 按订单号对数据进行分组having sum(quantity*item_price)&gt;=100; -- 条件语句-- 用ORDER BY 显示返回select o_num ,sum(quantity*item_price) AS orderTotal -- 选列FROM orderitems -- 目标表group by o_num -- 按订单号对数据进行分组having sum(quantity*item_price)&gt;=100 -- 条件语句order by orderTotal ; -- 排序输出select * from orderitems limit 4; -- 查询结果的前4行select * from orderitems limit 4,3; -- 查询结果的第4个结果开始的(不包括第4个),3行记录-- 查询表中的总行数select count(*) AS order_numfrom orderitems; -- 查询o_num 的价格的平均值select o_num , avg(item_price) as avg_pricefrom orderitemsgroup by o_num;-- 查询o_num=30001 的价格的平均值select o_num , avg(item_price) as avg_pricefrom orderitemswhere o_num=30001;-- 查询价格最高的select max(item_price) as max_pricefrom orderitems;-- 查询价格最低的select o_num , min(item_price) as min_pricefrom orderitems;-- 查询各个供应商提供的价格最低的select o_num , min(item_price) as min_pricefrom orderitemsgroup by o_num; 记录的插入、删除、更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081-- 创建表create table books(id int(11) NOT NUll primary key ,name varchar(50) not null ,authors varchar(100) not null ,price float not null ,pubdate year not null ,note varchar(100) not null ,num int(11) not null default 0);select * from books;-- 插入行insert into books (id , name , authors ,price , pubdate , note ,num) values (1,&apos;Table of AAA&apos; ,&apos;Dickes&apos;,23,&apos;1995&apos;,&apos;novel&apos;,111) ;-- 插入行 方式二insert into books values (2,&apos;Emmat&apos; ,&apos;Jane lura&apos;,35,&apos;1993&apos;,&apos;joke&apos;,22); select * from books;----------------------------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 23 1995 novel 111 2 Emmat Jane lura 35 1993 joke 22------------------------------------------------------------------------------ insert into books values (3,&apos;Story of Jane&apos; ,&apos;Jane Tim&apos;,40,&apos;2001&apos;,&apos;novel&apos;,0),(4,&apos;Lovey Day&apos; ,&apos;cswd&apos;,20,&apos;2005&apos;,&apos;novel&apos;,30),(5,&apos;Old Land&apos; ,&apos;dsfre&apos;,30,&apos;2010&apos;,&apos;law&apos;,0),(6,&apos;The battle&apos; ,&apos;safs&apos;,33,&apos;1999&apos;,&apos;medicine&apos;,40),(7,&apos;Rose Hood&apos; ,&apos;Richard Kale&apos;,28,&apos;2008&apos;,&apos;cartoon&apos;,28);select * from books;----------------------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 23 1995 novel 111 2 Emmat Jane lura 35 1993 joke 22 3 Story of Jane Jane Tim 40 2001 novel 0 4 Lovey Day cswd 20 2005 novel 30 5 Old Land dsfre 30 2010 law 0 6 The battle safs 33 1999 medicine 40 7 Rose Hood Richard Kale 28 2008 cartoon 28------------------------------------------------------------------------- UPDATE books SET price =price +5 WHERE note=&apos;novel&apos;; select id ,name,price , note from books where note = &apos;novel&apos;; ---------------------------------------------------------------- id name price note 1 Table of AAA 28 novel 3 Story of Jane 45 novel 4 Lovey Day 25 novel----------------------------------------------------------------- -- 更改价格方法二 直接改 UPDATE books set price=40 ,note =&apos;joke&apos; where name = &apos;emmat&apos;; select id ,name,price , note from books where note = &apos;joke&apos;; --------------------------------------------------------- id name price note 2 Emmat 40 joke---------------------------------------------------------- -- 条件删除行delete from books where num=0;select * from books;-------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 28 1995 novel 111 2 Emmat Jane lura 40 1993 joke 22 4 Lovey Day cswd 25 2005 novel 30 6 The battle safs 33 1999 medicine 40 7 Rose Hood Richard Kale 28 2008 cartoon 28-------------------------------------------------------------]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[麻省理工：算法导论-分治法--上课笔记]]></title>
    <url>%2F2017%2F03%2F14%2F%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%EF%BC%9A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习麻省理工算法导论的笔记。 分治：步骤：1、分2、治 3、合并 实例：一、归并排序：1、将排序数组一分为二2、将两个子数组排序3、合并两个有序子数组 二、二分查找：在一个有序数组中查找x1、先将x和有序数组中间的数比较2、再将x和左或右子数组的中间的数比较3、done 三、乘方问题：求x的n次方1、分解12x^n= x^(n/2)*x^(n/2) n为偶 x^((n-1)/2)*x^((n-1)/2)*x n为奇 2、先求两边乘(子算法规模为n/2)，再乘一起算法时间为O(lg n) 四、斐波那契数列问题：12345 &#123; 0 ; n=0Fn= | 1 ; n=1 &#123; F(n-1)+F(n-2)``` 这是个指数级问题，然而可以用朴素平方递归来降低到O(lg n) { F2 F1 } = ( 1 1 ){ F1 F0 } ( 1 0 ) { Fn+1 Fn } = { Fn Fn-1 }( 1 1 ) = ( 1 1 )^n-1 * ( 1 1 ) =( 1 1 )^n{ Fn Fn-1 } { Fn-1 Fn-2 }( 1 0 ) ( 1 0 ) ( 1 0 ) ( 1 0 )` $\LaTeX$ _ss This expression $\sqrt{3x-1}+(1+x)^2$ is an example of a $\LaTeX$ inline equation. he Lorenz Equations: $$\begin{aligned}\dot{x} &amp; = \sigma(y-x) \\dot{y} &amp; = \rho x - y - xz \\dot{z} &amp; = -\beta z + xy\end{aligned}$$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>公开课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F03%2F12%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 Java代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Sort;import java.util.Arrays;/** * Created by zdmein on 2017/9/27. * 快排 */public class quickSort1 &#123; public static void main(String[] args) &#123; int[] testData = &#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int[] dataSorted = quickSort(testData, 0, testData.length-1); for(int a : dataSorted) &#123; System.out.print(a + " "); &#125; &#125; /** * 快速排序 */ private static int partition(int[] data, int low, int high) &#123; int key = data[low]; while(low &lt; high) &#123; while(low&lt;high &amp;&amp; data[high]&gt;=key) &#123; high--; &#125; data[low] = data[high];//(此时因low=high或data[high]&lt;key)将high下标处的数赋给low下标处的数，保证data[low]&lt;key while(low&lt;high &amp;&amp; data[low]&lt;=key) &#123; low++; &#125; data[high] = data[low];//(此时因low=high或data[low]&gt;key)将low下标处的数赋给high下标处的数，保证data[high]&gt;key &#125; data[low] = key; return low; &#125; public static int[] quickSort(int[] data, int low, int high) &#123; if(low &lt; high) &#123; int result = partition(data, low, high); quickSort(data, low, result-1);//对low到result-1下标间数进行排序 quickSort(data, result+1, high);//对result+1到high下标间数进行排序 &#125; return data; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2017%2F03%2F12%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[自下往上对相邻的两个数进行比较和调整Key：大的数往下沉，小的数往上浮 Java实现 12345678910111213141516171819package algorithms4th;public class BubbleSort &#123; public static void main(String [] args)&#123; int a []=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; for(int j=0;j&lt;a.length-1;j++)&#123; for(int i=a.length-1;i&gt;j;i--)&#123; if(a[i]&lt;a[i-1])&#123; int temp=a[i]; a[i]=a[i-1]; a[i-1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F03%2F12%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基本思想：算法先要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 Math.ceil()是常见编程语言中的常用代码,ceil() 方法执行的是向上取整计算，它返回的是大于或等于函数参数，并且与之最接近的整数。 Java代码实现 1234567891011121314151617181920212223242526272829package algorithms4th;public class ShellSort &#123; public static void main (String []args)&#123; int a []=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; double d1=a.length; while(true)&#123; d1=Math.ceil(d1/3); int d=(int)d1; for(int x=0;x&lt;d;x++)&#123; for(int j=(int) (x+d);j&lt;a.length;j+=d)&#123; int i=(int) (j-d); if(a[i]&gt;a[j])&#123; temp=a[j]; a[j]=a[i]; a[i]=temp; &#125; &#125; &#125; if(d==1)&#123; break; &#125; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单直接排序]]></title>
    <url>%2F2017%2F03%2F12%2F%E7%AE%80%E5%8D%95%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基本思想：每个数与第一个数相比，选最小的放第一个；然后从第二个数开始，每个数与第二个数相比，选最小的放第二；…… Java代码实现 12345678910111213141516171819package algorithms4th;public class SelectSort &#123; public static void main(String [] args)&#123; int a []=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; for (int i=0;i&lt;a.length;i++)&#123; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[j]&lt;a[i])&#123; int temp=a[j]; a[j]=a[i]; a[i]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接插入排序]]></title>
    <url>%2F2017%2F03%2F08%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 Java代码实现 123456789101112131415161718192021package algorithms4th;public class InsertSort &#123; public static void main (String [] args)&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i-1;j&gt;0;j--)&#123; if(a[j]&lt;a[j-1])&#123; temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
