{"meta":{"title":"Damin's Notes","subtitle":"Learn ,Practice ,Summary !","description":"Goals determine <br/> what you are going to be .","author":"Damin ZHOU","url":"http://zhoudamin.github.io","root":"/"},"pages":[{"title":"Hello World！","date":"2017-03-26T13:29:08.000Z","updated":"2018-06-25T06:10:40.526Z","comments":true,"path":"about/index.html","permalink":"http://zhoudamin.github.io/about/index.html","excerpt":"","text":"关于我欢迎来到我的博客！ From zhoudamin Email: daminzhou@foxmail.com 中山大学→华为 技能树：1.QRcode 研发 2.Spring-boot后台开发 3.数学建模 4.Java，C#、Python、C 5.目前正在算法里摸爬滚打~ 相册毕业~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2017-03-31T13:59:04.000Z","updated":"2017-03-31T13:59:52.125Z","comments":false,"path":"categories/index.html","permalink":"http://zhoudamin.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2017-04-05T04:49:39.000Z","updated":"2017-04-05T04:50:12.386Z","comments":true,"path":"tags/index.html","permalink":"http://zhoudamin.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"guestbook","date":"2017-03-09T04:38:23.000Z","updated":"2017-03-09T07:01:43.189Z","comments":true,"path":"guestbook/index.html","permalink":"http://zhoudamin.github.io/guestbook/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"搜索二维矩阵","slug":"搜索二维矩阵","date":"2020-04-20T16:49:29.000Z","updated":"2020-04-20T16:52:00.150Z","comments":true,"path":"2020/04/21/sou-suo-er-wei-ju-zhen/","link":"","permalink":"http://zhoudamin.github.io/2020/04/21/sou-suo-er-wei-ju-zhen/","excerpt":"编写一个高效的算法来判断&nbsp;m x n&nbsp;矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例&nbsp;1: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例&nbsp;2: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false Related Topics数组二分查找","text":"编写一个高效的算法来判断&nbsp;m x n&nbsp;矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例&nbsp;1: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例&nbsp;2: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false Related Topics数组二分查找 先算全长，再除2，然后/% class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length; if (m== 0) { return false; } int n =matrix[0].length; int right = 0; int left = m*n-1; int indexNum; int index ; while (right&lt;=left){ index =(right+left)/2; indexNum =matrix[index/n][index%n]; if (indexNum ==target){ return true; }else if(indexNum>target){ left=index-1; }else { right = index+1; } } return false; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhoudamin.github.io/tags/leetcode/"}]},{"title":"三数之和","slug":"三数之和","date":"2020-04-19T09:53:06.000Z","updated":"2020-04-19T09:56:22.578Z","comments":true,"path":"2020/04/19/san-shu-zhi-he/","link":"","permalink":"http://zhoudamin.github.io/2020/04/19/san-shu-zhi-he/","excerpt":"给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 &nbsp; 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] Related Topics数组双指针","text":"给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 &nbsp; 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] Related Topics数组双指针 先排序，然后定点，双指针搜索。另外去重。 class Solution { public List&lt;List&lt;Integer>> threeSum(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer>> rstList = new ArrayList&lt;List&lt;Integer>>(); for (int i = 0; i &lt; nums.length - 2; i++) { if (nums[i] > 0) { break; } if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int first = i + 1; int end = nums.length - 1; while (first &lt; end) { int temp = nums[i] + nums[first] + nums[end]; if (temp > 0) { end--; } else if (temp &lt; 0) { first++; } else { List&lt;Integer> list = new ArrayList&lt;>(); list.add(nums[i]); list.add(nums[first]); list.add(nums[end]); rstList.add(list); first++; end--; while (first &lt; end &amp;&amp; nums[first] == nums[first - 1]) { first++; } while (first &lt; end &amp;&amp; nums[end] == nums[end + 1]) { end--; } } } } return rstList; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhoudamin.github.io/tags/leetcode/"}]},{"title":"Apollo核心概念","slug":"Apollo核心概念","date":"2019-10-13T04:03:55.000Z","updated":"2019-10-13T04:09:45.876Z","comments":true,"path":"2019/10/13/apollo-he-xin-gai-nian/","link":"","permalink":"http://zhoudamin.github.io/2019/10/13/apollo-he-xin-gai-nian/","excerpt":"携程框架Apollo概念介绍","text":"携程框架Apollo概念介绍 核心功能统一管理不同环境、不同集群的配置配置修改实时生效（热发布）版本发布管理 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://zhoudamin.github.io/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"http://zhoudamin.github.io/tags/Apollo/"}]},{"title":"Java知识增强","slug":"Java知识增强","date":"2019-08-07T12:39:12.000Z","updated":"2019-08-07T12:47:25.856Z","comments":true,"path":"2019/08/07/java-zhi-shi-zeng-qiang/","link":"","permalink":"http://zhoudamin.github.io/2019/08/07/java-zhi-shi-zeng-qiang/","excerpt":"每日一考！","text":"每日一考！ 倒排索引 讲讲redis里面的哈希表？ happen-before的规则？ volatile修饰符，synchronize锁 java单例模式的实现，懒汉、饿汉？ 进程与线程的区别，多进程和多线程的区别？ HashMap原理，为什么用红黑树，红黑树的特点？ 快排时间空间复杂度，最好最坏的情况，优化方案？ TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？ 讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？ 讲一下最大堆和最小堆 LRU算法实现（伪代码） 链表倒数第K个数（讲思路） 一堆螺丝和螺母用最短时间匹配（代码实现） 求每天浏览页面的新用户（Hive QL实现） 求抖音小视频每日点击量最高的10个（Hash + 最小堆） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhoudamin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"Java知识点锦集","slug":"Java知识点锦集","date":"2019-04-13T09:33:55.000Z","updated":"2019-04-13T10:21:42.906Z","comments":true,"path":"2019/04/13/java-zhi-shi-dian-jin-ji/","link":"","permalink":"http://zhoudamin.github.io/2019/04/13/java-zhi-shi-dian-jin-ji/","excerpt":"知识锦集","text":"知识锦集 hashMap原理，java8做的改变从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。ConcurrentHashMap线程安全。解决碰撞：当出现冲突时，运用拉链法，将关键词为同义词的结点链接在一个单链表中，散列表长m，则定义一个由m个头指针组成的指针数组T，地址为i的结点插入以T(i)为头指针的单链表中。Java8中，冲突的元素超过限制（8），用红黑树替换链表。 String 和 StringBuilder 的区别1）可变与不可变：String不可变，每一次执行“+”都会新生成一个新对象，所以频繁改变字符串的情况中不用String，以节省内存。2）是否多线程安全：StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。StringBuffer和String均线程安全。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhoudamin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"随想","slug":"随想","date":"2019-04-10T14:21:54.000Z","updated":"2019-04-10T15:06:22.105Z","comments":true,"path":"2019/04/10/sui-xiang/","link":"","permalink":"http://zhoudamin.github.io/2019/04/10/sui-xiang/","excerpt":"又到了一年一度域名续费的日子了","text":"又到了一年一度域名续费的日子了 加入我厂也有大半年了，从一开始忙到飞起，体验做不完的活，每次想起这个就想到陈老师给形容的：工作就像打仗一样。入我厂从一名Test做起，慢慢才开始做起开发，最近还搞起了设计，学到了Linux，sh，sql，angular，这些之前都很少接触，入我司半年，也算是小有所得。记得刚来的时候，住的特别挫，居然租了一个10楼无电梯的小房子，OMG，想起去年脚扭伤了，泽林和华哥送我上楼，然后好几天都没下来过，不是不想下来看医生，是根本下不来…2333，确实没必要租这么挫的房子，后面在要排到百草园的前夕，实在是受不了，拔草了后面一栋的三楼一个房子，光线不错，不过下水系统设计的很随意，又排起了百草园的队。。。2333都是泪。从去年年底开始看房子，到现在还没定好房子，发现钱在这个大件面前，真的好不值钱，想买的买不起，买的起的太郊区了，浪费钱。 博客好久没写了，还是好好学习吧，域名就不续了，除了自己访问一下，貌似也没啥用！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://zhoudamin.github.io/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://zhoudamin.github.io/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"人人懂AI","slug":"人人懂AI","date":"2019-03-03T12:57:38.000Z","updated":"2019-03-03T14:10:43.795Z","comments":true,"path":"2019/03/03/ren-ren-dong-ai/","link":"","permalink":"http://zhoudamin.github.io/2019/03/03/ren-ren-dong-ai/","excerpt":"人人懂AI入门学习！","text":"人人懂AI入门学习！ 神经网络M-P Model多参数，多权重学习模型 单层感知器：输入就输出的 多层感知器深度网络的前身。输入层–隐含层–输出层 Back Propagetion Algorithm前向计算输出，比较期望输出，得到误差，然后反向调整权项值，逼近阈值。 可以做车牌识别， 局限性：训练过程，局部最小，不是全局最小，收敛不了。和初始点选择有关，和全局下降速率有关。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zhoudamin.github.io/tags/AI/"}]},{"title":"Java之广度优先搜索算法","slug":"Java之广度优先搜索算法","date":"2018-08-12T14:35:39.000Z","updated":"2018-08-12T15:01:33.696Z","comments":true,"path":"2018/08/12/java-zhi-guang-du-you-xian-sou-suo-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2018/08/12/java-zhi-guang-du-you-xian-sou-suo-suan-fa/","excerpt":"BFS，全称是Breadth First Search。 简单说就是图搜索算法。","text":"BFS，全称是Breadth First Search。 简单说就是图搜索算法。 Word LadderGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence frombeginWord to endWord, such that: Only one letter can be changed at a timeEach intermediate word must exist in the word listFor example, Given:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,return its length 5. Note: Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters. 简单来说就是从一个单词出发，每次只改变一个字母，直到变到最后一个单词，求最短路径。 再简单点思考就是 hit—&gt;hot—&gt;lot/dot—&gt;log/dog—&gt;cog 思路就是用两个set,一个存老的单词，如果添加进路径，就删除；一个存路径。 循环终止条件是路径匹配到尾巴的目标单词； 关键代码 public int ladderLen(String beginWord ,String endWord ,List&lt;String> wordList){ Set&lt;String> wordSet = new HashSet&lt;>(wordList); Set&lt;String> visited = new HashSet&lt;>; visited.add(beginWord); int len=1; //开始计算路径与清楚单词集合里的单词 //算法终止条件 while(!visited.contains(endWord)){ Set&lt;String> temp = new HashSet&lt;>(); for(String word:visited){ for(int i=0;i&lt;word.length;i++){ char[] chars=word.toCharArray(); for(int j=(int)'a';j&lt;(int)'z'+1;j++){ chars[i]=(char)j; String newWord=new String(chars); if(wordSet.contains(newWord)){ temp.add(newWord); wordSet.remove(newWord); } } } } len += 1; if(temp.size()==0){ return 0; } vistied=temp; } return len; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之排序算法","slug":"Java之排序算法","date":"2018-08-06T15:52:53.000Z","updated":"2018-08-06T16:24:12.834Z","comments":true,"path":"2018/08/06/java-zhi-pai-xu-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2018/08/06/java-zhi-pai-xu-suan-fa/","excerpt":"排序，各种排序~","text":"排序，各种排序~ 桶排序First Missing PositiveGiven an unsorted integer array, find the first missing positive integer. For example, given [1,2,0] return 3 and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 分析：本质上是桶排序，每当A[i]!=i+1时，A[i]与A[A[i]-1]交换，终止条件是A[i]==A[A[i]-1]. public int firstMissingPositive(int [] nums){ bucket_sort(nums); for(int i=0;i&lt;nums.length;++i){ if(nums[i]!=(i+1)){ return i+1; } return nums.length+1; } private static void bucket_sort(int [] A){ final int n=A.length; for(int i=0;i&lt;n :i++){ while(A[i]!=i+1){ if(A[i]&lt;1 || A[i]>n || A[i]==A[A[i]-1]) break; int temp = A[i]; A[i]=A[temp-1]; A[temp-1]=temp; } } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之二叉树算法","slug":"Java之二叉树算法","date":"2018-08-05T15:04:25.000Z","updated":"2018-08-05T15:14:02.125Z","comments":true,"path":"2018/08/05/java-zhi-er-cha-shu-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2018/08/05/java-zhi-er-cha-shu-suan-fa/","excerpt":"二叉树算法","text":"二叉树算法 二叉查找树Validate Binary Search Tree 验证二叉搜索树Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. 思路，用递归，左&lt;根&lt;右 &amp;&amp; 左根递归 &amp;&amp; 右根递归关键代码 public boolean isValidBST(TreeNode root){ return isValidBST(root,INT_MIN,INT_MAX); } bool isValidBST (TreeNode* root,int lower ,int upper ){ if(root == nullptr) return true; return root.val>lower &amp;&amp; root.val&lt;upper &amp;&amp; isValidBST(root.left,lower,root.val) &amp;&amp; isValidBST(root.right,root.val,upper); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之数组算法","slug":"Java之数组算法","date":"2018-07-26T15:28:19.000Z","updated":"2018-07-29T03:14:09.336Z","comments":true,"path":"2018/07/26/java-zhi-shu-zu-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2018/07/26/java-zhi-shu-zu-suan-fa/","excerpt":"数组是常见的算法题，所以多做题，多总结，总是能找到idea的。","text":"数组是常见的算法题，所以多做题，多总结，总是能找到idea的。 Product of Array Except SelfGiven an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 思路：首先，介绍方法： [1,a1,a12,a123].*[a234,a34,a4,1]=[a234,a134,a124,a123]这个算法有个O(1)的思路:就是用常数的方法，从左边乘到右边，再取一个常数，从右边乘到左边 //关键算法段 left[0]=1; for(int i=1;i&lt;num.length;++i){ left[i]=left[i-1]*num[i-1]; } int right=1; for(int i=num.length-1;i>=0;i--){ left[i]*=right; //right 初始为1，每次乘完再迭代 right*=num[i]; } return left; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Essence","slug":"Essence","date":"2018-07-24T14:54:44.000Z","updated":"2018-08-15T15:06:33.913Z","comments":true,"path":"2018/07/24/essence/","link":"","permalink":"http://zhoudamin.github.io/2018/07/24/essence/","excerpt":"生活珠玑~","text":"生活珠玑~ 尽量结合兴趣，选准方向，不要动摇，深入研究。 和牛人共事，和善良的人交友。 从此刻起，加上思考，梳理手头的todolist，把最重要的工作找出来，全身心突出亮点。 不问别人为什么，多问自己凭什么！ —by 2018/8/9 健康 不要熬夜，尽量少熬夜 锻炼身体 不抽烟，少饮酒 注意日常行为姿势 多吃健康食品，少吃外卖 不要用眼过度，注意眼睛的休息 注重心理健康 定期体检 生活 建造强大的内心 尽早有理财念头 多出去走走 平和的心态面对一切 喜欢的东西要攒钱买下来 不要以为自己吃不胖 心本善，但是要有提防人的心 社交 增加自身的价值(有效社交) 不要盲目社交 注重对方的需求，不要一味索取 要多和人进行高质量的交流 不要勉强自己合群 分清自己的社交关系深浅 去掉一切不必要的应酬和饭局 不要急切的表达自己的观点，多听少说 人生 尽早做好人生规划(短期、长期) 建立正确的三观(学习、思考、实践) 趁年轻抓紧努力 要有自己的核心竞争力 别因为懒惰放弃能抓住的机会和挑战 要真正了解自己 别怕犯错和失败 不要自作聪明，恃才傲物 承担责任(社会、工作、家庭、自己的选择) 不要怕事，但别主动惹事 尽早进入社会历练 找到正确的平台比能力更重要 学会拒绝 不要轻易跳槽，但每次都要更上一个台阶 工作尽可能积累资源 要忠于自己，再忠于工作和公司 适当的妥协不丢人 要有长远的眼光，不要总是盯着眼前的利益 学习 勤学勤思考 多读书，广读书，读好书 迷茫的时候就学习 要有自己的专精 少刷手机 操作系统、网络、算法数据结构、离散数学、数据库原理与实践，这些看起来枯燥而无味的基础科学，要了解它们是必须付出非常多的时间才有可能理解通透些。而这些基础的扎实程度，就直接决定了你的高度。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://zhoudamin.github.io/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://zhoudamin.github.io/tags/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}]},{"title":"《Hadoop权威指南》 Notes","slug":"《Hadoop权威指南》-Notes","date":"2018-07-08T04:55:24.000Z","updated":"2019-05-12T15:21:17.488Z","comments":true,"path":"2018/07/08/hadoop-quan-wei-zhi-nan-notes/","link":"","permalink":"http://zhoudamin.github.io/2018/07/08/hadoop-quan-wei-zhi-nan-notes/","excerpt":"业余读书笔记1","text":"业余读书笔记1 初识HadoopHadoop项目简述 Common 一组分布式文件系统和通用I/O的组件与接口(序列化、Java RPC 和持久化数据结构)。 Avro 一种支持高效、跨语言的RPC以及永久存储数据的序列化系统。 MapReduce 分布式数据处理模型和执行环境，运行于大型商用机集群。 HDFS 分布式文件系统，运行于大型商用机集群。 Pig 一种数据流语言和运行环境，用以检索非常大的数据集。Pig运行在MapReduce和HDFS的集群上。 Hive 一个分布式、按列存储的数据仓库。Hive管理HDFS中存储的数据，并提供基于SQL的查询语言以查询数据。 HBase 一个分布式、按列存储数据库。 ZooKeeper 一个分布式、可用性高的协调服务。 Sqoop 在数据库和HDFS之间高效传输数据的工具。 关于MapReduce数据处理方法 将输入数据分成固定大小的块，然后把每块分配到各个进程，这样一来，即使有些进程能处理更多数据，我们也可以为他们分配更多的数据。 对每块数据进行处理，取每块中的最大值，作为每块的最高标准。 多台机器如何处理协调性和可靠性的问题。 查找最高气温的方法论 Hadoop自身提供一套可优化网络序列化传输的基本类型，在org.apache.hadoop.io包中。 map()方法的输入时一个键和一个值，首先将包含有一行输入的text值转换成java的String类型，之后使用subString()方法提取感兴趣的列。 map()方法还提供了OutputCollector实例用于输出内容的写入，在这种情况下，将年份按照Text对象进行读写，将气温值封装在IntWritable类型中。 测试气温数据是否缺失or显示为正确的气温读数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zhoudamin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://zhoudamin.github.io/tags/Notes/"}]},{"title":"Java实现彩色二维码","slug":"Java实现彩色二维码","date":"2018-05-02T11:30:05.000Z","updated":"2018-05-02T11:35:35.945Z","comments":true,"path":"2018/05/02/java-shi-xian-cai-se-er-wei-ma/","link":"","permalink":"http://zhoudamin.github.io/2018/05/02/java-shi-xian-cai-se-er-wei-ma/","excerpt":"使用Zxing库实现彩色二维码的生成，代码如下：","text":"使用Zxing库实现彩色二维码的生成，代码如下： package com; import com.google.zxing.BarcodeFormat; import com.google.zxing.EncodeHintType; import com.google.zxing.MultiFormatWriter; import com.google.zxing.client.j2se.MatrixToImageWriter; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel; import com.google.zxing.qrcode.encoder.Encoder; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.Hashtable; import java.util.Map; import java.util.Random; public class TexturedEncoderHandler { /** * 编码 * @param contents * @param width * @param height * @param imgPath */ public void encode(String contents, int width, int height, ErrorCorrectionLevel level, String imgPath) { Hashtable&lt;EncodeHintType, Object> hints = new Hashtable&lt;EncodeHintType, Object>(); // 指定纠错等级 hints.put(EncodeHintType.ERROR_CORRECTION, level); // 指定编码格式 hints.put(EncodeHintType.CHARACTER_SET, \"GBK\"); try { int [][] bitMatrix = new QRCodeWriter().encode(contents, BarcodeFormat.QR_CODE, width, height, hints); int len=bitMatrix.length; width=len*12; boolean [][]matrixBoo=new boolean[width][width]; MyPic(bitMatrix,matrixBoo,imgPath); } catch (Exception e) { e.printStackTrace(); } } public void MyPic(int [][] bitmatrix,boolean [][] matrixboo,String pathname) throws IOException { BufferedImage matrix = new BufferedImage(matrixboo.length , matrixboo[0].length, BufferedImage.TYPE_INT_ARGB); Random rand = new Random(); for(int i=0;i&lt;bitmatrix.length;i++){ for(int j=0;j&lt;bitmatrix[0].length;j++){ if(bitmatrix[i][j]==1){ int rr= rand.nextInt(255); int gg= rand.nextInt(255); int bb= rand.nextInt(255); Color color = new Color(rr, gg, bb); int colorInt = color.getRGB(); for(int n=i*12;n&lt;(i+1)*12;n++){ for(int m=j*12;m&lt;(j+1)*12;m++) { matrixboo[n][m] = true; matrix.setRGB(n, m, colorInt ); } } } } } ImageIO.write(matrix, \"PNG\", new File(pathname)); } /** * @param args */ public static void main(String[] args) { long startTime=System.currentTimeMillis(); String imgPath = \"guangzhou.jpg\"; String contents = \"guangzhou\"; int width = 300, height = 300; ErrorCorrectionLevel level=ErrorCorrectionLevel.L; TexturedEncoderHandler handler = new TexturedEncoderHandler(); handler.encode(contents, width, height, level, imgPath); long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println(\"程序运行时间： \"+(endTime-startTime)+\"ms\"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zhoudamin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java 二维码","slug":"Java-二维码","permalink":"http://zhoudamin.github.io/tags/Java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"HTTP基础","slug":"HTTP基础","date":"2018-04-25T10:18:20.000Z","updated":"2018-04-25T10:19:08.999Z","comments":true,"path":"2018/04/25/http-ji-chu/","link":"","permalink":"http://zhoudamin.github.io/2018/04/25/http-ji-chu/","excerpt":"","text":"服务器意图 GET：获取资源，用来请求已经被URI识别的资源 POST：传输实体主体 PUT：传输文件 HEAD：获得报文首部 DELETE：删除文件 OPTIONS：询问支持的方法 状态码 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://zhoudamin.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://zhoudamin.github.io/tags/HTTP/"}]},{"title":"云计算基础","slug":"云计算基础","date":"2018-04-25T10:13:17.000Z","updated":"2018-04-25T10:14:35.004Z","comments":true,"path":"2018/04/25/yun-ji-suan-ji-chu/","link":"","permalink":"http://zhoudamin.github.io/2018/04/25/yun-ji-suan-ji-chu/","excerpt":"","text":"云计算分类 IaaS 基础设施即服务 PaaS 平台即服务 SaaS 软件即服务 公有云公有云构建在互联网上，任何已付费的用户都可以访问。 私有云私有云构建在局域网内部，属于一个独立的组织。 混合云混合云由公有云和私有云共同构成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"云计算","slug":"云计算","permalink":"http://zhoudamin.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://zhoudamin.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"Hexo Notes","slug":"Hexo Notes","date":"2018-04-23T15:07:42.000Z","updated":"2018-04-23T15:15:14.704Z","comments":true,"path":"2018/04/23/hexo-notes/","link":"","permalink":"http://zhoudamin.github.io/2018/04/23/hexo-notes/","excerpt":"遇到的小问题","text":"遇到的小问题 关于设置页宽没错，这就是我上面提到的那个主题，这个主题有三种外观，其中我现在使用的是 Pisces Scheme ，但还是做了一些修改，因为原来那个宽度太小了，不适合展示代码块，也不太美观。修改方法如下：Pisces 的布局定义在 source/css/_schemes/Picses/_layout.styl 中，打开文件并在最后添加以下 css引用自 http://www.aidansu.com/2017/github-pages-build-blog/ .header{ width: 80%; +tablet() { width: 100%; } +mobile() { width: 100%; } } .container .main-inner { width: 80%; +tablet() { width: 100%; } +mobile() { width: 100%; } } .content-wrap { width: calc(100% - 260px); +tablet() { width: 100%; } +mobile() { width: 100%; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Notes","slug":"Notes","permalink":"http://zhoudamin.github.io/categories/Notes/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoudamin.github.io/tags/Hexo/"}]},{"title":"Java 运动模糊","slug":"Java-运动模糊","date":"2018-04-23T12:41:58.000Z","updated":"2018-04-23T14:32:38.495Z","comments":true,"path":"2018/04/23/java-yun-dong-mo-hu/","link":"","permalink":"http://zhoudamin.github.io/2018/04/23/java-yun-dong-mo-hu/","excerpt":"想用Java 写个运动模糊的效果，无奈本人水平有限，国内也没找到资源，于是Google到了一个文档，特地分享出来！","text":"想用Java 写个运动模糊的效果，无奈本人水平有限，国内也没找到资源，于是Google到了一个文档，特地分享出来！ 本代码源自 http://www.jhlabs.com/ip/blurring.html Java运动模糊算法： import java.awt.*; import java.awt.geom.*; import java.awt.image.*; public class MotionBlurOp extends AbstractBufferedImageOp { private float centreX = 0.5f, centreY = 0.5f; private float distance=20.0f; //这里设置运动距离 private float angle; private float rotation; private float zoom; public MotionBlurOp() { } public MotionBlurOp( float distance, float angle, float rotation, float zoom ) { this.distance = distance; this.angle = angle; this.rotation = rotation; this.zoom = zoom; } public void setAngle( float angle ) { this.angle = angle; } public float getAngle() { return angle; } public void setDistance( float distance ) { this.distance = distance; } public float getDistance() { return distance; } public void setRotation( float rotation ) { this.rotation = rotation; } public float getRotation() { return rotation; } public void setZoom( float zoom ) { this.zoom = zoom; } public float getZoom() { return zoom; } public void setCentreX( float centreX ) { this.centreX = centreX; } public float getCentreX() { return centreX; } public void setCentreY( float centreY ) { this.centreY = centreY; } public float getCentreY() { return centreY; } public void setCentre( Point2D centre ) { this.centreX = (float)centre.getX(); this.centreY = (float)centre.getY(); } public Point2D getCentre() { return new Point2D.Float( centreX, centreY ); } private int log2( int n ) { int m = 1; int log2n = 0; while (m &lt; n) { m *= 2; log2n++; } return log2n; } public BufferedImage filter( BufferedImage src, BufferedImage dst ) { if ( dst == null ) dst = createCompatibleDestImage( src, null ); BufferedImage tsrc = src; float cx = (float)src.getWidth() * centreX; float cy = (float)src.getHeight() * centreY; float imageRadius = (float)Math.sqrt( cx*cx + cy*cy ); float translateX = (float)(distance * Math.cos( angle )); float translateY = (float)(distance * -Math.sin( angle )); float scale = zoom; float rotate = rotation; float maxDistance = distance + Math.abs(rotation*imageRadius) + zoom*imageRadius; int steps = log2((int)maxDistance); translateX /= maxDistance; translateY /= maxDistance; scale /= maxDistance; rotate /= maxDistance; if ( steps == 0 ) { Graphics2D g = dst.createGraphics(); g.drawRenderedImage( src, null ); g.dispose(); return dst; } BufferedImage tmp = createCompatibleDestImage( src, null ); for ( int i = 0; i &lt; steps; i++ ) { Graphics2D g = tmp.createGraphics(); g.drawImage( tsrc, null, null ); g.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g.setRenderingHint( RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR ); g.setComposite( AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 0.5f ) ); g.translate( cx+translateX, cy+translateY ); g.scale( 1.0001+scale, 1.0001+scale ); // The .0001 works round a bug on Windows where drawImage throws an ArrayIndexOutofBoundException if ( rotation != 0 ) g.rotate( rotate ); g.translate( -cx, -cy ); g.drawImage( dst, null, null ); g.dispose(); BufferedImage ti = dst; dst = tmp; tmp = ti; tsrc = dst; translateX *= 2; translateY *= 2; scale *= 2; rotate *= 2; } return dst; } public String toString() { return \"Blur/Motion Blur...\"; } }测试代码： import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; /** * Created by zdmein on 2018/1/10. */ public class MotionBlurOpTest { public static void main(String [] args) throws IOException { BufferedImage sourceImage = ImageIO.read(new File(\"flower.jpg\")); MotionBlurOp filter=new MotionBlurOp(); BufferedImage destImage=filter.filter(sourceImage,null); ImageIO.write(destImage, \"PNG\", new File(\"MotionBlurOpflower.jpg\")); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"图像","slug":"图像","permalink":"http://zhoudamin.github.io/categories/%E5%9B%BE%E5%83%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"优秀博主整理","slug":"优秀博主整理","date":"2017-09-12T01:59:40.000Z","updated":"2018-04-23T15:50:59.749Z","comments":true,"path":"2017/09/12/you-xiu-bo-zhu-zheng-li/","link":"","permalink":"http://zhoudamin.github.io/2017/09/12/you-xiu-bo-zhu-zheng-li/","excerpt":"优秀博主整理","text":"优秀博主整理 Name Introduction 纯洁的微笑 资深码农博主，对Spring框架的总结非常不错，现在在一家互联网金融公司做技术经理兼技术负责人 Raysmond 复旦的计算机研究生，现在在北京工作，生活很精彩，工程能力也非常强，看到他在与我同龄时写的一些代码，非常佩服 Yikun 西电毕业的通信领域研究生，去年好像去了菊厂，手绘很棒，生活也很精彩，也是个技术牛人 酷壳 耗子叔，业内知名博主，每一篇博文都是经典，15年开发经验的老码农，曾在Amazon，阿里等处做过资深专家 王之琳 12年本科毕业前端交互工程师，能力很强，简历很炫，写的项目非常多，也特别喜欢逛各种论坛 litten 毕业于华科的前端工程师，非常文青，我这个博客主题就是他写的，现在鹅厂工作 Oilbeater 北大毕业的研究生，曾在阿里任职，现在灵雀云搞Docker，挺有想法的人 羡辙 毕业于上交的研究生，现在是一个非常出色的前端工程师，目前在百度ECharts团队做可视化的相关工作。博客非常有特点，博文质量很高，而且GITHUB的Follower高达4k DIYgod 15年毕业的前端工程师，非常二次元，博客也很另类，个人能力也是很强的，喜欢玩GITHUB很棒，也是掘金的联合小编 龙哥盟 16年毕业于上交，项目经验很丰富，而且非常喜欢搞各种教程，GITHUB的Follower也很多 闵聪 17年毕业于重邮，项目和实习经验都很丰富，现在似乎去了鹅厂 byvoid 牛x的大佬，搞NOIP进的清华，能力超强，奇闻逸事网上流传了很多，最有名的大概就是报阿里星时候的评价表。。。 谢益辉 在美帝工作的经济学PhD,双语博客从05年更到现在，文笔也牛的不行，现在在RStudio做软件工程师 MartinRGB 13年西电毕业的交互设计师以及GUI设计师，看了眼博客，没啥说的，不愧是设计师。。。 魏楚阳 18年毕业的华科研究生，webporter的开发者，爬虫和数据分析的高端玩家，BAT随便进。。。 VoidKing 16级东北师大的软件工程硕士研究生，是个很勤奋的博主，有梦想有想法。 颜开 对Java以及分布式数据库等有着非常深厚的积淀，现在任职于EMC，可惜的是博客不怎么更了 李钊 东北大学14级同届本科，能力很强，现在百度深度学习实验室。 马壮 努力高产的全栈工程师 孔令贤 11年硕士毕业，前华为 OpenStack 社区开发部技术经理，从14级破格提拔至17级，任总在总裁令中点名致歉的员工，在技术和管理的岔路口迷茫过，博客中也记录了职场中很多心路历程。现在已技术移民新西兰 余舜哲 同龄的同学，现在在多伦多大学留学，对新技术有很大的热情，很不错的博客 aneasystone 80后码农一枚。喜欢开源，喜欢读书，喜欢折腾，方向是偏信息安全的，目前应该转了java Zhisheng Tian 同一届的同学，学习的能力跟写作的条理都非常清楚，基础功很扎实，也是非常值得学习 翟永超 《Spring Cloud 微服务实战》一书作者，对Spring全家桶和微服务架构有着很深刻的理解 赵伊凡 比较喜欢总结知识的90后码农，好像写了本书叫《轻松学算法》 小草窝 很小就开始写代码的博主，自己写的emlog框架，比较喜欢搞网站安全 王爵 blade框架的作者，维护了很多开源项目，用blade写的Tale博客框架也挺不错的 并发编程网 阿里系的一帮大牛创的技术网站 aidan 雄哥的博客 云风的 BLOG 总是读成风云… 阮一峰的网络日志 非常佩服的一位，非常勤，特别能坚持 老赵 赵百万的博客 闵聪 腾讯的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Life","slug":"Life","permalink":"http://zhoudamin.github.io/categories/Life/"}],"tags":[{"name":"博主","slug":"博主","permalink":"http://zhoudamin.github.io/tags/%E5%8D%9A%E4%B8%BB/"}]},{"title":"常用数据结构底层实现及源码","slug":"常用数据结构底层实现及源码","date":"2017-09-12T01:59:40.000Z","updated":"2018-04-23T02:27:20.062Z","comments":true,"path":"2017/09/12/chang-yong-shu-ju-jie-gou-di-ceng-shi-xian-ji-yuan-ma/","link":"","permalink":"http://zhoudamin.github.io/2017/09/12/chang-yong-shu-ju-jie-gou-di-ceng-shi-xian-ji-yuan-ma/","excerpt":"ZDM–ArrayList、HashMap、Collection、LinkedList、Redis 底层实现及源码","text":"ZDM–ArrayList、HashMap、Collection、LinkedList、Redis 底层实现及源码 RedisRedis简介Redis是一种key/value型数据库，其中，每个key和value都是使用对象表示的。 SET message \"Hello\" 其中，字符串 “message” 这个对象 就是 key ， “Hello” 这个对象 就是 value Redis有5种对象的类型 类型常量 小写 对象名称 REDIS_STRING string 字符串对象 REDIS_LIST list 列表对象 REDIS_HASH hash 哈希对象 REDIS_SET set 集合对象 REDIS_ZSET zset 有序集合对象 Redis对象底层数据结构 编码常量 数据结构 int long类型的整数 embstr embstr编码的简单动态字符串 raw 简单动态字符串 ht 字典 linkedlist 双端链表 ziplist 压缩列表 intset 整数集合 skiplist 跳跃表和字典 字符串对象字符串对象的编码可以是int、raw、embstr 如果字符串对象的长度小于39字节，就用embstr 否则用传统的raw对象 # define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39 robj *createStringObject(char *ptr, size_t len) { if (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len); } embstr的优点： 创建只需分配一次内存，raw为两次 释放内存也是一次 embstr的objet和sds放在一起，更好地利用缓存带来的优势 列表对象列表对象的编码可以是 ziplist or LinkedList ziplist 是一种压缩链表，好处是更能节省内存空间，存储的内容都是在连续的内存区域中的 LinkedList是一种双向链表，没增加一个node，都要重新分配一个内存 哈希对象哈希对象的底层实现用ziplist or hashtable ziplist : 对象数目不多且内容不大，这种方式效率很高 HashTable由dict这个结构实现 集合对象集合对象编码可以是 intset or HashTable 有序集合对象编码一种是 ziplist ，一种是skipList 与 dict 的结合 ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score从小到大顺序排列。它的结构不再复述。 skiplist是一种跳跃表，它实现了有序集合中的快速查找，在大多数情况下它的速度都可以和平衡树差不多。但它的实现比较简单，可以作为平衡树的替代品。 ArrayListArrayList是基于数组实现的，是一个动态数组，其容量能自动增长(1.5+1)。 非线程安全 源码： package java.util; public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable { // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // ArrayList基于该数组实现，用该数组保存数据 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; } // ArrayList无参构造函数。默认容量是10。 public ArrayList() { this(10); } // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E> c) { elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } // 将当前容量值设为实际元素个数 public void trimToSize() { modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) { elementData = Arrays.copyOf(elementData, size); } } // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) { // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity > oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; //如果还不够，则直接将minCapacity设置为当前容量 if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); } } // 添加元素e public boolean add(E e) { // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; } // 返回ArrayList的实际大小 public int size() { return size; } // ArrayList是否包含Object(o) public boolean contains(Object o) { return indexOf(o) >= 0; } //返回ArrayList是否为空 public boolean isEmpty() { return size == 0; } // 正向查找，返回元素的索引值 public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i >= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } // 返回ArrayList的Object数组 public Object[] toArray() { return Arrays.copyOf(elementData, size); } // 返回ArrayList元素组成的数组 public &lt;T> T[] toArray(T[] a) { // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 >= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length > size) a[size] = null; return a; } // 获取index位置的元素值 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } // 设置index位置的值为element public E set(int index, E element) { RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; } // 将e添加到ArrayList中 public boolean add(E e) { ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 将e添加到ArrayList的指定位置 public void add(int index, E element) { if (index > size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // 删除ArrayList指定位置的元素 public E remove(int index) { RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; } // 删除ArrayList的指定元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 快速删除第index个元素 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; // 从\"index+1\"开始，用后面的元素替换前面的元素。 if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work } // 删除元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 清空ArrayList，将全部的元素设为null public void clear() { modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E> c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E> c) { if (index > size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \" + index + \", Size: \" + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; } private void RangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); } // 克隆函数 public Object clone() { try { ArrayList&lt;E> v = (ArrayList&lt;E>) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(); } } // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); } } HashMapHashMap是基于哈希表实现，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足时，会自动增长。 非线程安全，只是用于单线程环境下，多线程用concurrentHashMap 实现了Serializable接口，因此支持序列化，实现了Cloneable接口，能被克隆。 源码： package java.util; import java.io.*; public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable { // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的底层数组中已用槽的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因此不能小于0 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 默认构造函数。 public HashMap() { // 设置“加载因子”为默认加载因子0.75 this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); } // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V> m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); } //求hash值的方法，重新计算hash值 static int hash(int h) { h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) { return h &amp; (length-1); } public int size() { return size; } public boolean isEmpty() { return size == 0; } // 获取key对应的value public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; //判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } //没找到则返回null return null; } // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() { for (Entry&lt;K,V> e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } // HashMap是否包含key public boolean containsKey(Object key) { return getEntry(key) != null; } // 返回“键为key”的键值对 final Entry&lt;K,V> getEntry(Object key) { // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; } // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; //将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; } // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) { for (Entry&lt;K,V> e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 如果没有存在key为null的键值对，则直接题阿见到table[0]处! modCount++; addEntry(0, null, value, 0); return null; } // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) { int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { e.value = value; return; } } // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); } // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V> m) { // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V> e = i.next(); putForCreate(e.getKey(), e.getValue()); } } // 重新调整HashMap的大小，newCapacity是调整后的容量 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果就容量已经达到了最大值，则不能再扩容，直接返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { Entry&lt;K,V> e = src[j]; if (e != null) { src[j] = null; do { Entry&lt;K,V> next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } // 将\"m\"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V> m) { // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded > threshold) { int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity > MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity > table.length) resize(newCapacity); } // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V> e = i.next(); put(e.getKey(), e.getValue()); } } // 删除“键为key”元素 public V remove(Object key) { Entry&lt;K,V> e = removeEntryForKey(key); return (e == null ? null : e.value); } // 删除“键为key”的元素 final Entry&lt;K,V> removeEntryForKey(Object key) { // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V> prev = table[i]; Entry&lt;K,V> e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V> next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 删除“键值对” final Entry&lt;K,V> removeMapping(Object o) { if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V> entry = (Map.Entry&lt;K,V>) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V> prev = table[i]; Entry&lt;K,V> e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V> next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 清空HashMap，将所有的元素设为null public void clear() { modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; } // 是否包含“值为value”的元素 public boolean containsValue(Object value) { // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; } // 是否包含null值 private boolean containsNullValue() { Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; } // 克隆一个HashMap，并返回Object对象 public Object clone() { HashMap&lt;K,V> result = null; try { result = (HashMap&lt;K,V>)super.clone(); } catch (CloneNotSupportedException e) { // assert false; } result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; } // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V> implements Map.Entry&lt;K,V> { final K key; V value; // 指向下一个节点 Entry&lt;K,V> next; final int hash; // 构造函数。 // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\" Entry(int h, K k, V v, Entry&lt;K,V> n) { value = v; next = n; key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; } return false; } // 实现hashCode() public final int hashCode() { return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); } public final String toString() { return getKey() + \"=\" + getValue(); } // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V> m) { } // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V> m) { } } // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V> e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V>(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ >= threshold) resize(2 * table.length); } // 创建Entry。将“key-value”插入指定位置。 void createEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V> e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V>(hash, key, value, e); size++; } // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E> implements Iterator&lt;E> { // 下一个元素 Entry&lt;K,V> next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V> current; HashIterator() { expectedModCount = modCount; if (size > 0) { // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } // 获取下一个元素 final Entry&lt;K,V> nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V> e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } current = e; return e; } // 删除当前元素 public void remove() { if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; } } // value的迭代器 private final class ValueIterator extends HashIterator&lt;V> { public V next() { return nextEntry().value; } } // key的迭代器 private final class KeyIterator extends HashIterator&lt;K> { public K next() { return nextEntry().getKey(); } } // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V>> { public Map.Entry&lt;K,V> next() { return nextEntry(); } } // 返回一个“key迭代器” Iterator&lt;K> newKeyIterator() { return new KeyIterator(); } // 返回一个“value迭代器” Iterator&lt;V> newValueIterator() { return new ValueIterator(); } // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V>> newEntryIterator() { return new EntryIterator(); } // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V>> entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K> keySet() { Set&lt;K> ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); } // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K> { public Iterator&lt;K> iterator() { return newKeyIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return HashMap.this.removeEntryForKey(o) != null; } public void clear() { HashMap.this.clear(); } } // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V> values() { Collection&lt;V> vs = values; return (vs != null ? vs : (values = new Values())); } // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V> { public Iterator&lt;V> iterator() { return newValueIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsValue(o); } public void clear() { HashMap.this.clear(); } } // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V>> entrySet() { return entrySet0(); } // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V>> entrySet0() { Set&lt;Map.Entry&lt;K,V>> es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V>> { public Iterator&lt;Map.Entry&lt;K,V>> iterator() { return newEntryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V> e = (Map.Entry&lt;K,V>) o; Entry&lt;K,V> candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); } public boolean remove(Object o) { return removeMapping(o) != null; } public int size() { return size; } public void clear() { HashMap.this.clear(); } } // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Iterator&lt;Map.Entry&lt;K,V>> i = (size > 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) { while (i.hasNext()) { Map.Entry&lt;K,V> e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } } private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) { K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); } } // 返回“HashMap总的容量” int capacity() { return table.length; } // 返回“HashMap的加载因子” float loadFactor() { return loadFactor; } } HashTable基于哈希表实现，每个元素都是key-value对，内部通过单链表解决冲突问题，容量不足时，自动增长 是线程安全的，能用于多线程 实现了Serializable接口，支持序列号 实现了Cloneable接口，能被克隆 package java.util; import java.io.*; public class Hashtable extends Dictionary implements Map, Cloneable, java.io.Serializable { // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); if (loadFactor >> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } } else { return k.hashCode(); } } public synchronized int size() { return count; } public synchronized boolean isEmpty() { return count == 0; } // 返回“所有key”的枚举对象 public synchronized Enumeration keys() { return this.getEnumeration(KEYS); } // 返回“所有value”的枚举对象 public synchronized Enumeration elements() { return this.getEnumeration(VALUES); } // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) { //注意，Hashtable中的value不能是null， // 若是null的话，抛出异常! if (value == null) { throw new NullPointerException(); } // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- > 0 ;) { for (Entry e = tab[i] ; e != null ; e = e.next) { if (e.value.equals(value)) { return true; } } } return false; } public boolean containsValue(Object value) { return contains(value); } // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) { Entry tab[] = table; //计算hash值，直接用key的hashCode代替 int hash = key.hashCode(); // 计算在数组中的索引值 int index = (hash & 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { return true; } } return false; } // 返回key对应的value，没有的话返回null public synchronized V get(Object key) { Entry tab[] = table; int hash = hash(key); // 计算索引值， int index = (hash & 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { return e.value; } } return null; } // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() { int oldCapacity = table.length; Entry[] oldMap = table; //创建新容量大小的Entry数组 int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; //将“旧的Hashtable”中的元素复制到“新的Hashtable”中 for (int i = oldCapacity ; i-- > 0 ;) { for (Entry old = oldMap[i] ; old != null ; ) { Entry e = old; old = old.next; //重新计算index int index = (e.hash & 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; } } } // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // 将“修改统计数”+1 modCount++; // 若“Hashtable实际容量” > “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count >= threshold) { rehash(); tab = table; index = (hash & 0x7FFFFFFF) % tab.length; } //将新的key-value对插入到tab[index]处（即链表的头结点） Entry e = tab[index]; tab[index] = new Entry(hash, key, value, e); count++; return null; } // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) { Entry tab[] = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; //从table[index]链表中找出要删除的节点，并删除该节点。 //因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点 for (Entry e = tab[index], prev = null ; e != null ; prev = e, e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { modCount++; if (prev != null) { prev.next = e.next; } else { tab[index] = e.next; } count--; V oldValue = e.value; e.value = null; return oldValue; } } return null; } // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map t) { for (Map.Entry e : t.entrySet()) put(e.getKey(), e.getValue()); } // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() { Entry tab[] = table; modCount++; for (int index = tab.length; --index >= 0; ) tab[index] = null; count = 0; } // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() { try { Hashtable t = (Hashtable) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- > 0 ; ) { t.table[i] = (table[i] != null) ? (Entry) table[i].clone() : null; } t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; } catch (CloneNotSupportedException e) { throw new InternalError(); } } public synchronized String toString() { int max = size() - 1; if (max == -1) return \"{}\"; StringBuilder sb = new StringBuilder(); Iterator it = entrySet().iterator(); sb.append('{'); for (int i = 0; ; i++) { Map.Entry e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? \"(this Map)\" : key.toString()); sb.append('='); sb.append(value == this ? \"(this Map)\" : value.toString()); if (i == max) return sb.append('}').toString(); sb.append(\", \"); } } // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private Enumeration getEnumeration(int type) { if (count == 0) { return (Enumeration)emptyEnumerator; } else { return new Enumerator(type, false); } } // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private Iterator getIterator(int type) { if (count == 0) { return (Iterator) emptyIterator; } else { return new Enumerator(type, true); } } // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set keySet() { if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; } // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet { public Iterator iterator() { return getIterator(KEYS); } public int size() { return count; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return Hashtable.this.remove(o) != null; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set entrySet() { if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; } // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet { public Iterator iterator() { return getIterator(ENTRIES); } public boolean add(Map.Entry o) { return super.add(o); } // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash && e.equals(entry)) return true; return false; } // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e.hash==hash && e.equals(entry)) { modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; } } return false; } public int size() { return count; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection values() { if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; } // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection { public Iterator iterator() { return getIterator(VALUES); } public int size() { return count; } public boolean contains(Object o) { return containsValue(o); } public void clear() { Hashtable.this.clear(); } } // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map t = (Map) o; if (t.size() != size()) return false; try { // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator i = entrySet().iterator(); while (i.hasNext()) { Map.Entry e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(t.get(key)==null && t.containsKey(key))) return false; } else { if (!value.equals(t.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子 0 && length > origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements > 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } this.table = table; } private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } // Creates the new entry. Entry e = tab[index]; tab[index] = new Entry(hash, key, value, e); count++; } // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry implements Map.Entry { // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry next; // 构造函数 protected Entry(int hash, K key, V value, Entry next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } protected Object clone() { return new Entry(hash, key, value, (next==null ? null : (Entry) next.clone())); } public K getKey() { return key; } public V getValue() { return value; } // 设置value。若value是null，则抛出异常。 public V setValue(V value) { if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; } // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) && (value==null ? e.getValue()==null : value.equals(e.getValue())); } public int hashCode() { return hash ^ (value==null ? 0 : value.hashCode()); } public String toString() { return key.toString()+\"=\"+value.toString(); } } private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator implements Enumeration, Iterator { // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry entry = null; Entry lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) { this.type = type; this.iterator = iterator; } // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() { Entry e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null && i > 0) { e = t[--i]; } entry = e; index = i; return e != null; } // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() { Entry et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null && i > 0) { et = t[--i]; } entry = et; index = i; if (et != null) { Entry e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); } throw new NoSuchElementException(\"Hashtable Enumerator\"); } // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() { return hasMoreElements(); } // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); } // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() { if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(\"Hashtable Enumerator\"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) { Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e == lastReturned) { modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; } } throw new ConcurrentModificationException(); } } } private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration { EmptyEnumerator() { } // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() { return false; } // 空枚举类的nextElement() 抛出异常 public Object nextElement() { throw new NoSuchElementException(\"Hashtable Enumerator\"); } } // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator { EmptyIterator() { } public boolean hasNext() { return false; } public Object next() { throw new NoSuchElementException(\"Hashtable Iterator\"); } public void remove() { throw new IllegalStateException(\"Hashtable Iterator\"); } } } Collection是最基本的集合接口 继承的接口：Iterable 子接口：List、Set、Queue等 遍历Collection中的每一个元素 它支持一个Iterator()方法，该方法返回一个迭代子，该迭代子可逐一访问Collection中每一个元素 Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) { Object obj = it.next(); // 得到下一个元素 } 方法： retainAll(Collection&lt;?extends E>c); //保留，交运算 addAll(Collection&lt;?extends E>c); //添加，并运算 removeAll(Collection&lt;?extends E>c); //移除，减运算 LinkedListLinkedList是基于双向循环链表实现的，除了可以当作链表来操作外，它还可以当作栈、队列和双端队列来使用。 非线程安全，单线程下使用 LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 是一个类 实现的接口：List、Collection、Iterable、Serializable、Cloneable、Deque，Queue 子类：没有子类 添加元素方法： boolean add(E e) 添加到链表末尾 void add(int index, E e) 添加到指定位置 boolean addAll(int index, Collection&lt;? extends E&gt; c) boolean addAll(Collection&lt;? extends E&gt; c) package java.util; public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>, Cloneable, java.io.Serializable { // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E> header = new Entry&lt;E>(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() { header.next = header.previous = header; } // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E> c) { this(); addAll(c); } // 获取LinkedList的第一个元素 public E getFirst() { if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; } // 获取LinkedList的最后一个元素 public E getLast() { if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; } // 删除LinkedList的第一个元素 public E removeFirst() { return remove(header.next); } // 删除LinkedList的最后一个元素 public E removeLast() { return remove(header.previous); } // 将元素添加到LinkedList的起始位置 public void addFirst(E e) { addBefore(e, header.next); } // 将元素添加到LinkedList的结束位置 public void addLast(E e) { addBefore(e, header); } // 判断LinkedList是否包含元素(o) public boolean contains(Object o) { return indexOf(o) != -1; } // 返回LinkedList的大小 public int size() { return size; } // 将元素(E)添加到LinkedList中 public boolean add(E e) { // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; } // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) { if (o==null) { // 若o为null的删除情况 for (Entry&lt;E> e = header.next; e != header; e = e.next) { if (e.element==null) { remove(e); return true; } } } else { // 若o不为null的删除情况 for (Entry&lt;E> e = header.next; e != header; e = e.next) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E> c) { return addAll(size, c); } // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E> c) { if (index &lt; 0 || index > size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E> successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E> predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) { Entry&lt;E> e = new Entry&lt;E>((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; } successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; } // 清空双向链表 public void clear() { Entry&lt;E> e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) { Entry&lt;E> next = e.next; e.next = e.previous = null; e.element = null; e = next; } header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; } // 返回LinkedList指定位置的元素 public E get(int index) { return entry(index).element; } // 设置index位置对应的节点的值为element public E set(int index, E element) { Entry&lt;E> e = entry(index); E oldVal = e.element; e.element = element; return oldVal; } // 在index前添加节点，且节点的值为element public void add(int index, E element) { addBefore(element, (index==size ? header : entry(index))); } // 删除index位置的节点 public E remove(int index) { return remove(entry(index)); } // 获取双向链表中指定位置的节点 private Entry&lt;E> entry(int index) { if (index &lt; 0 || index >= size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Entry&lt;E> e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size >> 1)) { for (int i = 0; i &lt;= index; i++) e = e.next; } else { for (int i = size; i > index; i--) e = e.previous; } return e; } // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) { int index = 0; if (o==null) { for (Entry e = header.next; e != header; e = e.next) { if (e.element==null) return index; index++; } } else { for (Entry e = header.next; e != header; e = e.next) { if (o.equals(e.element)) return index; index++; } } return -1; } // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) { int index = size; if (o==null) { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (e.element==null) return index; } } else { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (o.equals(e.element)) return index; } } return -1; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() { if (size==0) return null; return getFirst(); } // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() { return getFirst(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() { if (size==0) return null; return removeFirst(); } // 将e添加双向链表末尾 public boolean offer(E e) { return add(e); } // 将e添加双向链表开头 public boolean offerFirst(E e) { addFirst(e); return true; } // 将e添加双向链表末尾 public boolean offerLast(E e) { addLast(e); return true; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() { if (size==0) return null; return getFirst(); } // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() { if (size==0) return null; return getLast(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() { if (size==0) return null; return removeFirst(); } // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() { if (size==0) return null; return removeLast(); } // 将e插入到双向链表开头 public void push(E e) { addFirst(e); } // 删除并返回第一个节点 public E pop() { return removeFirst(); } // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) { return remove(o); } // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) { if (o==null) { for (Entry&lt;E> e = header.previous; e != header; e = e.previous) { if (e.element==null) { remove(e); return true; } } } else { for (Entry&lt;E> e = header.previous; e != header; e = e.previous) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E> listIterator(int index) { return new ListItr(index); } // List迭代器 private class ListItr implements ListIterator&lt;E> { // 上一次返回的节点 private Entry&lt;E> lastReturned = header; // 下一个节点 private Entry&lt;E> next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) { // index的有效性处理 if (index &lt; 0 || index > size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size >> 1)) { next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; } else { next = header; for (nextIndex=size; nextIndex>index; nextIndex--) next = next.previous; } } // 是否存在下一个元素 public boolean hasNext() { // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; } // 获取下一个元素 public E next() { checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; } // 是否存在上一个元素 public boolean hasPrevious() { // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; } // 获取上一个元素 public E previous() { if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; } // 获取下一个元素的索引 public int nextIndex() { return nextIndex; } // 获取上一个元素的索引 public int previousIndex() { return nextIndex-1; } // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() { checkForComodification(); Entry&lt;E> lastNext = lastReturned.next; try { LinkedList.this.remove(lastReturned); } catch (NoSuchElementException e) { throw new IllegalStateException(); } if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; } // 设置当前节点为e public void set(E e) { if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; } // 将e添加到当前节点的前面 public void add(E e) { checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; } // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E> { // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E> next; // 上一个节点 Entry&lt;E> previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E> next, Entry&lt;E> previous) { this.element = element; this.next = next; this.previous = previous; } } // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E> addBefore(E e, Entry&lt;E> entry) { // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E> newEntry = new Entry&lt;E>(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; } // 将节点从链表中删除 private E remove(Entry&lt;E> e) { if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; } // 反向迭代器 public Iterator&lt;E> descendingIterator() { return new DescendingIterator(); } // 反向迭代器实现类。 private class DescendingIterator implements Iterator { final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() { return itr.hasPrevious(); } // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() { return itr.previous(); } // 删除当前节点 public void remove() { itr.remove(); } } // 返回LinkedList的Object[]数组 public Object[] toArray() { // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E> e = header.next; e != header; e = e.next) result[i++] = e.element; return result; } // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T> T[] toArray(T[] a) { // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E> e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length > size) a[size] = null; return a; } // 克隆函数。返回LinkedList的克隆对象。 public Object clone() { LinkedList&lt;E> clone = null; // 克隆一个LinkedList克隆对象 try { clone = (LinkedList&lt;E>) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } // 新建LinkedList表头节点 clone.header = new Entry&lt;E>(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E> e = header.next; e != header; e = e.next) clone.add(e.element); return clone; } // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); } // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E>(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhoudamin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhoudamin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码","slug":"源码","permalink":"http://zhoudamin.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"读书笔记之《程序员代码面试指南（字符串问题）》","slug":"读书笔记之《程序员代码面试指南（字符串问题）》","date":"2017-09-01T02:27:05.000Z","updated":"2018-08-03T14:54:45.413Z","comments":true,"path":"2017/09/01/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zi-fu-chuan-wen-ti/","link":"","permalink":"http://zhoudamin.github.io/2017/09/01/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zi-fu-chuan-wen-ti/","excerpt":"字符串问题也是老生常谈的算法问题，该书罗列的字符串问题以我做算法的经验来看，都是很好的题。 代码 Github 地址","text":"字符串问题也是老生常谈的算法问题，该书罗列的字符串问题以我做算法的经验来看，都是很好的题。 代码 Github 地址 判断两个字符串是否互为变形词给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。str1=”123”,str2=”231”,返回true。str1=”123”,str2=”2331”,返回false。 先判断长度是不是一致 再用一个长度为256的数组标记，一个加，一个减。最后看是不是互抵了。 package String; /** * Created by zdmein on 2017/9/1. * 判断两个字符串是否互为变形词 * 给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样， * 那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。 str1=\"123\",str2=\"231\",返回true。 str1=\"123\",str2=\"2331\",返回false。 */ public class isDeformation1 { public static void main(String args []){ String str1=\"54s6\"; String str2=\"465d\"; System.out.println(isDeformation(str1,str2)); } public static boolean isDeformation(String str1 ,String str2){ if(str1.length()!=str2.length()){ return false; } int res[]=new int [256]; int index=0; while (index!=str1.length()){ res[str1.charAt(index)]++; res[str2.charAt(index++)]--; } for(int i=0;i&lt;256;i++){ if(res[i]!=0){ return false; } } return true; } } 字符串的调整与替换 *把 “a b c” 替换后为 “a%20b%20%20c” 开辟空间，从尾部遍历替换到头部 package String; /** * Created by zdmein on 2017/9/1. * 字符串的调整与替换 *把 \"a b c\" 替换后为 “a%20b%20%20c” */ public class replace1 { public static void main(String [] args ){ String str=\"a b c\"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++){ chas[i]=str.charAt(i); } replace(chas); } public static void replace(char [] chas){ int len=0; int num=0; for(;len&lt;chas.length &amp;&amp; chas[len]!=0;len++){ if(chas[len]==' '){ num++; } } int index=len+num*2; for(;index>=0;index--){ if (chas[len--]==' '){ chas[index--]='0'; chas[index--]='2'; chas[index]='%'; }else { chas[index]=chas[len+1]; } } System.out.println(chas); } } 扩展： 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 package String; /** * Created by zdmein on 2017/9/1. * 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 */ public class replace2 { public static void main(String [] args ){ String str=\"12**35\"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++){ chas[i]=str.charAt(i); } modify(chas); } public static void modify(char [] chas){ if(chas==null||chas.length==0){ return; } int j=chas.length-1; for(int i=chas.length-1;i>=0;i--){ if(chas[i]!='*'){ chas[j--]=chas[i]; } } for(;j>=0;j--){ chas[j]='*'; } System.out.println(chas); } } 翻转字符串写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 写个函数，先整体翻转一次，然后再每个单词翻转一次。easy！ package String; /** * Created by zdmein on 2017/9/2. * 翻转字符串 * 写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 */ public class rotateWord1 { public static void main(String [] args){ String str= \"dogs love pig.\"; rotateWord(str); } public static void rotateWord(String str){ if(str==null||str.length()==0){ return ; } char [] strArr = str.toCharArray(); reverse(strArr,0,strArr.length-1); int index=0; for(int i=0;i&lt;strArr.length;i++){ if(strArr[i]==' '){ reverse(strArr,index,i-1); index=i+1; } } reverse(strArr,index,strArr.length-1); System.out.println(strArr); } public static void reverse(char[] strArr ,int first ,int end){ while (first&lt;end){ char tmp=strArr[first]; strArr[first]=strArr[end]; strArr[end]=tmp; first++; end--; } } } 数组中两个字符串的最小距离 Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1. 用2个下标指向2个字符串，跟新位置，互相减，然后Math.min取小的。 package String; /** * Created by zdmein on 2017/9/3. * 数组中两个字符串的最小距离 *Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]. * Given word1 = “coding”, word2 = “practice”, return 3. * Given word1 = \"makes\", word2 = \"coding\", return 1. */ public class minDistance1 { public static void main(String args[]){ String [] strs ={\"1\",\"3\",\"3\",\"3\",\"2\",\"3\",\"1\"}; String str1=\"1\"; String str2=\"2\"; minDistance(strs,str1,str2); } public static void minDistance(String[] strs,String str1 , String str2){ if(strs==null||strs.length==0||str1==null||str2==null){ return; } int index1=-1; int index2=-1; int min=Integer.MAX_VALUE; for(int i=0;i&lt;strs.length;i++){ if(strs[i]==str1){ index1=i; if(index2!=-1){ min=Math.min(min,index1-index2); } }else if(strs[i]==str2){ index2=i; if(index1!=-1){ min=Math.min(min,index2-index1); } } } // if(min!=Integer.MAX_VALUE){ System.out.println(min); }else { System.out.println(-1); } //上面这个渣渣代码可以这样写： // min==Integer.MAX_VALUE ? -1 : min; } } 替换字符串中连续出现的指定字符串题目：给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。举例：str=”123abc”，from=”abc”，to=”4567”，返回”1234567”；str=”123”，from=”abc”，to=”4567”，返回”123”；str=”123abcabc”，from=”abc”，to=”X”，返回”123X”； 思路： 把from匹配的字符，设为0，然后把0的部分全部替换掉成to，就好了 package String; /** * Created by zdmein on 2017/9/4. * 替换字符串中连续出现的指定字符串 题目： 给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。 举例： str=\"123abc\"，from=\"abc\"，to=\"4567\"，返回\"1234567\"； str=\"123\"，from=\"abc\"，to=\"4567\"，返回\"123\"； str=\"123abcabc\"，from=\"abc\"，to=\"X\"，返回\"123X\"； */ public class replace3 { public static void main(String args[]){ String str=\"123abcabc\"; String from=\"abc\"; String to = \"4567\"; System.out.println(replace(str,from,to)); } private static String replace(String str,String from ,String to){ if(str==null||from==\"\"||to==\"\"){ return str; } char[] chstr=str.toCharArray(); char[] chfrom=from.toCharArray(); int match=0; for(int i=0;i&lt;str.length();i++){ if(chstr[i]==chfrom[match++]){ if(match==chfrom.length){ clear(chstr,i,chfrom.length); match=0; } }else { match=0; } } String res=\"\"; for(int i=0;i&lt;chstr.length;i++){ if(chstr[i]!=0){ while (chstr[i]!=0){ res+=chstr[i++]; } } if(chstr[i]==0){ while (i!=chstr.length&amp;&amp;chstr[i]==0){ i++; } res+=to; i--; } } return res; } private static void clear(char[] chstr , int end ,int len){ while(len--!=0){ chstr[end--]=0; } } } 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 先记录a，然后一项一项对比记录 String.valueof()的使用 package String; /** * Created by zdmein on 2017/9/5. * 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率 输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 */ public class getCountString1 { public static void main(String [] args){ String str=\"aaabbadddffc\"; System.out.println(getCountString(str)); } private static String getCountString(String str){ if(str==null||str.length()==0){ return \"\"; } char [] chs=str.toCharArray(); String res=String.valueOf(chs[0]); int num=1; for(int i=1;i&lt;str.length();i++){ if(chs[i]==chs[i-1]){ num++; }else { res=res+\"_\"+String.valueOf(num)+\"_\"+String.valueOf(chs[i]) ; num=1; } } return res+\"_\"+String.valueOf(num)+\"\" ; } } 判断两个字符串是否互为旋转词 题目： 如果一个字符串str，把字符串str前面任意的部分挪到后面形成的字符串叫做str的旋转词。 如str=”12345”，str的旋转词有”12345”、”23451”、”34512”、”45123”、”51234”。 给定两个字符串a和b，请判断a和b是否互为旋转词。 举例： a=”cdab”，b=”abcd”，返回true； a=”1ab2”，b=”ab12”，返回false； a=”2ab1”，b=”ab12”，返回true。 要求： 如果a和b长度不一样，那么a和b必然不互为旋转词，可以直接返回false。 当a和b长度一样，都为N时，要求解法的时间复杂度为O(N)。 package String; /** * Created by zdmein on 2017/9/6. */ public class isRotation { public boolean isRotation(String a ,String b){ if(a==null||b==null||a.length()!=b.length()){ return false; } String b2=b+b; return KMP(b2,a)!=-1; // KMP算法 } public static int KMP(String source , String pattern){ // int [] N=getN(pattern); return -1; } } 判断是不是整体有效的括号字符串package String; import java.util.Scanner; /** * Created by zdmein on 2017/9/18. * 判断是不是整体有效的括号字符串 * 括号字符串的有效性和最长有效长度 */ public class isValid1 { public static void main(String [] args){ Scanner cin=new Scanner(System.in); String str=cin.next(); System.out.println(isValid(str)); } public static boolean isValid(String str){ if(str==null ||str.equals(\"\")){ return false; } char [] chs=str.toCharArray(); int status=0; for(int i=0;i&lt;str.length();i++){ if(chs[i]!=')'&amp;&amp;chs[i]!='('){ return false; } if(chs[i]==')'&amp;&amp;--status&lt;0){ return false; } if(chs[i]=='('){ status++; } } return status==0; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"面经-腾讯1","slug":"面经-腾讯1","date":"2017-08-30T02:18:48.000Z","updated":"2017-08-31T04:41:29.561Z","comments":true,"path":"2017/08/30/mian-jing-teng-xun-1/","link":"","permalink":"http://zhoudamin.github.io/2017/08/30/mian-jing-teng-xun-1/","excerpt":"基础查漏补缺~","text":"基础查漏补缺~ 面向对象的特征 继承：联结性的层次模型，表述共性 多态：允许不同类对同一消息作出响应 抽象：过程抽象，数据抽象 封装：将客观事物抽象成类 重写和重载有什么不同 重写（override）：派生类函数覆盖 重载（overload）：多个方法有相同名字、不同参数。 区别： 重写是子类与父类之间的关系，是垂直关系；重载是同一个类中方法之间的关系，是水平关系。 重写只能由一个方法或者一对方法产生关系；重载是多个方法之间的关系。 重写要求参数列表相同；重载要求参数列表不同。 重写关系中，调用方法体是根据对象的类型来决定；重载是根据调用的实参表和形参表来选择方法体。 计算机加载程序包括哪几个区？链表和数组有什么不同？ 数组静态分配内存，链表动态分配内存 数组在内存中连续，链表不连续 数组元素在栈区，链表元素在堆区 数组利用下标定位，时间复杂度O(1)，链表定位元素时间复杂度O(n) 数组插入和删除时间复杂度O(n)，链表的时间复杂度O(1) 栈和堆的特点是什么？ 栈： 先进后出 存放的都是局部变量 使用完变量会自动在内存中释放 堆： 可以看成一棵树 存放的是实体或者成员变量 存放的实体都是有首地址值的 实体中的数据都是有初始值的 什么排序稳定性高而且效率？快排 进程间通讯的几种方式？ 文件和记录锁定 管道 有名管道 FIFO 信号量 信号 消息队列 共享内存 套接字（socket） 详解 解释 TCP/IP的三次握手协议TCP/IP有什么作用有哪些方式可以加快查询？（我答了建索引，试图存储 过程，建索引是一定对的其他两个就不知道了）然后他继续追问，建索引一般是怎么才能让查询更加快呢？ （问我怎么样才能够通过索引排除不同的数据吧，这个还真懂完全没左外连接和右外连接有什么不同左连接就是以左为主，右边的记录可能为空 右连接就是以右为主左边的可能为空 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"面经","slug":"面经","permalink":"http://zhoudamin.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://zhoudamin.github.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"腾讯","slug":"腾讯","permalink":"http://zhoudamin.github.io/tags/%E8%85%BE%E8%AE%AF/"}]},{"title":"读书笔记之《程序员代码面试指南（二叉树问题）》","slug":"读书笔记之《程序员代码面试指南（二叉树问题）》","date":"2017-08-24T02:59:41.000Z","updated":"2018-08-03T14:54:17.732Z","comments":true,"path":"2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-er-cha-shu-wen-ti/","link":"","permalink":"http://zhoudamin.github.io/2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-er-cha-shu-wen-ti/","excerpt":"二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 代码 Github 地址","text":"二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 代码 Github 地址 判断二叉树是不是平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡的二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 先比较左边，再比较右边； 左子树也先比较左边再比较右边。 public boolean isBalance(Node head){ boolean res=true; getHeight(head,1,res); return res; } public int getHeight(Node head , int level ,boolean res){ if(head==null){ return level; } int lH=getHeight(head.left,level+1,res); if(!res){ return level; } int rH=getHeight(head.right,level+1,res); if(!res){ return level; } if(Math.abs(lH-rH)>1){ res=false; } return Math.max(lH,rH); } 根据后序数组重建搜索二叉树给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。 数组最后一个值，肯定是根节点的值 小于根节点的为左子树，大于根节点的为左子树 对应2,1,3小于4 6,5,7大于4 public static void main(String [] args){ int [] arr={2,1,3,6,5,7,4}; System.out.println(isPostArray(arr)); } public static boolean isPostArray(int [] arr){ if(arr==null || arr.length==0){ return false; } return isPost(arr,0,arr.length-1); } public static boolean isPost(int [] arr, int start ,int end){ if(start==end){ return true; } int less=-1; int more=end; for(int i=start;i&lt;end;i++){ if(arr[i]&lt;arr[end]){ less=i; }else { more=more==end ? i : more; } } if(less==-1||more==end){ return isPost(arr,start,end-1); } if(less!=more-1){ return false; } return isPost(arr,start,less)&amp;&amp;isPost(arr,more,end-1); } 二叉树的序列化和反序列化package BinaryTree; import java.util.LinkedList; import java.util.Queue; /** * Created by zdmein on 2017/9/7. 12 / \\ 3 null / \\ null null 先序遍历：12！3！#！#！#！ */ public class NodeSerial { /** * 定义Node */ public class Node{ public int value; public Node left; public Node right; public Node(int data){ this.value=data; } } /** * 先序遍历 */ public String serialByPre(Node head){ if(head==null){ return \"#!\"; } String res=head.value+\"!\"; res+=serialByPre(head.left); res+=serialByPre(head.right); return res; } /** * 先序遍历反序列化 */ public Node reconByPreString(String preStr){ String [] values=preStr.split(\"!\"); Queue&lt;String> queue=new LinkedList&lt;String>(); for(int i=0;i&lt;values.length;i++){ queue.offer(values[i]); } return reconPreOrder(queue); } /** * Queue add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 */ public Node reconPreOrder(Queue&lt;String> queue){ String value = queue.poll(); if(value.equals(\"#\")){ return null; } Node head=new Node(Integer.valueOf(value)); Node left=reconPreOrder(queue); Node right=reconPreOrder(queue); return head; } } 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 package BinaryTree; /** * Created by zdmein on 2017/9/8. * 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 6 / \\ 1 12 /\\ / \\ 0 3 10 13 / \\ / \\ 4 14 2 9 /\\ /\\ 2 5 1 6 二叉搜索树： 10 / \\ 4 14 / \\ / \\ 2 5 1 6 要求： 如果节点数为N，要求时间复杂度为O（N） ,额外空间复杂度为O(h),h为二叉树的高度。 解： 以节点node为头的树中，最大的搜索二叉子树只可能来自一下两种情况。 1.如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树的最大搜索二叉树是以 node.right为头的；node左子树上的最大搜索二叉子树的最大值小于node.value； node右子树的最大搜索二叉子树的最小值大于node.value,那么以节点node为头的整棵树都是搜索二叉树。 2如果不满足第一中情况，说明节点node为头的整颗树不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树来自node的左子树上的最大搜索二叉子树和来自右子树上的最大搜索二叉子树之间， 节点较多的那个。 过程如下： 1，整个过程是二叉树的后序遍历。（左右根） 2，遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点（IBST） ，节点数（ISize）,最小值（IMin）,最大值（IMax）. 再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点（RBST） ，节点数（RSize）,最小值（RMin）,最大值（RMax）. 3, 根据步骤2收集的信息，判断是否满足第一种情况，如果满足第一种情况就返回cur，如果满足第二种情况，就返回IBST和RBST中较大的一个。 4，可以使用全局变量的方式实现步骤2中收集节点数，最大和最小的情况。 */ public class biggestSubBST1 { public class Node{ public int value; public Node left; public Node right; public Node(int data){ this.value=data; } } public Node biggestSubBST(Node head){ int [] record =new int[3]; return posOrder(head , record); } public Node posOrder(Node head,int [] record){ if(head==null){ record[0]=0; record[1]=Integer.MAX_VALUE; record[2]=Integer.MIN_VALUE; return null; } int value=head.value; Node left=head.left; Node right=head.right; Node lBST=posOrder(left,record); int lSize=record[0]; int lMin=record[1]; int lMax=record[2]; Node rBST=posOrder(right,record); int rSize=record[0]; int rMin=record[1]; int rMax=record[2]; record[1]=Math.min(value,lMin); record[2]=Math.max(value,rMax); if(left==lBST&amp;&amp;right==rBST&amp;&amp;lMax&lt;value&amp;&amp;rMin>value){ record[0]=lSize+rSize+1; return head; } record[0]=Math.max(lSize,rSize); return lSize>rSize?head.left:head.right; } } 找到二叉树中符合搜索二叉树条件的最大拓扑结构 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《程序员代码面试指南（链表问题）》","slug":"读书笔记之《程序员代码面试指南（链表问题）》","date":"2017-08-24T02:59:19.000Z","updated":"2018-08-03T14:53:42.767Z","comments":true,"path":"2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-lian-biao-wen-ti/","link":"","permalink":"http://zhoudamin.github.io/2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-lian-biao-wen-ti/","excerpt":"链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。它可以根据需要开辟内存单元。链表有一个“头指针”变量，以head表示，它存放一个地址。该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：一为用户需要用的实际数据，二为下一个结点的地址。因此，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。","text":"链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。它可以根据需要开辟内存单元。链表有一个“头指针”变量，以head表示，它存放一个地址。该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：一为用户需要用的实际数据，二为下一个结点的地址。因此，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 打印两个有序链表的公共部分package LinkedList; /** * Created by zdmein on 2017/8/31. * * 打印两个有序链表的公共部分 * 给定两个有序列表的头指针head1和head2，打印两个链表的公共部分。 */ public class printCommonPart1 { public static class Node{ public int value; public Node next; public Node(int data){ this.value=data; } } public static void main(String args[]){ Node head1=new Node(2); Node head11=new Node(3); Node head12=new Node(4); Node head13=new Node(7); head1.next=head11; head11.next=head12; head12.next=head13; Node head2=new Node(1); Node head21=new Node(3); Node head22=new Node(4); Node head23=new Node(9); head2.next=head21; head21.next=head22; head22.next=head23; printCommonPart(head1,head2); } public static void printCommonPart(Node head1,Node head2){ System.out.println(\"Print Common Part: \"); while(head1!=null&amp;&amp;head2!=null){ if(head1.value==head2.value){ System.out.println(head1.value); head1=head1.next; head2=head2.next; }else if(head1.value>head2.value){ head2=head2.next; }else { head1=head1.next; } } } } 判断一个链表是否为回文结构题目：判断一个链表是否为回文结构。要求：时间复杂度为 O(n)，空间时间复杂度为O(1)。 思路分析：回文链表的特点就是对称，那么要判断是否回文，就可以用两个指针指向对称的节点，看它们的数据是否一样。由于是单向链表，不能同时用两个指针，从头尾向内部遍历取值比较。且本题对空间复杂度也有要求，所以可用如下方法实现。具体步骤如下：（1）先得到链表的中间节点；（2）从中间节点的下一个节点开始，反转链表。（3）从中间节点处，断开原链表。（4）用两个指针分别向两个端点移动，同时进行比较，数据相同则继续，数据不同则直接返回false。直到遍历完成，最后返回true。 class ListNode { public char data; public ListNode next; public ListNode(char c){ this.data=c; } } public static boolean isPalindrome(ListNode head ){ ListNode slow = head; ListNode fast= head; if(fast==null || fast.next==null){ return true; } //一个每次走2步，一个每次走1步，所以当fast到表尾，slow肯定把链表折半 while(fast.next!=null&amp;&amp;fast.next.next!=null){ fast=fast.next.next; slow=slow.next; } ListNode midNode=slow; ListNode firNode = slow.next; //后半段第一个节点 ListNode cur=firNode.next; //从第一个节点开始插入 firNode.next=null; //第一个节点最后变成最后一个节点，所以要置空 while(cur!=null){ ListNode nextNode = cur.next; cur.next=midNode.next; midNode=cur; cur=nextNode; } slow=head; fast=midNode.next; while (fast!=null){ if(fast.data!=slow.data){ return false; } slow=slow.next; fast=firNode.next; } return true; } 反转单向反转单向链表 1–&gt;2–&gt;null 反转后 2–&gt;1–&gt;null /** * Definition for ListNode. * public class ListNode { * int val; * ListNode next; * ListNode(int val) { * this.val = val; * this.next = null; * } * } */ public class Solution { /* * @param head: n * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) { // write your code here ListNode pre=null; ListNode next1=null; while(head!=null){ next1=head.next; head.next=pre; pre=head; head=next1; } return pre; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《程序员代码面试指南（位运算及大数据）》","slug":"读书笔记之《程序员代码面试指南（位运算及大数据）》","date":"2017-08-22T12:09:43.000Z","updated":"2018-08-03T14:54:29.283Z","comments":true,"path":"2017/08/22/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-wei-yun-suan-ji-da-shu-ju/","link":"","permalink":"http://zhoudamin.github.io/2017/08/22/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-wei-yun-suan-ji-da-shu-ju/","excerpt":"位运算、大数据和空间限制","text":"位运算、大数据和空间限制 不用额外变量交换两个整数的值【题目】 如何不用任何额外变量交换两个整数的值？ 【解答】 使用位运算的异或运算，或者使用加法运算 a异或b的结果是c,那么c就是a整数位信息和b整数位信息的所有不同信息。 a = a^b,当前a=c；b = a^b相当于b = c^b 当前b=a；a = a^b 相当于a = c^a 当前a=b,完成交换； 如果是加法交换的话，假设a + b结果是c，那么 a = a+b,当前a=c；b = a-b相当于b = c-b 当前b=a；a = a-b 相当于a = c-a 当前a=b,完成交换； a=011 b=100 c=a^b=111 a=a^c=011^111=100 b=a^c=100^111=011 输入一个整数,求该整数的二进制表达中有多少个1题目：输入一个整数，求该整数的二进制表达中有多少个1。例如输入10，由于其二进制表示为1010，有两个1，因此输出2。 public int count(int n){ int res=0; while(n!=0){ n&amp;=(n-1); res++; } return res; } --- n=1010 n=1010&amp;1001=1000 res=1; n=1000&amp;0999=0000 res=2; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java基础-操作系统","slug":"Java基础-操作系统","date":"2017-08-15T12:14:51.000Z","updated":"2017-08-16T08:00:23.672Z","comments":true,"path":"2017/08/15/java-ji-chu-cao-zuo-xi-tong/","link":"","permalink":"http://zhoudamin.github.io/2017/08/15/java-ji-chu-cao-zuo-xi-tong/","excerpt":"操作系统的一些基本概念","text":"操作系统的一些基本概念 进程和线程的区别进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单元，他是比进程更小的能独立运行的基本单位。 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 死锁的必要条件，怎么处理死锁四个条件： 互斥条件：指进程对所分配到的资源进行排他性的使用，即在一段时间内某资源只有一个进程占用，如果此时还有其他进程请求资源，则让他先等着，直到占有资源的进程用完释放后，才可以用。意思就是一个资源只能一个进程占用，其他要用的得等着。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放。意思是一个进程占用了资源，想获得别的资源，要是那个资源被占，那自己先等，但是自己占的资源也不会释放给别的进程。 不剥夺条件：指进程占有的资源，不能被剥夺，只能自己释放。我占的资源你不能抢。 环路等待条件：指在发生死锁时，必然是有一个环路链，进程都占用资源，但是又想获得其他进程占有的资源，形成一个环，循环等待。 处理死锁的方法： 预防死锁 破坏占有并等待条件：一次性分配全部资源 or 每次申请前，必须释放自己的资源 避免死锁 检测死锁 解除死锁 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程 撤销进程：强制撤销某些、甚至全部死锁进程并剥夺这些进程的资源 进程回退：让一or多个进程回退到足以回避死锁的地步，进程回退时自愿放弃资源而不是剥夺。（设置还原点） Window内存管理方式段存储## 页存储 段页存储进程的几种状态进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。 一个进程的生命周期可以划分为一组状态。 三个：就绪、运行、阻塞 运行：进程占用CPU，并在CPU上运行 就绪：进程已经具备运行条件，但是CPU还没有分配过来 阻塞：进程因为某件事发生而暂时不能运行 IPC几种通信方式IPC是进程间的通讯 （Inter-process communication） 作用：数据传输、共享数据、通知事件、资源共享、进程控制（这些都需要通讯） 无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程间通信。管道的缓冲区是有限的，管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约好数据的格式。 命名管道（fifo）：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则是把数据添加到末尾。 消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，可以用非先进先出方式处理，消息队列是异步通信。 共享内存：共享内存是最快的IPC方式，在共享内存段中都是以字符串的默认结束符为一条信息的结尾。 信号量（semophore）：信号量是一个计数器 什么是虚拟内存 虚拟地址、逻辑地址、线性地址、物理地址的区别 物理地址 用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应 虚拟地址 这是对整个内存的抽象描述 逻辑地址 指机器语言指令中，用来指定一个操作数或者是一条指令的地址 线性地址 也是不真实的地址，对应硬件页式内存的转换前地址 推荐书籍：《深入理解现代操作系统》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://zhoudamin.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://zhoudamin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"读书笔记之《程序员代码面试指南（数组和矩阵问题）》","slug":"读书笔记之《程序员代码面试指南（数组和矩阵问题）》","date":"2017-08-14T15:54:40.000Z","updated":"2018-08-03T14:53:54.581Z","comments":true,"path":"2017/08/14/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-shu-zu-he-ju-zhen-wen-ti/","link":"","permalink":"http://zhoudamin.github.io/2017/08/14/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-shu-zu-he-ju-zhen-wen-ti/","excerpt":"数组和矩阵问题，这些做得比较多。","text":"数组和矩阵问题，这些做得比较多。 未排序正整数数组中累加和为给定值的最长子数组长度package Array; /** * Created by zdmein on 2017/8/30. *未排序正整数数组中累加和为给定值的最长子数组长度 * 给定一个无需数组arr,其中元素为正，给定一个整数k。求arr的所有子数组中累加和为k的最长子数组的长度。 * arr=[1,2,1,1,1],k=3 * 结果返回3 */ public class getMaxLength1 { public static void main(String [] args){ int [] arr={1,2,1,1,1}; int k=3; System.out.println(getMaxLength(arr,k)); } public static int getMaxLength(int [] arr ,int k){ if(arr==null||arr.length&lt;0||k&lt;0){ return 0; } int right =0; int left=0; int len=0; int sum=arr[0]; while (right&lt;arr.length){ if(sum==k){ len=Math.max(len,right-left+1); sum-=arr[left++]; }else if(sum&lt;k){ right++; if(right==arr.length){ break; } sum+=arr[right]; }else { sum-=arr[left++]; } } return len; } } 数组partition调整使数组的左部分单调有序给定一个有序数组arr，调整使得数组的左部分无重复元素且有序，右边部分不要求。如数组arr[]={1,2,2,2,3,3,4,5,6,9,9} ;调整过后可以为：[1, 2, 3, 4, 5, 6, 9, 2, 3, 2, 9] 。 思路：使用标记 u 其中arr[0…u] 表示已经处理过的没有重复元素且有序的区间，从arr[u+1…i-1]表示有重复元素的部分。则算法主要分为下面两部分。1. 比较 arr[i] 与 arr[u] 是否相同如果不同，则将 arr[i] 的值赋给arr[u+1],u++;2. i++遍历数组。 import java.util.HashSet; public class Main { public static void main(String[] args) { int[] arr = {1, 2, 2, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 8, 9}; leftUnique(arr); } public static void leftUnique(int[] arr) { if (arr.length == 0 || arr == null) { return; } int u=0; int i=1; while (i!=arr.length){ if(arr[i++]!=arr[u]){ swap(arr,i-1,++u); } } for( i=0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } } public static int [] swap(int[] arr,int m, int n){ int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; } } 将正方形矩阵顺时针转动90度题目：给定一个N*N的矩阵matrix,求把这个矩阵调整成顺时针转动90度后的形式。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 顺时针转动90度后为: 13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 要求：额外空间复杂度为O(1) public class Main { public static void main(String[] args) { int[][] m = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12}, {13,14,15,16} }; rotate(m); } public static void rotate(int[][] arr) { int tR=0; int tC=0; int dR=arr.length-1; int dC=arr[0].length-1; while (tR&lt;dR){ rotateEdge(arr,tR++,tC++,dR--,dC--); } for (int i=0;i&lt;arr.length;i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(\" \"); } } public static void rotateEdge(int [][] arr ,int tR,int tC ,int dR ,int dC){ int times=dR-tR; int temp=0; for(int i=0;i!=times;i++){ temp = arr[tR][tC+i]; arr[tR][tC+i]=arr[dR-i][tC]; arr[dR-i][tC]=arr[dR][dC-i]; arr[dR][dC-i]=arr[tR+i][dC]; arr[tR+i][dC]=temp; } } } 找到无序数组中最小的K个数给定一个无序的整型数组arr，找到其中最小的k个数。 时间复杂度：O(nlogk) 维护一个有k个数的大根堆，这个堆代表目前选出的k个最小的数。在堆的k个元素中堆顶元素是最小的k个数中最大的那个。 接下来要遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。如果是，就把堆顶元素替换成当前数，然后调整堆。如果不是，则不做任何操作，继续遍历下一个数。在遍历完成后，堆中的k个数就是所有数组中最小的k个数。 public class Main { public static void main(String[] args) { int[] arr = {5 ,9,3,4,7,2,8,1,6}; int k=3; int [] res= getMinKNumsByHeap(arr,k); for(int i=0;i&lt;res.length;i++){ System.out.println(res[i]); } } public static int [] getMinKNumsByHeap(int[] arr,int k) { if(k&lt;1&amp;&amp;k>arr.length){ return arr; } int kHeap[]=new int [k]; for(int i=0;i!=k;i++){ heapInsert(kHeap,arr[i],i); } for(int i = k;i !=arr.length;i++){ if(arr[i]&lt;kHeap[0]){ kHeap[0]=arr[i]; heapify(kHeap,0,k); } } return kHeap; } public static void heapify(int [] arr, int index ,int heapsize){ int left= index*2+1; int right=index*2+2; int largest=index; while(left&lt;heapsize){ if(arr[left]>arr[index]){ largest=left; } if(right&lt;heapsize &amp;&amp; arr[right]>arr[largest]){ largest=right; } if(largest!=index){ swap(arr,largest,index); }else { break; } index=largest; left= index*2+1; right=index*2+2; } } public static void heapInsert(int [] kHeap ,int arri ,int i){ kHeap[i]=arri; while (i!=0){ int parent=(i-1)/2; if(kHeap[parent]&lt;kHeap[i]){ swap(kHeap,parent,i); i=parent; }else { break; } } } public static void swap(int [] arr ,int m ,int n){ int temp=arr[m]; arr[m]=arr[n]; arr[n]=temp; } } 三数排序给定一个数组，其中只有三个数0,1,2三个值，请实现arr排序。 三个颜色的球排序 用left和right标记数组头和尾，用index遍历，遇到该交换的交换，直到index==right为止。 import java.util.HashSet; public class Main { public static void main(String[] args) { int[] arr = {1,0,2,0,1,2,1,0 ,2, 2,0}; leftUnique(arr); } public static void leftUnique(int[] arr) { if (arr.length &lt;2 || arr == null) { return; } int left=-1; int index=0; int right=arr.length; while (index&lt;right){ if(arr[index]==0){ swap(arr,++left,index++); }else if(arr[index]==2){ swap(arr,--right,index); }else { index++; } } for(int i=0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } } public static int [] swap(int[] arr,int m, int n){ int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; } } 转圈打印矩阵给一个整型矩阵matrix，按照转圈的方式打印它。 1 2 3 4 5 6 7 8 9 打印就是：1 2 3 6 9 8 7 4 5 public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}, {13,14,15,16}}; spirOrderPrint(m); } public static void spirOrderPrint(int [][]matrix){ int tR = 0; int tC = 0; int dR=matrix.length-1; int dC=matrix[0].length-1; while (tR&lt;=dR &amp;&amp; tC&lt;=dC){ printEdge(matrix,tR++,tC++,dR--,dC--); } } public static void printEdge(int [][] matrix ,int tR ,int tC,int dR , int dC){ if(tR==dR){ for(int i=0;i&lt;=dC;i++){ System.out.print(matrix[tR][i]+\" \"); } }else if(tC==dC){ for(int i=0;i&lt;dR ;i++){ System.out.print(matrix[i][tC]+ \" \"); } }else { int curC=tC; int curR=tR; while (curC != dC){ System.out.print(matrix[tR][curC]+\" \"); curC++; } while (curR!=dR){ System.out.print(matrix[curR][dC]+\" \"); curR++; } while (curC != tC){ System.out.print(matrix[dR][curC]+\" \"); curC--; } while (curR!=tR){ System.out.print(matrix[curR][tC]+\" \"); curR--; } } } } “之”字形打印矩阵 上坐标（tR,tC）初始为（0,0），先向右走（tC++）,再向下走tR++ 下坐标类似 打印斜线方向用boolean判断 public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,2,3, 4}, {5,6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}; printMatrixZigZag(m); } public static void printMatrixZigZag(int [][] matrix){ int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length-1; int endC = matrix[0].length-1; boolean flag=false; while (tR!=matrix.length){ printZigZag(matrix,tR,tC,dR,dC,flag); tC=tC==endC?tC:tC+1; tR= tC==endC ?tR+1:tR; dR=dR==endR?dR:dR+1; dC=dR==endR?dC+1:dC; flag=!flag; } } public static void printZigZag(int [][] matrix,int tR,int tC,int dR,int dC,boolean flag ){ if(flag){ while (tR!=dR+1){ System.out.print(matrix[tR++][tC--]+\" \"); } }else { while (dR!=tC-1) { System.out.print(matrix[dR--][dC++]+\" \"); } } } } 自然数数组的排序给定一个长度为N的整型数组arr，其中有N个互不相等的自然数1N，请实现arr的排序，但是不要把下标0N-1位置上的数值通过直接赋值的方式替换成1~N。 要求：时间复杂度为O(N)，额外空间复杂度为O(1)。 思路： 1.从左向右遍历arr，假设当前遍历到i位置。 2.if arr[i]==i+1,不需要调整，继续遍历。 3.if arr[i]!=i+1,进行调整。 根据调整功能的方法不同，可以有不同的实现过程。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,2,5,3, 4}; m=sort(m); for(int i=0;i&lt;m.length;i++){ System.out.println(m[i]); } } public static int [] sort(int [] matrix){ for(int i=0;i&lt;matrix.length;i++){ while(matrix[i]!=i+1){ int temp=matrix[matrix[i]-1]; matrix[matrix[i]-1]=matrix[i]; matrix[i]=temp; } } return matrix; } } 奇数下标都是奇数或偶数下标都是偶数给定一个长度不小于2的数组arr，实现一个函数调整arr，要么使所有的偶数下标都是偶数，要么使所有的奇数下标都是奇数。 要求：时间复杂度为O(N),额外空间复杂度为O(1)。 算法解释： 最后位置的数是偶数，就替换前面的偶数下标，最后位置的是奇数，就替换前面的奇数下标，每替换一次，最后位置的数都是变化的，这样就都替换了。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,8,3,2,4,6}; modify(m); } public static void modify(int [] matrix){ if(matrix==null || matrix.length&lt;2){ return; } int even=0; int odd=1; int end=matrix.length-1; while (even&lt;=end &amp;&amp; odd&lt;=end){ if((matrix[end]&amp;1)==0){ swap(matrix,even,end); even+=2; }else { swap(matrix,odd,end); odd+=2; } } for(int i=0;i&lt;matrix.length;i++){ System.out.println(matrix[i]); } } public static void swap(int [] m,int index1,int index2){ int temp=m[index1]; m[index1]=m[index2]; m[index2]=temp; } } 子数组的最大累加和问题给定一个数组，返回子数组的最大累加和。 例如：arr=[1,-2,3,5,-2,6,-1]，所有子数组中，[3,5,-2,6]可以累加出最大的和12，return 12. 时间复杂度为O(N)，额外空间复杂度为O(1)。 如果arr中没有正数，产生的最大累加和一定是数组中的最大值。 如果arr中有正数，从左向右遍历arr，用变量cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。当cur&lt;0时，舍弃当前部分，令cur=0，表示重新从下一个数开始累加。当cur&gt;=0时，每一次的累加都可能是最大的累加和，所以，用另外一个变量max全程跟踪cur出现的最大值。 cur累加到负数就重新累加，max记录当前cur的最大值。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,-2,3,5,-2,6,-1}; maxSum(m); } public static void maxSum(int[] m){ if(m==null||m.length==0){ return; } int cur=0; int max=0; for(int i=0;i&lt;m.length;i++){ cur+=m[i]; if(max&lt;cur){ max=cur; } if(cur&lt;0){ cur=0; } } System.out.println(max); } } 子矩阵的最大累计和问题给定一个矩阵，其中的值有正、有负、有0。返回子矩阵的最大累计和。 如果一个矩阵一共有K行且限定必须含有K行元素的情况下，只要把矩阵中每一行的K个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含有K行元素的子矩阵中的最大累加和。 用i动态测试每一层往下累计的最大值，i+1实际上是把i层之上的全部不算。实现动态遍历 j和k是普通遍历 用s[k]存每次往下加的数字 cur加s[k]如果大就保存，如果不是最大就不存，如果小于0就清零。 public class Main { public static void main(String[] args) { int[][] m = {{-90, 48, 78}, {64, -40, 64}, {-81, -7, 66}}; maxSum(m); } public static void maxSum(int[][] m) { if (m == null || m.length == 0 || m[0].length == 0) { return; } int cur = 0; int max = Integer.MIN_VALUE; int []s=null; for (int i = 0; i &lt; m.length; i++) { s = new int[m[0].length]; for (int j = i; j &lt; m.length; j++) { cur = 0; for (int k = 0; k &lt; m[0].length; k++) { s[k] += m[j][k]; cur += s[k]; max = Math.max(max, cur); if (cur &lt; 0) { cur = 0; } } } } System.out.println(max); } } 在数组中找到一个局部最小的位置定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]为局部最小。如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小。如果0&lt;i&lt;N-1，arr[i]&lt;arr[i+1]&amp;&amp;arr[i]&lt;arr[i-1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任何两个相邻的数不相等。写一个函数，只需返回arr中任何一个局部最小出现的位置即可。 利用二分查找可以做到时间复杂度O(logN)、额外空间复杂度为O(1) public class Main { public static void main(String[] args) { int[] m = {90,78, 48, 78}; System.out.println(getLessIndex(m)); } public static int getLessIndex(int[] arr) { if(arr==null || arr.length==0){ return -1; } if(arr[0]&lt;arr[1]){ return 0; } if(arr[arr.length-1]&lt;arr[arr.length-2]){ return arr[arr.length-1]; } int left = 1; int right= arr.length-2; int mid=0; while (left&lt;right){ mid=(right+left)/2; if(arr[mid]>arr[mid-1]){ right=mid-1; }else if(arr[mid]>arr[mid+1]){ left=mid+1; }else { return mid; } } return left; } } 不包含本位置值的累乘数组给定一个整型数组，返回不包含本位置的累乘数组。 例如：arr=[2,3,1,4],返回[12,8,24,6],即除自己外，其他位置的类乘。 1.时间复杂度为O(N). 2.除需要返回的结果数组之外，额外空间复杂度为O(1). 使用除法： 结果数组记为res，所有数的乘积记为all。如果数组中不含0，则设置res[i]=all/arr[i]。如果数组中有一个0，对唯一的arr[i]==0的位置令res[i]=all,其他位置都是0。如果数组中0的数量大于1，那么res所有位置上的值都是0。 不使用除法： 1.生成两个长度和arr一样的新数组lr[]和rl[]，lr[i]=arr[0…i],rl[i]=arr[i…N-1]。 2.res[i]=lr[i-1]*rl[i+1] 3.res[0]=rl[1],res[N-1]=lr[N-2] 这里又额外使用了两个数组，可以通过res数组复用的方式省略掉这两个数组，先把res数组作为辅助计算的数组，然后把res调整成结果数组返回。 public class Main { public static void main(String[] args) { int[] m = {2,3, 1, 4}; m= product(m); for(int i=0;i&lt;m.length;i++){ System.out.println(m[i]); } } public static int [] product(int[] arr) { if(arr==null || arr.length==0){ return null; } int[] res=new int [arr.length]; res[arr.length-1]=1; for(int i=arr.length-2;i>=0;i--){ res[i]=res[i+1]*arr[i+1]; } int temp=1; for(int i=0;i&lt;arr.length;i++){ res[i]*=temp; temp*=arr[i]; } return res; } } 求最短通路值用一个整形矩阵matrix表示一个网络，1代表有路，0代表没路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。 例如： 1 0 1 1 1 1 0 1 0 1 1 1 1 0 1 0 0 0 0 1 通路只有1条，由12个1组成，所以返回12。 使用宽度优先遍历即可，如果矩阵大小为NM，时间复杂度为O(NM)， 1.开始时生成map矩阵，map[i][j]的含义是从（0,0）位置走到（i，j）位置最短的路径值。然后将左上角位置（0,0）的行坐标和列坐标放入行队列rQ、列队列 cQ。 2.不断从队列弹出一个位置（r,c）,然后看这个位置的上下左右四个位置哪些在matrix上的值是1，这些都是能走的位置。 3.将那些能走的位置设置好各自在map中的值，即map[r][c]+1。同时将这些位置加入到rQ和cQ的中，用队列完成宽度优先遍历。 4.在步骤3中，如果一个位置走过，就不要重复走，这个逻辑可以根据一个位置在map中的值来确定，比如map[i][j]!=0，就可以知道这个位置之前走过。 5.一直重复步骤2~步骤4。直到遇到右下角位置，说明已经找到终点，返回终点在map中的值即可，如果rQ和cQ已经为空都没有遇到终点位置，return 0。 import java.util.LinkedList; import java.util.Queue; public class Main { public static void main(String[] args) { int[][] m = { {1,0,1,1,1}, {1,0,1,0,1}, {1,1,1,0,1}, {0,0,0,0,1} }; System.out.println(minPathValue(m)); } public static int minPathValue(int [][] m){ if(m==null || m.length==0|| m[0].length==0||m[0][0]!=1||m[m.length-1][m[0].length-1]!=1){ return 0; } int res=0; int [][] map=new int [m.length][m[0].length]; map[0][0]=1; Queue&lt;Integer> rQ=new LinkedList&lt;Integer>(); Queue&lt;Integer> cQ=new LinkedList&lt;Integer>(); rQ.add(0); cQ.add(0); int r=0; int c=0; while (!rQ.isEmpty()){ r=rQ.poll(); c=cQ.poll(); if( ( r==m.length-1 ) &amp;&amp; ( c==m[0].length-1)){ //查map路径 for(int i=0;i&lt;map.length;i++){ for (int j=0;j&lt;map[0].length;j++){ System.out.print(map[i][j]+\" \"); } System.out.println(\" \"); } //输出结果 return map[r][c]; } walkTo(map[r][c],r-1,c,m,map,rQ,cQ); walkTo(map[r][c],r+1,c,m,map,rQ,cQ); walkTo(map[r][c],r,c-1,m,map,rQ,cQ); walkTo(map[r][c],r,c+1,m,map,rQ,cQ); } return res; } public static void walkTo(int pre,int toR,int toC ,int [][]m , int [][] map,Queue&lt;Integer> rQ , Queue&lt;Integer> cQ ){ if (toR &lt; 0 || toR == m.length || toC &lt; 0 || toC == m[0].length || m[toR][toC] != 1 || map[toR][toC] != 0) { return; } map[toR][toC]=pre+1; rQ.add(toR); cQ.add(toC); } } ---res: 1 0 7 8 9 2 0 6 0 10 3 4 5 0 11 0 0 0 0 12 12 最长的可整合数组的长度如果一个数组再排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6],符合每相邻两个数差的绝对值为1，所以这个数组为可整合数组。 给定一个整型数组，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3]的最大可整合子数组为[5,3,2,6,4]，所以返回5. 一个数组中如果没有重复元素，并且如果最大值减去最小值，再加上1的结果等于元素的个数（max-min+1=元素个数）,那么这个数组就是可整合数组。 这样，验证一个数组是否是可整合数组的时间复杂度可以从第一种方法的O(NlogN)减少至O(1),整个过程的时间复杂度为O(N^2) 无需排序，仅仅只需要遍历比较大小 public class Main { public static void main(String[] args) { int[] m = { 5,5,3,2,6,4,3}; System.out.println(getLIL(m)); } public static int getLIL(int [] arr){ if(arr.length==0||arr==null){ return 0; } int max=0; int min=0; int len=0; HashSet&lt;Integer> set=new HashSet&lt;Integer>(); for(int i=0;i&lt;arr.length;i++){ max=Integer.MIN_VALUE; min=Integer.MAX_VALUE; for(int j=i;j&lt;arr.length;j++){ if(set.contains(arr[j])){ break; } set.add(arr[j]); max=Math.max(max,arr[j]); min=Math.min(min,arr[j]); if(max-min==j-i){ len=Math.max(len,j-i+1); } } set.clear(); } return len; } } 边界都是1的最大正方形大小给定一个M*N的矩阵，在这个矩阵中，只有0和1两种值，返回边框全是1的最大正方形的边长长度。 例如： ​ [0, 1, 1, 1, 1], ​ [0, 0, 1, 0, 1], ​ [0, 1, 1, 0, 1], ​ [0, 1, 1, 1, 1], ​ [0, 1, 0, 1, 1] 其中，边框全是1的最大正方形的大小为4。 解析： 1.正方形边长为0&lt;=size&lt;=Math.min(rows,cols); 2.边长为size时，左上角的坐标范围为 0&lt;=i&lt;=rows-size，0&lt;=j&lt;=cols-size; 3.使用预处理矩阵right和down，空间换时间，right[i][j]保存matrix[i][j]包括自己往右边有多少个1，同理down[i][j]。 3.对每一个左上角的边长为size的矩形判断边上是否全为1，发现有满足的直接返回当前size。 public class Main { public static void main(String[] args) { int[][] arr = { {0,1,1,1,1}, {0,1,0,0,1}, {0,1,0,0,1}, {0,1,1,1,1}, {0,1,0,1,1}}; System.out.println(getMaxSize(arr)); } public static int getMaxSize(int [][]m){ int [][] right=new int [m.length][m[0].length]; int [][] down= new int [m.length][m[0].length]; setBorderMap(m,right,down); for(int size=Math.min(m.length,m[0].length);size!=0;size--){ if(hasSizeOfBorder(size,right,down)){ return size; } } return 0; } public static void setBorderMap(int [][] m,int [][]right ,int [][]down){ int r=m.length; int c=m[0].length; if(m[r-1][c-1]==1){ right[r-1][c-1]=1; down[r-1][c-1]=1; } for(int i=r-2;i>=0;i--){ if(m[i][c-1]==1){ right[i][c-1]=1; down[i][c-1]=down[i+1][c-1]+1; } } for(int j=c-2;j>=0;j--){ if(m[r-1][j]==1){ right[r-1][j]=right[r-1][j+1]+1; down[r-1][j]=1; } } for(int i=r-2;i>=0;i--){ for (int j=c-2;j>=0;j--){ right[i][j]=right[i][j+1]+1; down[i][j]=down[i+1][j]+1; } } } public static boolean hasSizeOfBorder(int size ,int [][]right ,int [][] down){ for(int i=0;i&lt;right.length-size+1;i++){ for(int j=0;j&lt;right[0].length-size+1;j++){ if(right[i][j]>=size&amp;&amp;down[i][j]>=size &amp;&amp;right[i+size-1][j]>=size &amp;&amp;down[i][j+size-1]>=size) return true; } } return false; } } 需要排序的最短子数组长度package Array; /** * Created by zdmein on 2017/9/15. * 需要排序的最短子数组长度 * 思路： 用noMin 记录从右到左，可以遍历的，最左边开始需要重新排的 用noMax 记录从左到右，可以遍历的，最右边需要重新排的 1, 5,3,4,2, 6,7 返回 4 */ public class getMinLength1 { public static void main(String args[]){ int []arr={1,5,3,4,2,6,7}; System.out.println(getMinLength(arr)); } public static int getMinLength(int [] arr){ if(arr==null||arr.length&lt;2){ return 0; } int min=arr[arr.length-1]; int noMin=-1; for(int i=arr.length-2;i>=0;i--){ if(arr[i]>min){ noMin=i; }else { min=Math.min(arr[i],min); } } if(noMin==-1) return 0; int max=arr[0]; int noMax=-1; for(int i=1;i&lt;arr.length;i++){ if(arr[i]&lt;max){ noMax=i; }else { max=Math.max(max,arr[i]); } } return noMax-noMin+1; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《程序员代码面试指南（递归和动态规划）》","slug":"读书笔记之《程序员代码面试指南（递归和动态规划）》","date":"2017-08-10T00:49:54.000Z","updated":"2018-08-03T14:54:10.234Z","comments":true,"path":"2017/08/10/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-di-gui-he-dong-tai-gui-hua/","link":"","permalink":"http://zhoudamin.github.io/2017/08/10/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-di-gui-he-dong-tai-gui-hua/","excerpt":"递归：将问题分解成子问题求解，从较小的问题逐渐逼近原始问题，很多时候只需要在f（n-1）中加入或移除某些东西或稍作修改就可以求得f（n） 递归 是 考虑所有的情况，一般使用搜索（DFS /BFS）来实现。 一般可以使用记忆化搜索进行优化的递归算法，我们可以使用DP来进行优化。","text":"递归：将问题分解成子问题求解，从较小的问题逐渐逼近原始问题，很多时候只需要在f（n-1）中加入或移除某些东西或稍作修改就可以求得f（n） 递归 是 考虑所有的情况，一般使用搜索（DFS /BFS）来实现。 一般可以使用记忆化搜索进行优化的递归算法，我们可以使用DP来进行优化。 斐波那契系列问题经典斐波那契问题代码就不写了，这个基本都会，需要注意的是： 递归方法的时间复杂度是：$O(2^N)$ 顺序计算的时间复杂度是：$O(N)$ 二阶递推数列的时间复杂度是：$O(logN)$ 大牛小牛问题假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。 第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。 每只小母牛3年之后成熟又可以生小母牛。 给定整数N，求出N年后牛的数量。 【举例】N=6，第1年1头成熟母牛记为a； 第2年a生了新的小母牛，记为b，总牛数为2； 题目最优解第3年a生了新的小母牛，记为c，总牛数为3； 第4年a生了新的小母牛，记为d，总牛数为4。 第5年b成熟了，a和b分别生了新的小母牛，总牛数为6； 第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9。 【要求】对以上所有的问题，请实现时间复杂度O(logN)的解法。 有 $F(N)=F(N-1)+F(N-3)$ 用一个矩阵乘法，且状态矩阵为$3*3$ public int c3(int n){ if(n&lt;1){ return 0; } if(n==1||n==2||n=3){ return n; } int base[][]={{1,1,0},{0,0,1},{1,0,0}}; //构造矩阵 int [][] res = matrixPower(base,n-3); //矩阵n-3次方 return 3*res[0][0]+2*res[1][0]+res[2][0]; } 矩阵的最小路径和题目描述 有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。 给定一个矩阵map及它的行数n和列数m，请返回最小路径和。 EG： 1 、3 、5 、9 8 、1 、3、4 5、0、6、1 8、8、4、0 经典动态规划方法最终生成的dp矩阵如下： 1、4、9、18 9、5、8、12 14、5、11、12 22、13、15、12 因为第一行和第一列只有一条路走，就是一直沿着走； 第二行，第二列开始就是选择从上往下还是从左往右走； 每次都把每一步的最小路径加起来 时间复杂度$O(MN)$ ，空间复杂度$O(MN)$ public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,3,5,9}, {8,1,3,4}, {5,0,6,1}, {8,8,4,0}}; System.out.println(minPathSum1(m)); } public static int minPathSum1(int [] []m){ if (m == null || m.length == 0 || m[0]==null || m[0].length==0) { return 0; } int row=m.length; int col=m[0].length; int [][] dp=new int [row][col]; dp[0][0]=m[0][0]; for(int i=1;i&lt;row;i++){ dp[i][0]=dp[i-1][0]+m[i][0]; } for(int j=1;j&lt;col;j++){ dp[0][j]=dp[0][j-1]+m[0][j]; } for(int i=1;i&lt;row;i++){ for(int j=1;j&lt;col;j++){ dp[i][j]=Math.min(dp[i][j-1]+m[i][j],dp[i-1][j]+m[i][j]); } } return dp[row-1][col-1]; } } 压缩空间方法时间复杂度$O(M*N)$ ，空间复杂度$O(min ( M,N ))$ public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,3,5,9}, {8,1,3,4}, {5,0,6,1}, {8,8,4,0}}; System.out.println(minPathSum1(m)); } public static int minPathSum1(int [] []m){ if (m == null || m.length == 0 || m[0]==null || m[0].length==0) { return 0; } int more = Math.max(m.length,m[0].length); int less= Math.min(m.length,m[0].length); boolean rowmore=more==m.length; int arr[] = new int [less]; arr[0]=m[0][0]; for(int i=1;i&lt;less;i++){ arr[i]=arr[i-1]+(rowmore?m[0][i]:m[i][0]); } for(int i=1;i&lt;more;i++){ arr[0]=arr[0]+(rowmore?m[i][0]:m[0][i]); for(int j=1;j&lt;less;j++){ arr[j]=Math.min(arr[j],arr[j-1])+(rowmore?m[i][j]:m[j][i]); } } return arr[less-1]; } } 换钱的最少货币数题目： 给定数组arr, arr中所有的值都为正数且不重复。每个值代表一中面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数。 思路: 如果arr的长度为N, 则生成一个行数为N, 列数为aim+1的动态规划表dp[N][aim+1], dp[i][j]的含义为:在可以任意使用arr[0…i]货币的情况下，组成j所需的最小张数。 设: arr=[5,2,3,1] aim = 5 1.dp[0..N-1][0]的值表示找钱数为0时需要的最少张数，所以全设为0。（矩阵的第一列） 0 0 0 0 0 0 dp= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ​ 2.dp[0][0…aim]的值表示只能使用arr[0]货币也就是5的情况下，找0 ,1,2,3,4,5的钱的情况下。其中无法找开的一律设为32位的最大值，记为max. 0 max max max max 1 dp= 0 0 0 3.剩下的位置依次从左到右，再从上到下计算。假设计算到(i,j)位置，dp[i][j]的值可能来自下面的情况: 完全不使用当前货币arr[i]情况系的最少张数，即dp[i-1][j]的值 只使用一张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-arr[i]]+1 其中 j-arr[i]的值为使用了一张arr[i]后，还需要找多少钱。 i-1是指使用arr[i]之前的钱来兑换 只使用两张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-2*arr[i]]+2 只使用三张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-3*arr[i]]+3 所有情况中，取最小的纸张数。所以: dp[i][j] = min{dp[i-1][j], dp[i-1][j-k*arr[i]]} + k ==&gt; dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-x*arr[i]]+x (x &gt;= 1)}} ==&gt; 设x-1 = y &gt;= 0 ==&gt; x = y +1代入得 dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-arr[i]-y*arr[i]+y+1 (y&gt;=0)}} 又因为min{dp[i-1][j-arr[i]-y*arr[i]+ y (y&gt;=0)] =&gt; dp[i][j-arr[i]] 因为其中 dp[i-1][j-y*arr[i]+y] = dp[i][j] 最终有:dp[i][j] = min{dp[i-1][j], dp[i][j-arr[i]+1]} 如果 j-arr[i] &lt; 0,即发生越界。 说明arr[i]太大了，用一张都会超出钱数j，所以令dp[i][j]=dp[i-1][j]即可。 0 max max max max 1 dp = 0 max 1 max 2 1 0 max 1 1 2 1 0 1 1 1 2 1 public class CircleDynamic { public static void main(String [] args){ int [] m= {5,2,5,3}; int aim = 15; System.out.println(minCoins(m,aim)); } public static int minCoins(int [] arr,int aim){ if(arr==null || arr.length==0|| aim&lt;0){ return -1; } int n=arr.length; int max=Integer.MAX_VALUE; int [][] dp=new int [n][aim+1]; for(int j=1;j&lt;aim;j++){ dp[0][j]=max; if(j-arr[0]>=0 &amp;&amp; dp[0][j-arr[0]]!=max){ dp[0][j]=dp[0][j-arr[0]]+1; } } int left = 0; for(int i=1;i&lt;n ;i++){ for(int j=1;j&lt;aim;j++){ left=max; if(j-arr[i]>=0&amp;&amp;dp[i][j-arr[i]]!=max){ left=dp[i][j-arr[i]]+1; } dp[i][j]=Math.min(left,dp[i-1][j]); } } for(int i=0;i&lt;n ;i++){ for(int j=0;j&lt;aim;j++){ System.out.print(dp[i][j]+ \" \" ); if(j==aim-1){ System.out.println(\" \"); } } } return dp[n-1][aim] !=max ?dp[n-1][aim-1]:-1; } } Result: 0 2147483647 2147483647 2147483647 2147483647 1 2147483647 2147483647 2147483647 2147483647 2 2147483647 2147483647 2147483647 2147483647 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 1 2 1 2 2 2 3 2 3 3 3 4 4 数组中最长的连续数字序列给定一个无序的整数序列， 找最长的连续数字序列。 例如： 给定[100, 4, 200, 1, 3, 2], 最长的连续数字序列是[1, 2, 3, 4]。 输出4. public class Main { public static void main(String[] args) { int[] arr = {100,4,200,1,3,2}; System.out.println(longestConsecutive(arr)); } public static int longestConsecutive(int [] arr){ if(arr.length==0||arr==null){ return 0; } int max=1; HashMap&lt;Integer,Integer> map=new HashMap&lt;Integer,Integer>(); for(int i=0;i&lt;arr.length;i++){ if(!map.containsKey(arr[i])){ map.put(arr[i],1); if(map.containsKey(arr[i]-1)){ max=Math.max(max,merge(map,arr[i]-1,arr[i])); } if(map.containsKey(arr[i]+1)){ max=Math.max(max,merge(map,arr[i],arr[i]+1)); } } } return max; } public static int merge(HashMap&lt;Integer,Integer> map,int less,int more){ //计算左边有几个数 int left=less-map.get(less)+1; //计算右边有几个数 int right=more+map.get(more)-1; //合计 int len=right-left+1; //标记 map.put(left,len); map.put(right,len); return len; } } 龙于地下城游戏问题给定一个二维数组map，含义是一张地图，例如： {{-2,-3,3}, {-5,-10,1}, {0,30,-5}} 游戏规则如下： 骑士从左上角出发，每次只能向下或者向右，直到右下才能见到公主； 每个格子代表骑士遭遇的事件，如果是负数，代表消耗血量，如果是正数，代表血瓶； 骑士走到任何一个位置，血量都不能低于1。 为了让骑士见到公主，骑士初始血量最少为多少？ 只能往下或往右，需要一个辅助数组dp[][] 来计算。那么可以逆着来计算。 public class Main { public static void main(String[] args) { int[][] arr = { {-2,-3,3}, {-5,-10,1}, {0,30,-5} }; System.out.println(minHP(arr)); } public static int minHP(int [] [] arr){ if(arr.length==0||arr==null){ return 1; } int row=arr.length; int col=arr[0].length; int[][] dp=new int [row--][col--]; dp[row][col]=arr[row][col]>0?1:1-arr[row][col]; for(int j=col-1;j>=0;j--){ dp[row][j]=Math.max(dp[row][j+1]-arr[row][j],1); //计算初步差异值 } int right=0; int down=0; for(int i=row-1;i>=0;i--){ dp[i][col]=Math.max(dp[i+1][col]-arr[i][col],1); //计算初步上下差异值 for(int j=col-1;j>=0;j--){ right=Math.max(dp[i][j+1]-arr[i][j],1); //向右走 down=Math.max(dp[i+1][j]-arr[i][j],1); //向下走 dp[i][j]=Math.min(right,down); //取最小的差异值 } } return dp[0][0]; } } 最长公共子串问题所谓最长公共子串，比如 串 str1=”1AB2345CD” 串 str2=”12345EF”; 则它们的最长公共子串为串 “2345”,输出4 public class Main { public static void main(String[] args) { String str1=\"1AB2345CD\"; String str2=\"12345EF\"; System.out.println(getdp(str1,str2)); } public static int getdp(String str1,String str2){ int dp[][]=new int [str1.length()][str2.length()]; for(int i=0;i&lt;str1.length();i++){ if(str1.charAt(i)==str2.charAt(0)){ dp[i][0]=1; } } for(int j=1;j&lt;str2.length();j++){ if(str1.charAt(0)==str2.charAt(j)){ dp[0][j]=1; } } int max=0; for(int i=1;i&lt;str1.length();i++){ for(int j=1;j&lt;str2.length();j++){ if(str1.charAt(i)==str2.charAt(j)){ dp[i][j]=dp[i-1][j-1]+1; } System.out.print(dp[i][j]+\" \"); max=Math.max(max,dp[i][j]); } System.out.println(\"\"); } return max; } } --- 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 3 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 跳跃游戏package RecursiveAndDynamic; /** * Created by zdmein on 2017/9/14. * 跳跃游戏 给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 给出数组A = [2,3,1,1,4]，最少到达数组最后一个位置的跳跃次数是2 (从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次) 思路：贪心算法; * 从第一个数开始, 寻找可以一个可以跳最远的点; * 例1：3 1 2 4 1 0 0 * 1.从第一个位置0,可以跳到位置1和位置2和位置3; * 2.如果跳到位置1,那么最远就可以跳到位置(1+1); * 3.如果跳到位置2,那么最远就可以跳到位置(2+2); * 4.如果跳到位置3,那么最远就可以跳到位置(3+4); * 5.故选择跳到位置3 ,重复1.2.3步; * * 算法分析： * 1.如果选择跳到位置3 ,就无法跳到位置2和位置3, 那么会不会因此错过最优解？ 答：不会！ * 2.因为任意位置1和位置2能到达的位置, 位置3都可以到达; * 3.故不会错过最优解; */ public class jump1 { public static void main(String [] args){ int [] arr={3,2,3,1,1,4}; System.out.println(jump(arr)); } public static int jump(int [] arr){ if(arr==null||arr.length==0){ return 0; } int jump=0; int cur=0; int next=0; for (int i=0;i&lt;arr.length;i++){ if(cur&lt;i){ jump++; cur=next; } next=Math.max(next,i+arr[i]); } return jump; } } ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《操作系统概念》","slug":"读书笔记之《操作系统概念》","date":"2017-08-09T06:54:40.000Z","updated":"2017-08-09T09:00:12.665Z","comments":true,"path":"2017/08/09/du-shu-bi-ji-zhi-cao-zuo-xi-tong-gai-nian/","link":"","permalink":"http://zhoudamin.github.io/2017/08/09/du-shu-bi-ji-zhi-cao-zuo-xi-tong-gai-nian/","excerpt":"非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。","text":"非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。 第二部分 进程管理第四章 进程进程状态 创建、运行、等待、就绪、终止 进程：一个具有单个控制线程的执行程序。 第五章 线程线程：是CPU使用的基本单元 多线程编程优点： 响应度高 资源共享 经济 多处理器体系结构的利用 多线程模型 多对一 Many-to-one 优点： 线程之间切换快 可以用用户自己的方式管理线程库 缺点： 如果一个线程执行了阻塞系统调用，那么整个系统就会阻塞。 一对一 One - to - one 优点：更好的并发能力 缺点：创建一个用户线程就需要创建一个相应的内核线程 多对多 Many-to - many 优点：没有many-to-One和 one-to -one的缺点 线程池 在进程开始时创建一定数量的线程，并放入到池中坐以等待工作。 如果池中没有可用的线程，那么服务器会一直等待直到有空线程为止。 优点： 用现有线程处理请求要比等待创建新的线程要快 线程池限制了在任何时候可存在线程的数量 第七章 进程同步多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为竞争条件。 两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。当出现这样的状态时，这些进程称为死锁（deadlocked）。 第八章 死锁 必要条件 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。 占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。 非抢占：资源不能被抢占；即，只有进程完成其任务之后，才会释放其资源。 循环等待：一组进程，循环等待下一个的资源。 所有四个条件必须同时满足才会出现死锁。 为了预防死锁，要确保这四个必要条件中的一个不成立。 死锁恢复 进程终止 终止所有死锁进程 一次只终止一个进程直到取消死锁循环为止 资源抢占 选择一个牺牲品 回滚 饥饿 从理论上来说，有三种方法可以处理死锁： 使用一些协议来预防或避免死锁，确保系统永远都不会进到死锁状态。 允许系统进入死锁状态，检测死锁，并恢复。 忽视所有问题，并假设系统中永远都不会出现死锁。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书","slug":"读书","permalink":"http://zhoudamin.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://zhoudamin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"读书笔记之《程序员代码面试指南（栈和队列）》","slug":"读书笔记之《程序员代码面试指南（栈和队列）》","date":"2017-08-09T01:33:15.000Z","updated":"2018-08-03T14:54:36.720Z","comments":true,"path":"2017/08/09/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zhan-he-dui-lie/","link":"","permalink":"http://zhoudamin.github.io/2017/08/09/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zhan-he-dui-lie/","excerpt":"第一章、栈和队列","text":"第一章、栈和队列 有getMin功能的栈使用两个栈，一个用来保存当前栈中的元素，记为stackData，一个用来保存每一步的最小值，即为stackMin. public class MyStack { public static void main (String [] args){ int [] Arr = {1,2,3}; push(Arr[0]); push(Arr[1]); System.out.println(pop()+\" \" + getMin()); } private static Stack&lt;Integer > stackData=new Stack&lt;Integer>(); private static Stack &lt;Integer> stackMin =new Stack&lt;Integer>(); public static void push(int newNum){ stackData.push(newNum); if(stackMin.isEmpty()){ stackMin.push(newNum); }else if(newNum&lt;stackMin.peek()){ stackMin.push(newNum); } } public static int pop(){ if(stackData.peek()==stackMin.peek()){ stackMin.pop(); } return stackData.pop(); } public static int getMin(){ if(stackMin.isEmpty()){ throw new RuntimeException(\"you stack is empty.\"); } return stackMin.peek(); } } 由两个栈组成的队列 一个栈stackPush专门用来存数据 一个栈stackPop专门用来取数据 每次取数据前stackPop必须清空 每次stackPush压入数据到stackPop中时，必须一次性全部压入 public class MyStack { private static Stack&lt;Integer > stackPush =new Stack&lt;Integer>(); private static Stack &lt;Integer> stackPop =new Stack&lt;Integer>(); public static void add(int pushInt){ stackPush.push(pushInt); } public static int poll(){ if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty()){ throw new RuntimeException(\"Queue is Empty ！\"); }else if(stackPop.isEmpty()){ while (!stackPush.isEmpty()){ stackPop.push(stackPush.pop()); } } return stackPop.pop(); } public static int peek(){ if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty()){ throw new RuntimeException(\"Queue is Empty ！\"); }else if(stackPop.isEmpty()){ while (!stackPush.isEmpty()){ stackPop.push(stackPush.pop()); } } return stackPop.peek(); } } 用栈解决汉诺塔问题修改后的汉诺塔问题不能从左直接到右，也不能从右直接到左，必须通过中间； 左、中、右三个地点依次记为LS，LM，RS； 则仅有四个动作：LS–&gt;LM 、LM–&gt;LS 、LM–&gt;RS 、RS–&gt;LM 动作：某一个栈（from）把栈顶元素弹出 ，然后压入到另一个栈里（to），作为这一个栈（to）的栈顶。 两个原则： 一个动作能发生的先决条件是不违反小压大的原则。 还一个是相邻不可逆原则。 意思是，L-&gt;M ，那么M-&gt;L，就重复了，如果要最小步法完成，必须不走重复步。 核心 游戏的第一个动作一定是L-&gt;M 在走出任何最小步数过程中，四个动作，只有一个动作不违反原则，其余三个一定会违反。 public class MyStack { public enum Action { No , LToM , MToL , MToR , RToM } public static int hannoProblem(int num , String left , String mid ,String right){ Stack&lt;Integer > ls =new Stack&lt;Integer>(); Stack &lt;Integer> ms =new Stack&lt;Integer>(); Stack &lt;Integer> rs =new Stack&lt;Integer>(); ls.push(Integer.MAX_VALUE); ms.push(Integer.MAX_VALUE); rs.push(Integer.MAX_VALUE); for( int i=num ;i>0;i--){ ls.push(i); } Action [] record = {Action.No}; int step = 0; while (rs.size()!=num+1){ step+= fStackTotStack(record,Action.MToL,Action.LToM,ls,ms , left , mid); step+= fStackTotStack(record,Action.LToM,Action.MToL,ms,ls , mid , left); step+= fStackTotStack(record,Action.RToM,Action.MToR,ms,rs , mid , right); step+= fStackTotStack(record,Action.MToR,Action.RToM,rs,ms , right, mid); } return step; } public static int fStackTotStack(Action [] record , Action preNoAct , Action nowAct , Stack&lt;Integer> fStack , Stack&lt;Integer> tStack, String from , String to){ if(record[0] != preNoAct &amp;&amp; fStack.peek()&lt;tStack.peek()){ tStack.push(fStack.pop()); System.out.println(\"Move\"+\" \"+tStack.peek()+\" \"+\"from\" +\" \"+ from +\" \"+ \"to\" +\" \"+ to); record[0]=nowAct; return 1; } return 0; } public static void main (String [] args){ int num=2; String left=\"left\"; String mid =\"mid\"; String right= \"right\"; System.out.println(hannoProblem(num,left,mid,right)); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《深入理解Java虚拟机》","slug":"读书笔记之《深入理解Java虚拟机》","date":"2017-08-08T02:35:12.000Z","updated":"2018-08-03T14:55:24.082Z","comments":true,"path":"2017/08/08/du-shu-bi-ji-zhi-shen-ru-li-jie-java-xu-ni-ji/","link":"","permalink":"http://zhoudamin.github.io/2017/08/08/du-shu-bi-ji-zhi-shen-ru-li-jie-java-xu-ni-ji/","excerpt":"","text":"第13章 线程安全与锁优化分类1. 不可变不可变的对象一定是线程安全的 不可变带来的安全性是最简单和最纯粹的 基本数据类型：final 对象：java.lang.String 2. 绝对线程安全在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。 Java.util.Vector是一个线程安全的容器，因为它的add()、get()、size()这类方法都是被synchronized修饰的。 在多线程中，还需在调用端做额外的同步措施。 3. 相对线程安全通常意义上讲的线程安全 在Java中，大部分的线程安全类都属于这种类型，如Vector、HashTable、Collection、的synchronizedCollection()方法包装的集合等。 4. 线程兼容指对象本身并不是线程安全的，但是可以在同步端正确使用同步手段保证对象在并发环境中可以安全地使用。 Java API 中大部分的类都是属于线程兼容的，如Vector 和 HashTable相对应的集合类ArrayList 和 HashMap 等。 5. 线程对立指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 一个线程对立的例子是Thread类的 suspend() 和 resume() 方法。 线程安全实现方法互斥同步Mutual Exclusion &amp; Synchronization 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信息量的时候）线程使用。 互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信息量（Semaphore）都是主要的互斥实现方式。 互斥是因，同步是果。互斥是方法，同步是目的。 互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。 Synchronized在Java中，最基本的互斥同步手段就是synchronized关键字 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成） ReentrantLock重人锁 原生语法层面的互斥锁。 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。只需要多次调用newCondition()方法即可。 非阻塞同步乐观的并发策略 先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。 测试并设置 获取并增加 交换 比较并交换 加载链接/条件存储 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://zhoudamin.github.io/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://zhoudamin.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}]},{"title":"读书笔记之《Java编程思想》","slug":"读书笔记之《Java编程思想》","date":"2017-08-08T01:07:57.000Z","updated":"2017-08-10T09:47:54.678Z","comments":true,"path":"2017/08/08/du-shu-bi-ji-zhi-java-bian-cheng-si-xiang/","link":"","permalink":"http://zhoudamin.github.io/2017/08/08/du-shu-bi-ji-zhi-java-bian-cheng-si-xiang/","excerpt":"","text":"17. 容器Set存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。 Set接口不保证维护元素的次序 Map映射表（关联数组）的基本思想是维护的是键-值（对）关联，因此可以用键来查找值。 基本方法 Map.put() Map.get() 21. 并发 阻塞： 如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程阻塞了。 Java的线程机制是抢占式的。 一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务。 LiftOff任务将显示发射之前的倒计时： public class LiftOff implements Runnable{ protected int countDown = 10; private static int taskCount =0; private final int id=taskCount++; public LiftOff(){ this.countDown=countDown; } public String status(){ return \"#\"+id +\"(\"+(countDown>0 ? countDown:\"LiftOff ！\")+\").\"; } public void run(){ while(countDown-->0){ System.out.println(status()); Thread.yield(); } } } /*************************************************************/ public class ThreadPro { public static void main(String [] args){ for(int i=0;i&lt;5;i++) new Thread(new LiftOff()).start(); System.out.println(\"Waiting for LiftOff !\"); } } 执行器（Executor） Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。 优先级 线程的优先级将该线程的重要性传递给了调度器。 尽管CPU处理现有线程集的顺序使不确定的，但是调度器将倾向于让优先权最高的线程先执行。 另外会让优先级较低的线程执行的频率较低，故而优先权不会导致死锁。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书","slug":"读书","permalink":"http://zhoudamin.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2017-07-27T08:38:39.000Z","updated":"2017-10-02T11:58:45.226Z","comments":true,"path":"2017/07/27/shu-ju-jie-gou-yu-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2017/07/27/shu-ju-jie-gou-yu-suan-fa/","excerpt":"一些基本的数据结构与算法","text":"一些基本的数据结构与算法 数据结构(1)数组 (Array) 在程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。 这些按序排列的同类数据元素的集合称为数组。 在Ｃ语言中， 数组属于构造数据类型。 一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。 因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。 (2)栈 (Stack) 是只能在某一端插入和删除的特殊线性表。 它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶， 需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。 (3)队列 (Queue) 一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。 (4)链表 (Linked List) 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 (5)树 (Tree) 是包含n（n>0）个结点的有穷集合K，且在K中定义了一个关系N，N满足 以下条件： （1）有且仅有一个结点 k0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。 （2）除K0外，k中的每个结点，对于关系N来说有且仅有一个前驱。 （3）K中各结点，对关系N来说可以有m个后继（m>=0）。 (6)图 (Graph) 图是由结点的有穷集合V和边的集合E组成。 其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对， 若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 链表定义结点class Node { Node next=null; int data; public Node (int data){ this.data=data; } }找单链表中倒数第K个元素一次遍历的方法：用2个指针，第一个指针先走K步；然后2个指针一起走；直到第一个指针到达尾部。 public Node findElem(Node head,int k){ if(k&lt;1||k&gt;this.length()){ return null; } Node p1=head; Node p2=head; for(int i=0;i&lt;k-1;i++){ p1=p1.next; } while (p1!=null){ p1=p1.next; p2=p2.next; } return p2; }从链表中删除重复数据方法1：HashTable需要额外存储空间时间复杂度较低 public void deleteDuplecate(Node head){ Hashtable&lt;Integer,Integer&gt; table = new Hashtable&lt;Integer,Integer&gt;(); Node tmp=head; Node pre=null; while (tmp!=null){ if(table.containsKey(tmp.data)){ pre.next=temp.next; }else { table.put(tmp.data,1); pre=tmp; } tmp=tmp.next; } }方法2：双指针法对链表进行双重循环外循环正常遍历链表，当前设为cur内循环从cur开始遍历若遇到与cur所指向结点值相同则删除这个结点 public void deleteDuplecate(Node head){ Node cur=head; while(cur!=null){ Node q=cur; while(q.next!=null){ if(cur.data==q.next.data){ q.next=q.next.next; }else { q=q.next; } } cur=cur.next; } }在不知道头指针的情况下删除指定结点 若待删除结点为链表尾结点，则无法删除，因为前驱next指针为空 若删除不是尾结点，则先交换该节点和后继结点，再删除！public boolean deleteNode(Node n){ if(n==null || n.next==null){ return false; } int temp=n.data; n.data=n.next.data; n.next.data=temp; //先交换当前与后继data n.next=n.next.next; //再指向下下结点 return true; } 判断两个链表是否相交如果两个链表相交，那么他们一定有着相同的尾结点。分别遍历两个链表，记录他们的尾结点，如果他们的尾结点相同，那么这两个链表相交，否则不相交。 public boolean isIntersect (Node h1, Node h2){ if(h1==null || h2==null){ return false; } //遍历链表 1 Node tail1=h1; while (tail1.next!=null){ tail1=tail1.next; } //遍历链表 2 Node tail2=h2; while (tail2.next!=null){ tail2=tail2.next; } return tail1==tail2; }检测一个链表是否有环fast每次进2slow每次进1 public boolean isLoop(Node head){ Node fast=head; Node slow=head; if(fast==null){ return false; } //如果无环，就总会到尾巴然后退出 //如果有环，就总会追上 while (fast!=null &amp;&amp; fast.next!=null){ fast=fast.next.next; slow=slow.next; if(fast==slow){ return true; } } return !(fast==null &amp;&amp; fast.next==null); } } 栈和队列实现栈public class MyStack&lt;E>{ private Object[] stack; private int size; public MyStack(){ stack=new Object[10]; } //判断堆栈是否为空 public boolean isEmpty(){ return size==0; } public E peek(){ if(isEmpty()){ return null; } return (E) stack[size-1]; } public E pop(){ E e=peek(); stack[size-1]=null; size--; return e; } public E push(E item){ ensureCapacity(size+1);//检查容器 stack[size++]=item; return item; } //判断数组是否已满，若满，则扩容 private void ensureCapacity(int size){ int len=stack.length; if(size>len){ int newlen=10;//每次扩容10 stack= Arrays.copyOf(stack,newlen); } } } 用O(1)的时间复杂度求栈中最小元素栈–后进先出因此pop和push只对栈顶元素进行操作使用两个栈结构，一个栈用来存储数据另一个栈用来存储栈的最小元素 入栈当前入栈元素比之前栈中最小值还小，则压入最小栈中 出栈如果当前出栈的元素是最小值，则把最小值栈的最小值也出栈，留下的就是栈的第二小值成了最小值 public class MyStack1{ MyStack&lt;Integer> elem; MyStack&lt;Integer> min; public MyStack1(){ elem=new MyStack&lt;Integer>(); min = new MyStack&lt;Integer>(); } public void push(int data){ elem.push(data); if(min.isEmpty()){ min.push(data); }else if(data&lt;min.peek()){ min.push(data); } } public int pop() { int topData = elem.peek(); elem.pop(); if (topData == this.min()) { min.pop(); } return topData; } public int min(){ if(min.isEmpty()){ return Integer.MAX_VALUE; }else { return min.peek(); } } } 排序位运算用移位操作实现乘法运算把一个数向左移动n位相当于把该数乘以2的n次方 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(\"n : \"); int n= scanner.nextInt(); System.out.println(powerN(m,n)); } public static int powerN(int m,int n){ for(int i=0;i&lt;n ; i++ ){ m=m&lt;&lt;1; } return m; } } 判断一个数是否为2的n次方最直观的方法—直接递增对比 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(power2(m)); } public static boolean power2(int m){ if(m&lt;1) return false; int i=1; while (i&lt;=m){ if(i==m) return true; i=i&lt;&lt;1; } return false; } } 效率更高的方法2的n次方，二进制中只有一个1，所以用 m&amp;(m-1) 就可以判断了 int num=m&amp;(m-1)； return num==0; 二进制中1的个数首先判断最后一位是否为1，是，则计数加1；然后右移丢弃最后一位 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(countOne(m)); } public static int countOne(int m){ int count=0; while (m>0){ if((m&amp;1)==1){ count++; } m>>=1; } return count; } } 更好的方法每与一次都消除1个1eg: 11001100 &amp; 1011 = 1000 , conut = 11000 &amp; 0111 = 0000 , count = 2 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(countOne(m)); } public static int countOne(int m){ int count=0; while (m>0){ if(m!=0){ m=m&amp;(m-1); count++; } } return count; } } 数组判断一个数组中数值是否连续相邻一个数组序列 元素取值范围为0-65535 相同数值不会重复出现 0可以反复出现 设计一种算法，从数组中随机选取5个数值，判断这5个数值是否连续相邻 注意： 5个数值允许是乱序的，如{8,7,5,0,6} 0可以通配任意数值 0可以多次出现 全0算连续，只有一个非0算连续 思路： 如果没有0的存在，最大值与最小值相差必须等于4 如果0存在，则最大和最小相差小于4 public class Main { public static boolean IsContinuous(int[] array) { int min=-1; int max=-1; for(int i=0;i&lt;array.length;i++){ if(array[i]!=0) { if (max &lt; array[i] || max == -1) { max = array[i]; } if (min > array[i] || min == -1) { min = array[i]; } } } return (max-min)&lt;=4; } public static void main(String[] args) { int[] array = {8,7,5,0,6}; int k=2; System.out.print(IsContinuous(array)); } } 寻找数组中的最小值与最大值取双元素法维持两个全局变量Max，Min每次比较相连两个数将最大与Max比将最小与Min比遍历比较次数为1.5N public class Main { static int Max=Integer.MIN_VALUE; static int Min=Integer.MAX_VALUE; public static void GetMaxandMin(int [] array) { for (int i = 0; i &lt; array.length; i += 2) { if (i + 1 > array.length - 1) { if (array[i] > Max) Max = array[i]; if (array[i] &lt; Min) Min = array[i]; } else { if (array[i] > array[i + 1]) { if (array[i] > Max) Max = array[i]; if (array[i + 1] &lt; Min) Min = array[i + 1]; } if (array[i] &lt; array[i + 1]) { if (array[i + 1] > Max) Max = array[i + 1]; if (array[i] &lt; Min) Min = array[i]; } } } } public static void main(String[] args) { //int [] array= {3,5,6,8,1,4,2}; int [] array= {3,5,6}; GetMaxandMin(array); System.out.println(\"Max = \"+ Max); System.out.println(\"Min = \"+ Min); } } 求最大子数组之和连续子数组，输出最大连续子数组之和 public class Main { public static int[] maxSubArray(int[] array) { int begin = 0; int end = 0; int nStart = 0; int max = Integer.MIN_VALUE; int nSum = 0; for (int i = 0; i &lt; array.length; i++) { if (nSum &lt; 0) { nSum = array[i]; nStart = i; } else { nSum += array[i]; } if (nSum > max) { max = nSum; begin = nStart; end = i; } } int[] num = {begin, end}; return num; } public static void main(String[] args) { int [] array= {3,5,6,-24,1,4,2}; // int [] array= {3,5,6}; int [] num=maxSubArray(array); for (int i=num[0];i&lt;=num[1];i++) System.out.println(array[i]); } } 找出数组中重复元素最多的数 public static int findMostFreInArray(int[] array) { Map&lt;Integer ,Integer > map=new HashMap&lt;Integer,Integer>(); for(int i=0;i&lt;array.length;i++){ if (map.containsKey(array[i])) { map.put(array[i],map.get(array[i])+1); }else { map.put(array[i],1); } } 找出数组中只出现一次的数字一个数组中除了一个数字外，其他数字都出现了2次。 异或运算：任何数字异或它自己都等于0 如果从头到尾异或，那么最后得到的结果就是那个单一数字，其余都被抵消！ public class Main { public static int findNotDouble(int[] array) { int num = array[0]; for (int i = 1; i &lt; array.length; i++) { num ^= array[i]; } return num; } public static void main(String[] args) { int[] array = {3,3,4,76,4,7,76}; int num = findNotDouble(array); System.out.println(num); } } 求数组中两两相加等于20的组合种数先排序 begin end 同时遍历 public class Main { public static void findNotDouble(int[] array,int p) { Arrays.sort(array); int begin=0; int end=array.length-1; int num=0; while (begin&lt;end){ if (array[begin]+array[end]==p) { System.out.println(array[begin]+\",\"+array[end]); begin++; end--; }else if(array[begin]+array[end]>p){ end--; }else { begin++; } } } public static void main(String[] args) { int[] array = {3,3,4,76,4,7,17,16,76}; int point=20; findNotDouble(array,point); } } 把一个数组循环右移k位把12345678右移2位 得到78123456 把78 和123456 看成2个整体,右移k位就是把两部分交换。 只进行三次逆序操作，时间复杂度为O（n）。 逆序数组子序列123456，变成65432178 逆序78，变成65432187 全部逆序，变成78123456 public class Main { public static void reverse(int[] array,int p) { reverpart(array,0,array.length-p-1); reverpart(array,array.length-p,array.length-1); reverpart(array,0,array.length-1); } public static void reverpart(int [] arr,int a,int b){ int temp=0; while (a&lt;b){ temp=arr[a]; arr[a]=arr[b]; arr[b]=temp; a++; b--; } } public static void main(String[] args) { int[] array = {1,2,3,4,5,6,7,8}; int point=2; reverse(array,point); for(int i=0;i&lt;array.length;i++){ System.out.print(array[i]+\" \"); } } } 字符串实现字符串的反转how are you you are how 两次反转过程 how are you uoy era woh you are how public class List { public static void main(String[] args){ String str=\"how are you\"; System.out.println(swapword(str)); } public static String swapword(String str){ char [] cStr=str.toCharArray(); swap(cStr,0,cStr.length-1); int begin=0; for (int end=1;end&lt;cStr.length;end++){ if(cStr[end]==' '){ swap(cStr,begin,end-1); begin=end+1; end++; } if(end==cStr.length-1){ swap(cStr,begin,end); } } return new String(cStr); } public static void swap(char [] str,int n ,int m){ while (n&lt;m){ char temp=str[n]; str[n]=str[m]; str[m]=temp; n++; m--; } } } 判断两个字符串是否由相同字符组成aaaabbc和abcbaaa是不是相同的字符组成 public class List { public static void main(String[] args){ String str1=\"aaaabbce\"; String str2=\"abcbaaad\"; System.out.println(compare(str1,str2)); } public static boolean compare(String str1,String str2){ int [] num=new int [256]; int str1len=str1.length()-1; int str2len=str2.length()-1; while (str1len>=0){ // char temp=str1.charAt(0); num[str1.charAt(str1len)]++; str1len--; } while (str2len>=0){ // char temp=str1.charAt(0); num[str2.charAt(str2len)]--; str2len--; } for (int i=0;i&lt;num.length;i++){ if(num[i]!=0){ return false; } } return true; } } 删除字符串中重复的字符简单的用数组[256]去判断 public class List { public static void main(String[] args){ String str1=\"aaaabbce\"; System.out.println(removeDuplicate(str1)); } public static String removeDuplicate(String str){ int [] num=new int [256]; char [] cStr=new char[str.length()]; int j=0; for(int i=0;i&lt;str.length();i++){ if(num[str.charAt(i)]==0){ num[str.charAt(i)]++; cStr[j++]=str.charAt(i); } } return new String(cStr,0,j); } } 统计一行字符中有多少个单词用一个count 字母前有空格，则表示单词开始 count++ 字母前还是字母，则还没结束该单词 public class List { public static void main(String[] args){ String str1=\"how are you\"; System.out.println(wordCount(str1)); } public static int wordCount(String str){ int count =0; int i=1; for(;i&lt;str.length();i++){ if(str.charAt(i-1)!=' '&amp;&amp;str.charAt(i)==' '){ count++; } } if( str.charAt(i-1)!=' '){ count++; } return count; } } 二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhoudamin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java程序员面试笔试宝典","slug":"Java程序员面试笔试宝典","permalink":"http://zhoudamin.github.io/tags/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"书籍","slug":"书籍","permalink":"http://zhoudamin.github.io/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"常考面试算法题之贪心算法","slug":"常考面试算法题之贪心算法","date":"2017-07-22T08:56:46.000Z","updated":"2017-07-27T09:26:31.994Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-tan-xin-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-tan-xin-suan-fa/","excerpt":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。","text":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法基本思路1.建立数学模型来描述问题。 2.把求解的问题分成若干个子问题。 3.对每一子问题求解，得到子问题的局部最优解。 4.把子问题的解局部最优解合成原来解问题的一个解。 实现该算法的过程： 从问题的某一初始解出发； while 能朝给定总目标前进一步do 求出可行解的一个解元素； 由所有解元素组合成问题的一个可行解。 排序子序列牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2输入描述:输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。输出描述:输出一个整数表示牛牛可以将A最少划分为多少段排序子序列示例1输入61 2 3 2 2 1输出2 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int m = scanner.nextInt(); int[] num = new int[m]; for (int i = 0; i &lt; m; i++) { num[i] = scanner.nextInt(); } System.out.println(NewSort(m, num)); } public static int NewSort(int m, int[] num) { if (m &lt;= 0) { return -1; } int count = 1; int flags = 0; for (int i = 1; i &lt; m; i++) { if (num[i] &gt; num[i - 1]) { if(flags==0){ flags=1; } if(flags==-1){ flags=0; count++; } } else if (num[i] &lt; num[i - 1]) { if(flags==0){ flags=-1; } if(flags==1){ count++; flags=0; } } } return count; } }组队竞赛训练部队 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"http://zhoudamin.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"常考面试算法题之模拟实现","slug":"常考面试算法题之模拟实现","date":"2017-07-22T08:56:30.000Z","updated":"2017-07-23T03:30:41.774Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-mo-ni-shi-xian/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-mo-ni-shi-xian/","excerpt":"","text":"平衡数 消除重复元素 奇怪的表达式求值 变换次数 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"常考面试算法题之数学","slug":"常考面试算法题之数学","date":"2017-07-22T08:56:17.000Z","updated":"2017-07-27T10:57:11.220Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-shu-xue/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-shu-xue/","excerpt":"","text":"超级素数幂如果一个数字能表示为p^q(^表示幂运算)且p为一个素数,q为大于1的正整数就称这个数叫做超级素数幂。现在给出一个正整数n,如果n是一个超级素数幂需要找出对应的p,q。输入描述: 输入一个正整数n(2 ≤ n ≤ 10^18) 输出描述: 如果n是一个超级素数幂则输出p,q,以空格分隔,行末无空格。如果n不是超级素数幂，则输出No示例1输入27输出3 3 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"剩下数字个数 ：\"); long n=scanner.nextLong(); boolean flag=false; double p; for(int q=2;q*q&lt;n;q++){ p=Math.pow((double) n,1d/q); System.out.println(1d/q); System.out.println(1/q); if((long )p==p &amp;&amp; isPrimeNum((long)p)){ System.out.println((long)p+\" \"+q); flag=true; break; } } if(!flag){ System.out.println(\"No\"); } } public static boolean isPrimeNum(long num){ if (num&lt;=1){ return false; } for (int i=2;i*i&lt;=num;i++){ if(num%i==0){ return false; } } return true; } }用 1d 取double很关键！ 剩下数字个数 ： 27 0.5 0 0.3333333333333333 0 3 3找整除牛牛想在[a, b]区间内找到一些数满足可以被一个整数c整除,现在你需要帮助牛牛统计区间内一共有多少个这样的数满足条件？输入描述: 首先输入两个整数a,b,（-510^8 ≤ a ≤ b ≤ 510^8)接着是一个正整数c（1 &lt;= c &lt;= 1000） 输出描述: 输出一个整数表示个数。示例1输入0 14 5输出3 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"整数a ：\"); int a=scanner.nextInt(); System.out.println(\"整数b ：\"); int b=scanner.nextInt(); System.out.println(\"正整数c ：\"); int c=scanner.nextInt(); int count=0; for(int n=a/c ; n*c&lt;=b;n++ ){ if(c*n&gt;=a) { count++; } } System.out.println(count); } }魔力手环小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。示例1输入 3 21 2 3输出8 9 7 混合颜料最大的奇约数末尾0的个数Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"常考面试算法题之DFS/BFS","slug":"常考面试算法题之DFS-BFS","date":"2017-07-22T08:56:06.000Z","updated":"2018-04-25T03:37:12.482Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dfs-bfs/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dfs-bfs/","excerpt":"","text":"推箱子 工作安排 幸运的袋子 饥饿的小易 跳石板 地下迷宫 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://zhoudamin.github.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://zhoudamin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"常考面试算法题之动态规划","slug":"常考面试算法题之动态规划","date":"2017-07-22T08:55:42.000Z","updated":"2018-08-02T15:24:31.948Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dong-tai-gui-hua/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dong-tai-gui-hua/","excerpt":"","text":"猴子摘桃小猴子下山，沿着下山的路有一排桃树，每棵树都结了一些桃子。小猴子想摘桃子，但是又一些条件需要遵守，小瘦子只能沿着下山的方向走，不能回头，每棵树最多摘一个，而且一旦摘了一棵树的桃子，就不能再摘比这棵树结的桃子少的树上的桃子，那么小猴子最多能摘到几课桃子呢？距离说明，比如有五棵树，分别结了10，4，5，12，8棵桃子，那么小猴子最多能摘3颗桃子，来自于结了4，5，12颗桃子的桃树。 public class Main { public static void main(String[] args) { int[] m = {10,4,5,12,8}; int maxP[]=new int [m.length]; for(int j=0;j&lt;m.length;j++){ maxP[j]=1; for (int k=0;k&lt;j;k++){ if(maxP[k]+1>maxP[j] &amp;&amp; m[j]>m[k]){ maxP[j]=maxP[k]+1; } } } int maxPeach=1; for (int k=0;k&lt;maxP.length;k++){ if(maxPeach&lt;maxP[k]){ maxPeach=maxP[k]; } } System.out.println(maxPeach); } } 页码统计牛牛新买了一本算法书，算法书一共有n页，页码从1到n。牛牛于是想了一个算法题目：在这本算法书页码中0~9每个数字分别出现了多少次？输入描述: 输入包括一个整数n(1 ≤ n ≤ 1,000,000,000) 输出描述: 输出包括一行10个整数，即0~9这些数字在页码中出现的次数，以空格分隔。行末无空格。示例1输入 999输出 189 300 300 300 300 300 300 300 300 300创造新世界双核处理堆砖块不等式数列牛牛的数列牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。输入描述: 输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。 输出描述: 输出一个整数,表示最长的长度。示例1输入 6 7 2 3 1 5 6输出 5暗黑的字符串数字和为sum的方法数Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"常考面试算法题之暴力枚举","slug":"常考面试算法题之暴力枚举","date":"2017-07-22T03:22:56.000Z","updated":"2018-08-02T15:23:55.027Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-bao-li-mei-ju/","link":"","permalink":"http://zhoudamin.github.io/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-bao-li-mei-ju/","excerpt":"结合2017春招和秋招真题，以下几类算法题最常考，汇总了一下：","text":"结合2017春招和秋招真题，以下几类算法题最常考，汇总了一下： 好多鱼！牛牛有一个鱼缸。鱼缸里面已经有n条鱼，每条鱼的大小为fishSize[i] (1 ≤ i ≤ n,均为正整数)，牛牛现在想把新捕捉的鱼放入鱼缸。鱼缸内存在着大鱼吃小鱼的定律。经过观察，牛牛发现一条鱼A的大小为另外一条鱼B大小的2倍到10倍(包括2倍大小和10倍大小)，鱼A会吃掉鱼B。考虑到这个，牛牛要放入的鱼就需要保证：1、放进去的鱼是安全的，不会被其他鱼吃掉2、这条鱼放进去也不能吃掉其他鱼鱼缸里面已经存在的鱼已经相处了很久，不考虑他们互相捕食。现在知道新放入鱼的大小范围minSize,maxSize,牛牛想知道有多少种大小的鱼可以放入这个鱼缸。 输入描述:输入数据包括3行.第一行为新放入鱼的尺寸范围minSize,maxSize(1 ≤ minSize,maxSize ≤ 1000)，以空格分隔。第二行为鱼缸里面已经有鱼的数量n(1 ≤ n ≤ 50)第三行为已经有的鱼的大小fishSize[i](1 ≤ fishSize[i] ≤ 1000)，以空格分隔。 输出描述:输出有多少种大小的鱼可以放入这个鱼缸。考虑鱼的大小都是整数表示示例1输入 1 12 1 1输出 3import java.util.Random; import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(\"minSize :\"); int minSize = scanner.nextInt(); System.out.println(\"maxSize :\"); int maxSize = scanner.nextInt(); System.out.println(\"inNumber :\"); int inNumber = scanner.nextInt(); System.out.println(\"inFishSize[ ] :\"); int [] inFishSize = new int[inNumber]; for(int i=0;i&lt;inNumber;i++) { inFishSize[i]=scanner.nextInt(); } int count =0; for(int i=minSize;i&lt;=maxSize ;i++){ boolean flag=false; for(int j=0;j&lt;inNumber ;j++){ if(( i*2&lt;=inFishSize[j]&amp;&amp;inFishSize[j]&lt;=i*10 )||( inFishSize[j]*2&lt;=i &amp;&amp; inFishSize[j]*10&gt;=i )){ flag=true; break; } } if(!flag){ count++; } } System.out.println(count); } }DNA合成DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。碱基互补配对原则：A和T是配对的，C和G是配对的。如果两条碱基链长度是相同的并且每个位置的碱基是配对的，那么他们就可以配对合成为DNA的双螺旋结构。现在给出两条碱基链，允许在其中一条上做替换操作：把序列上的某个位置的碱基更换为另外一种碱基。问最少需要多少次让两条碱基链配对成功输入描述:输入包括一行：包括两个字符串,分别表示两条链,两个字符串长度相同且长度均小于等于50。输出描述:输出一个整数，即最少需要多少次让两条碱基链配对成功示例1输入 ACGT TGCA输出 0import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(\"输入碱基s1 :\"); String s1=scanner.nextLine(); System.out.println(\"输入碱基s2 :\"); String s2= scanner.nextLine(); if(s1.length()!=s2.length()||s1.isEmpty()||s2.isEmpty()){ return; } int count =0; for(int i=0;i&lt;s1.length();i++){ if(!( (s1.charAt(i)=='A' &amp;&amp; s2.charAt(i)=='T') || (s2.charAt(i)=='A' &amp;&amp; s1.charAt(i)=='T') || (s1.charAt(i)=='C' &amp;&amp; s2.charAt(i)=='G') || (s2.charAt(i)=='C' &amp;&amp; s1.charAt(i)=='G') )){ count++; } } System.out.println(count); } }连续整数牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正整数，牛牛现在要猜出所有可能是抹除掉的整数。例如：10 7 12 8 11 那么抹除掉的整数只可能是95 6 7 8 那么抹除掉的整数可能是4也可能是9输入描述:输入包括2行：第一行为整数n(1 &lt;= n &lt;= 50)，即抹除一个数之后剩下的数字个数第二行为n个整数num[i] (1 &lt;= num[i] &lt;= 1000000000)输出描述:在一行中输出所有可能是抹除掉的数,从小到大输出,用空格分割,行末无空格。如果没有可能的数，则输出mistake示例1输入 2 3 6输出 mistakeimport java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"剩下数字个数 ：\"); int n=scanner.nextInt(); int [] num=new int[n]; System.out.println(\"输入剩下数字 :\"); int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; int s=0; for(int i=0;i&lt;n;i++){ num[i]=scanner.nextInt(); s+=num[i]; if(num[i]&lt;min) min=num[i]; if(num[i]&gt;max) max=num[i]; } if(max-min+1 == n){ if(s==(max+min)*n/2){ if(min&gt;1){ System.out.println((min-1)+\" \"+ (max+1)); }else { System.out.println(max+1); } }else { System.out.println(\"mistake!\"); } }else { if(max-min==n){ for(int j=1;j&lt;n;j++){ if(num[j]==num[j-1]){ System.out.println(\"mistake!\"); }else if (num[j]==num[j-1]+2){ System.out.println(num[j]-1); } } }else { System.out.println(\"mistake!\"); } } } }序列和01翻转最长公共连续子串 组装三角形 最小的矩形 字符串分类 优美的回文串 赶去公司 调整队形 集合 涂棋盘 小易记单词 分饼干 买帽子 度度熊回家 寻找三角形 有趣的排序 神奇数 添加字符 数组变换 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"面经-阿里1","slug":"面经-阿里1","date":"2017-07-20T02:10:20.000Z","updated":"2017-08-30T02:22:21.320Z","comments":true,"path":"2017/07/20/mian-jing-a-li-1/","link":"","permalink":"http://zhoudamin.github.io/2017/07/20/mian-jing-a-li-1/","excerpt":"阿里面经总结，查漏补缺~","text":"阿里面经总结，查漏补缺~ Java基础：面向对象和面向过程的区别面向过程就像一个细心的管家，什么事情都要考虑到；而面向对象就像家用电器，只需要知道他的功能，不用知道工作原理。面向过程是一种以事件为中心的编程思想，分析出解决问题所需要的步骤，然后用函数将这些步骤实现，并按顺序调用；面向对象是以对象为中心的编程思想。eg:汽车发动，汽车到站对面向过程来说，这是两个事件，关心的是事件，不是汽车本身，写两个事件函数，分别调用； Java的四个基本特性（抽象、封装、继承，多态）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：通常认为封装就是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装，我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类)；得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应。 多态的理解(实现方法)Overload和Override的区别方法重载–Overload：实现的是编译时的多态性(也称为前绑定)。 方法重写–Override：实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西。 要实现多态需要做两件事：1.方法重写子类继承父类并重写父类中已有的或抽象的方法2.对象造型用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。 项目中对多态的应用举个栗子，在实验室信息管理系统中，有两种用户，教师和学生，两个用户都可以登陆系统，他们有相同的方法Login，但登陆之后他们会进入不同的页面，也就是在登陆时会有不同的操作，两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。 构造器Constructor是否可被override 访问控制符public,protected,private,以及默认的区别 是否可以继承String类 String和StringBuffer、StringBuilder的区别 hashCode和equals方法的关系 抽象类和接口的区别 自动装箱与拆箱 什么是泛型、为什么要使用以及泛型擦除 Java中的集合类及关系图 HashMap实现原理(看源代码) HashTable实现原理(看源代码) HashMap和HashTable区别HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap；HashTable不允许null值(key 和 value都不可以)，HashMap允许null值(key 和 value 都可以)；两者的遍历方式大同小异，HashTable仅仅比HashMap多一个elements方法； HashTable和HashMap都能通过values()方法返回一个Collection，然后进行遍历处理，两者也都可以通过entrySet()方法返回一个Set，然后进行遍历处理。 HashTable使用Enumeration，HashMap使用Iterator。 哈希值的使用不同，HashTable直接使用对象的HashCode，HashMap重新计算hash值，而且用于代替求模；HashTable中hash数组默认大小是11，增加的方式是old*2+1，HashMap中hash数组的默认大小是16，而且一定是2的指数；HashTable基于Dictionary，而HashMap基于AbstractMap类。 HashTable如何实现线程安全(看源代码) ArrayList和vector区别(看源代码) ArrayList和LinkedList区别及使用场景 Collection和Collections的区别 Concurrenthashmap实现原理(看源代码) Error、Exception区别 Unchecked Exception和Checked Exception，各列举几个 Java中如何实现代理机制(JDK、CGLIB) 多线程的实现方式 线程的状态转换 如何停止一个线程 什么是线程安全某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait，sleep，join等控制方式，如果一个类在多线程访问下运转一切正常，并且访问类不需要进行额外的同步处理或协调，那么我们认为它是线程安全的。 如何保证线程安全对变量使用volitate对程序段进行加锁(synchronized,lock) Synchronized如何使用 synchronized和Lock的区别 多线程如何进行信息交互 sleep和wait的区别(考察的方向是是否会释放锁) 多线程与死锁 如何才能产生死锁 什么叫守护线程，用什么方法实现守护线程 Java线程池技术及原理线程池就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 java并发包concurrent及常用的类 volatile关键字 Java中的NIO，BIO，AIO分别是什么 IO和NIO区别 序列化与反序列化 常见的序列化协议有哪些 内存溢出和内存泄漏的区别 Java内存模型及各个区域的OOM，如何重现OOM 出现OOM如何解决 用什么工具可以查出内存泄漏 Java内存管理及回收算法 Java类加载器及如何加载类(双亲委派) xml解析方式 Statement和PreparedStatement之间的区别 JavaEE:servlet生命周期及各个方法①实例化阶段：服务器对Servlet进行实例化，调用Servlet的构造方法②初始化阶段：服务器调用Servlet的init方法进行初始化（只在第一次请求时调用）。③请求处理阶段：服务器调用Servlet的service方法，然后根据请求方式调用相应的doXXX方法。④服务终止阶段：服务器调用Servlet的destroy方法销毁Servlet实例 servlet中如何自定义filter JSP原理 JSP和Servlet的区别 JSP的动态include和静态include Struts中请求处理过程 MVC概念 8.Spring mvc与Struts区别 Hibernate/Ibatis两者的区别 Hibernate一级和二级缓存 Hibernate实现集群部署 Hibernate如何实现声明式事务 简述Hibernate常见优化策略 Spring bean的加载过程(推荐看Spring的源码) Spring如何实现AOP和IOC Spring bean注入方式 Spring的事务管理(推荐看Spring的源码) Spring事务的传播特性 springmvc原理 springmvc用过哪些注解 Restful有几种请求 Restful好处 Tomcat，Apache，JBoss的区别 memcached和redis的区别 有没有遇到中文乱码问题，如何解决的 如何理解分布式锁 你知道的开源协议有哪些 json和xml区别 设计模式：设计模式的六大原则 单一职责原则定义：不要存在多于一个导致类变更的原因。即一个类只负责一项职责。 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 常用的设计模式 用一个设计模式写一段代码或画出一个设计模式的UML 如何理解MVC 高内聚，低耦合方面的理解内聚性又称快内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素联系的越紧密，则它的内聚性就越高。耦合性也称块间联系，指软件系统结构中各模块间相互紧密程度的一种度量。模块间联系越紧密，其耦合性就越强。将软件系统化分模块时，尽量做到高内聚低耦合，提高模块的独立性。有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。 算法： 深度优先、广度优先算法 排序算法及对应的时间复杂度和空间复杂度 写一个排序算法 查找算法 B+树和二叉树查找时间复杂度 KMP算法、hash算法 常用的hash算法有哪些 如何判断一个单链表是否有环？ 给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？ 给你一个数组，如何里面找到和为K的两个数？ 100000个数找出最小或最大的10个？ 一堆数字里面继续去重，要怎么处理？ 数据结构： 队列、栈、链表、树、堆、图 编码实现队列、栈 Linux:linux常用命令 cd命令：切换目录 ls命令：查看文件与目录 grep命令：分析一行的信息 find命令：查找 cp命令：copy，复制文件 mv命令：move ，移动文件，目录或更名 rm命令: 该命令用于删除文件或目录，remove ps命令: 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意 kill命令: 该命令用于向某个工作或者是某个PID（数字）传送一个信号 killall命令: 该命令用于向一个命令启动的进程发送一个信号 file命令: 该命令用于判断接在file命令后的文件的基本数据 tar命令: 该命令用于对文件进行打包 cat命令: 该命令用于查看文本文件的内容，后接要查看的文件名 chgrp命令: 该命令用于改变文件所属用户组 chown命令: 该命令用于改变文件的所有者 chmod命令: 该命令用于改变文件的权限 vim命令: 该命令主要用于文本编辑，它接一个或多个文件名作为参数 gcc命令: 对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序 time命令: 该命令用于测算一个命令（即程序）的执行时间 如何查看内存使用情况 Linux下如何进行进程调度 操作系统： 操作系统什么情况下会死锁 产生死锁的必要条件 死锁预防 数据库： 范式 数据库事务隔离级别 数据库连接池的原理 乐观锁和悲观锁 如何实现不同数据库的数据查询分页 SQL注入的原理，如何预防 数据库索引的实现(B+树介绍、和B树、R树区别) SQL性能优化 数据库索引的优缺点以及什么时候数据库索引失效 10.Redis的存储结构 网络： OSI七层模型以及TCP/IP四层模型 HTTP和HTTPS区别 HTTP报文内容 get提交和post提交的区别 get提交是否有字节限制，如果有是在哪限制的 TCP的三次握手和四次挥手 session和cookie的区别 HTTP请求中Session实现原理 redirect与forward区别 10.DNS TCP和UDP区别 安全： 如果客户端不断的发送请求连接会怎样 DDos攻击 DDos预防 那怎么知道连接是恶意的呢？可能是正常连接 其它： 说一个你参与的项目、其中作为什么角色 遇到最困的问题是什么，怎么解决的 你认为自己有那些方面不足 平常如何学习的 如何评价自己 智力题： 给你50个红球和50个黑球，有两个一模一样的桶，往桶里放球，让朋友去随机抽，采用什么策略可以让朋友抽到红球的概率更高？ 从100个硬币中找出最轻的那个假币？ Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"面经","slug":"面经","permalink":"http://zhoudamin.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://zhoudamin.github.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"阿里","slug":"阿里","permalink":"http://zhoudamin.github.io/tags/%E9%98%BF%E9%87%8C/"}]},{"title":"剑指Offer(51-67)","slug":"剑指Offer(51-67)","date":"2017-07-11T07:33:24.000Z","updated":"2017-07-11T12:19:04.769Z","comments":true,"path":"2017/07/11/jian-zhi-offer-51-67/","link":"","permalink":"http://zhoudamin.github.io/2017/07/11/jian-zhi-offer-51-67/","excerpt":"英文新增面试题！","text":"英文新增面试题！ 题51：数组中重复的数字题目： 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 思路： 1、排序 将数组排序，然后扫描排序后的数组即可。 时间复杂度：O(nlogn)，空间复杂度:O(1) 2、哈希表 从头到尾扫描数组，每扫描到一个数字，判断该数字是否在哈希表中，如果该哈希表还没有这个数字，那么加入哈希表，如果已经存在，则返回该数字； 时间复杂度：O(n)，空间复杂度:O(n) 3、交换 0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置； 从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i， 如果是，则继续扫描下一个数字； 如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置； 重复上述过程，直至找到一个重复的数字； 时间复杂度：O(n)，空间复杂度：O(1) (将每个数字放到属于自己的位置最多交换两次) public class Main{ public static void main(String[] args){ int[] nums={2,3,1,0,2,5,3}; duplicate(nums); } public static void duplicate(int [] nums){ if(nums==null ||nums.length&lt;=0) return; for(int i=0;i&lt;nums.length;i++){ if(nums[i]&gt;nums.length) return ; } for(int i=0;i&lt;nums.length;i++){ while (nums[i]!=i){ if(nums[i]==nums[nums[i]]){ System.out.println(nums[i]); break; } int temp=nums[nums[i]]; nums[nums[i]]=nums[i]; nums[i]=temp; } } } } # 题52：构建乘积数组 题目： 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法 ``` public class Main{ public static void main(String[] args){ int[] nums={1,2,3,4,5}; ConstructAarry(nums); } public static void ConstructAarry(int [] nums){ int [] A =new int [nums.length] ; int [] B =new int [nums.length] ; int [] C =new int [nums.length] ; B[0]=1; C[0]=1; for(int i=1;i&lt;nums.length;i++){ B[i]=B[i-1]*nums[i-1]; C[i]=C[i-1]*nums[nums.length-i]; } for(int i=0;i&lt;nums.length;i++){ A[i]=B[i]*C[nums.length-i-1]; System.out.println(A[i]); } }} &lt;br/&gt; # 题53：正则表达式匹配 题目描述 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但是与\"aa.a\"和\"ab*a\"均不匹配 &lt;br/&gt; # 题54：表示数值的字符串 题目： 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\",\"5e2\",\"-123\",\"3.1416\"和\"-1E-16\"都表示数值。 但是\"12e\",\"1a3.14\",\"1.2.3\",\"+-5\"和\"12e+4.3\"都不是。import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); String str=sc.next(); char [] chr=str.toCharArray(); System.out.println(isNum(chr)); } public static boolean isNum(char [] chr){ if(chr==null) return false; int index=0; if(chr[index]=='+'||chr[index]=='-'){ index++; } if (index==chr.length) return false; boolean num=true; //数有多少个数字 while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } if(index!=chr.length){ if(chr[index]=='.'){ index++; while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } if(index&lt;chr.length&amp;&amp;(chr[index]=='E'||chr[index]=='e')){ num=isExponential(chr,index); }else num=false; } } return num&amp;&amp;index==chr.length; } public static boolean isExponential(char[]chr ,int index){ index++; if(index==chr.length) return false; if(chr[index]=='+'||chr[index]=='-'){ index++; } if(index==chr.length) return false; while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } return index==chr.length? true:false; }} &lt;br/&gt; # 题55：字符流中第一个不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符“google\"时，第一个只出现一次的字符是\"l\"。 输出描述: 如果当前字符流没有存在出现一次的字符，返回#字符。import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); String str=sc.next(); System.out.println( FirstAppearingOnce(str)); } public static char FirstAppearingOnce(String str){ int [] hash=new int [256]; for(int i=0;i&lt;str.length();i++){ hash[str.charAt(i)]++; } int j=0; while (hash[str.charAt(j)]!=1){ j++; } return str.charAt(j); }} ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer(41-50)","slug":"剑指Offer(41-50)","date":"2017-07-11T07:33:07.000Z","updated":"2017-07-12T12:41:21.198Z","comments":true,"path":"2017/07/11/jian-zhi-offer-41-50/","link":"","permalink":"http://zhoudamin.github.io/2017/07/11/jian-zhi-offer-41-50/","excerpt":"","text":"题46：求1+2+3+…+n【题目描述】求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C） import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); int num1=sc.nextInt(); int num2=sc.nextInt(); System.out.println( add(num1,num2)); } public static int add(int num1 ,int num2){ int sum ,carry; do { sum=num1^num2; carry=(num1&amp;num2)&lt;&lt;1; num1=sum; num2=carry; }while (carry!=0); return num1; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer(31-40)","slug":"剑指Offer(31-40)","date":"2017-07-05T06:33:53.000Z","updated":"2017-07-13T11:18:31.898Z","comments":true,"path":"2017/07/05/jian-zhi-offer-31-40/","link":"","permalink":"http://zhoudamin.github.io/2017/07/05/jian-zhi-offer-31-40/","excerpt":"剑指Offer","text":"剑指Offer 题31：连续子数组的最大和题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。例子说明：例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和 18 。 public class Main{ public static void main(String[] args){ int [] arr={1, -2, 3, 10, -4, 7, 2, -5}; System.out.println(bigsum(arr)); } private static boolean flag=true; public static int bigsum(int [] arr){ if(arr==null || arr.length&lt;=0){ flag=false; return 0; } int bigsum=0; int sum=0; for(int i=0;i&lt;arr.length;i++){ if(sum&lt;=0){ sum=arr[i]; }else { sum+=arr[i]; } if(bigsum&lt;sum){ bigsum=sum; } } return bigsum; } } 题32：求从 1 到 n 的整数中 1 出现的次数题目：输入一个整数 n 求从 1 到 n 这 n 个整数的十进制表示中 1 出现的次数。举例说明： 例如输入 12 ，从 1 到 12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。 题33： # 题34： ``` &lt;br/&gt; # 题35：&lt;br/&gt; # 题36：&lt;br/&gt; # 题37：&lt;br/&gt; # 题38：&lt;br/&gt; # 题39：&lt;br/&gt; # 题40：``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer(21-30)","slug":"剑指Offer(21-30)","date":"2017-07-03T03:23:05.000Z","updated":"2017-07-10T08:53:46.886Z","comments":true,"path":"2017/07/03/jian-zhi-offer-21-30/","link":"","permalink":"http://zhoudamin.github.io/2017/07/03/jian-zhi-offer-21-30/","excerpt":"","text":"题21：包含min函数的栈题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，push及pop的时间复杂度都是O(1). public class Main{ private MyStack&lt;Integer&gt; minStack = new MyStack&lt;&gt;(); private MyStack&lt;Integer&gt; dataStack = new MyStack&lt;&gt;(); public void push(Integer item){ dataStack.push(item); if(minStack.length == 0 || item&lt;=minStack.head.data){ minStack.push(item); }else{ minStack.push(minStack.head.data); } } public Integer pop(){ if(dataStack.length == 0 || minStack.length == 0){ return null; } minStack.pop(); return dataStack.pop(); } public Integer min(){ if(minStack.length == 0){ return null; } return minStack.head.data; } public static void main(String[] args){ E21MinInStack test = new E21MinInStack(); test.push(3); test.push(2); test.push(1); System.out.println(test.pop()); System.out.println(test.min()); } } # 题28：字符串的排列 题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 ``` public class Main { public static void main(String[] args){ permutation(\"abc\"); } public static void permutation(String str){ int count=0; if(str==null){ return; } char [] chs=str.toCharArray();//将字符串转换为字符数组 int point=0; System.out.print(chs); System.out.print(“ “); count++; char temp1=chs[point]; chs[point]=chs[++point]; chs[point]=temp1; while (!String.valueOf(chs).equals(str)){ System.out.print(chs); System.out.print(“ “); count++; if(point==chs.length-1){ char temp=chs[point]; chs[point]=chs[0]; chs[0]=temp; point=0; }else { char temp=chs[point]; chs[point]=chs[++point]; chs[point]=temp; } } System.out.println(count); }} &lt;br/&gt; # 题29：数组中出现次数超过一半的数组 题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出null。public class Main { public static void main(String[] args){ int [] array={1,2,3,2,2,2,5,4,2}; System.out.println(morethanhalfnumber(array)); } public static Integer morethanhalfnumber(int [] array){ int count=1; int temp=array[0]; for(int i=1;i&lt;array.length;i++){ if(temp==array[i]){ count++; }else { count--; if(count==0){ temp=array[i]; count++; } } } int count1=0; for(int i=0;i&lt;array.length;i++){ if(array[i]==temp){ count1++; } } return count1&gt;=array.length/2 ? temp:null; }} &lt;br/&gt; # 题30：最小的k个数 题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。import java.util.ArrayList;import java.util.TreeSet; public class Main { public static void main(String[] args){ int [] array={4,5,1,6,2,7,3,8}; int k=4; System.out.println(MinKnumber(array,k)); } public static ArrayList&lt;Integer&gt; MinKnumber(int [] array, int k){ if(array==null) return null; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(k); if(k&gt;array.length) return list; TreeSet&lt;Integer&gt; tree=new TreeSet&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++){ tree.add(array[i]); } int i=0; for (Integer elem:tree){ if(i&gt;k-1) break; list.add(elem); i++; } return list; }} ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"Efounds笔试","slug":"Efounds笔试","date":"2017-06-24T03:38:56.000Z","updated":"2018-04-25T03:34:43.221Z","comments":true,"path":"2017/06/24/efounds-bi-shi/","link":"","permalink":"http://zhoudamin.github.io/2017/06/24/efounds-bi-shi/","excerpt":"Efounds的笔试~","text":"Efounds的笔试~ 1.比较两个浮点数大小 一般不会直接用“==”或者“!=”对两个浮点数进行比较。 判断两个浮点数float a 与 float b 是否相等可以根据他们的差的绝对值是否大于0来进行判断。 判断相等： if（Math.abs(a-b)&lt;=0）{相等} 或者 if（!Math.abs(a-b)&gt;0）{相等} 判断不等： if（Math.abs(a-b)&gt;0）{不相等} 2，用最快排序找到无序的数组里第K大的数 public class AlgCode { public static void main(String[] args) { // int [] nums={5, 7, 1, 8,3, 10}; //测试 int [] nums= {3,1,4,7,5,8,0}; int k=5; int res= findKth(nums,0,nums.length-1,k-1); System.out.print(\"The Kth is: \"+res); } private static int findKth(int [] data ,int first , int last ,int k){ int kth; if(first==last) kth=data[first]; else { int pivot = data[first]; int splitPoint = partition(data, first, last); if (k &lt; splitPoint) kth = findKth(data, first, splitPoint - 1, k); else if(k&gt;splitPoint) kth = findKth(data, splitPoint + 1, last, k); else kth = pivot; } return kth; } private static int partition(int [] data ,int first , int last){ int pivot = data[first]; while(first&lt;last) { while (first &lt; last &amp;&amp; data[last] &gt; pivot) last--; data[first] = data[last]; while (first &lt; last &amp;&amp; data[first] &lt; pivot) first++; data[last] = data[first]; } data[first]=pivot; return first; } }3，单链表是否有环并如何找到环入口首先要了解什么叫环，如图，Join.next-&gt;Pos，Pos.next-&gt;Join，那么该链表有环 public class LinkedLoop{ //内部静态类定义结点类 static class Node{ int val; Node next; public Node(int val){ this.val = val; } } //判断单链表是否有环 public static boolean hasLoop(Node head){ Node p1=head; //指向头节点 Node p2=head.next; //指向下一个节点 while(p2!=null &amp;&amp;p2.next!=null){ p1=p1.next; p2=p2.next.next; if(p2==null){ return false; } int val1=p1.val; int val2=p2.val; if(val1==val2) return true; } return false; } public static void main(String [] args){ Node n1=new Node(1); Node n2=new Node(3); Node n3=new Node(6); Node n4=new Node(4); Node n5=new Node(5); Node n6=new Node(10); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; n5.next = n6; n6.next = n5; System.out.println(hasLoop(n1)); } }4，快排第一次排列后的顺序 int [] nums= {3,1,4,7,5,8,0}; 如果基准为3； 第一次快排后: nums={0,1,3,7,5,8,4}; 5，Java 数据输入 int a =0; Scanner input = new Scanner(System.in); System.out.println(\"输入数字:\"); a = input.nextInt();6，软件生命周期 软件生命周期(SDLC，Systems Development Life Cycle,SDLC)是软件的产生直到报废或停止使用的生命周期。软件生存周期包括： 一，问题定义。要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。 二，可行性研究。一方面在于把待开发的系统的目标以明确的语言描述出来，另一方面从经济、技术、法律等多方面进行可行性分析。 三，需求分析。弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。 四，开发阶段。开发阶段由三个阶段组成：1，设计2，实现：根据选定的程序设计语言完成源程序的编码。3，测试 五，维护：维护包括四个方面1，改正性维护：在软件交付使用后，由于开发测试时的不彻底、不完全、必然会有一部分隐藏的错误被带到运行阶段，这些隐藏的错误在某些特定的使用环境下就会暴露。2，适应性维护：是为适应环境的变化而修改软件的活动。3，完善性维护 ：是根据用户在使用过程中提出的一些建设性意见而进行的维护活动。4，预防性维护：是为了进一步改善软件系统的可维护性和可靠性，并为以后的改进奠定基础。 7,多线程和多进程的区别a.进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。 b.进程有独立的地址空间，比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的，比如在windows中用_begin threadex创建一个新进程就会在调用CreateThread的同时申请一个专属于线程的数据块（_tiddata)。 c.线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。 d.由b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。 e.线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。 8,多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明 所谓同步，表示有先有后，比较正式的解释是“线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。” 所谓互斥，比较正式的说明是“线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。”表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。 举个例子，设有一个全局变量global，为了保证线程安全，我们规定只有当主线程修改了global之后下一个子线程才能访问global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问global的时候另一个线程不能访问global，那么就需要互斥。 9,网络协议：访问某个网址都经过了哪些协议·域名解析协议DNS应用层协议，网址相当于是域名，访问DNS服务器，这个过程有域名解析协议，解析出域名对应的IP地址。 ·超文本传输协议HTTP应用层协议，基于请求和响应的协议，通过请求行、消息报头、请求正文向目的地址发送请求。目的服务器在接受请求后，返回一个状态行、消息报头、响应正文的响应。 ·传输控制协议TCP传输层协议，HTTP协议是基于TCP协议的，也就是说HTTP无论是请求还是响应都是把HTTP的内容作为TCP的正文封装到TCP的报文中的。TCP协议是传输安全，面向连接的协议，在客户端和服务端建立TCP/IP五层模型的协议 连接的过程中需要经过三次握手，发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一端执行被动打开，以及四次释放的过程才停止发送数据。 ·网际协议IP协议IP协议在整个传输过程中都起着重要的作用，网址通过DNS解析为IP地址，在TCP建立连接以及传输数据的整个过程中都在使用着IP协议。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://zhoudamin.github.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"Java之查找算法","slug":"Java之查找算法","date":"2017-06-22T02:57:01.000Z","updated":"2018-07-26T15:29:16.128Z","comments":true,"path":"2017/06/22/java-zhi-cha-zhao-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2017/06/22/java-zhi-cha-zhao-suan-fa/","excerpt":"用Java实现一些基本查找算法。","text":"用Java实现一些基本查找算法。 Search for a Range描述Given a sorted array of integers, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n) .If the target is not found in the array, return [-1, -1] .For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4] .分析已经排好了序，用二分查找。重新实现 lower_bound 和 upper_boundSearch for a Range // Search for a Range // 重新实现 lower_bound 和 upper_bound // 时间复杂度O(logn)，空间复杂度O(1) public class Solution{ private static int[] searchRange(int [] nums,int target){ int lower=lower_bound(nums,0,nums.length,target); int high=upper_bound(nums,0,nums.length,target); if(lower == nums.length || nums[lower]!=target) return new int[]{-1,-1}; else return new int[]{lower,high-1}; } private static int lower_bound(int [] A , int first ,int last ,int target){ while(first!=last){ int mid=(first+last)/2; if(target&gt;A[mid]) first=++mid; else last=mid; } return first; } private static int upper_bound(int [] A , int first ,int last ,int target){ while(first!=last){ int mid=(first+last)/2; if(target&gt;=A[mid]) first=++mid; //找到最远边界 else last=mid; } return first; } }Search Insert Position描述Given a sorted array and a target value, return the index if the target is found. If not, return the indexwhere it would be if it were inserted in order.You may assume no duplicates in the array.Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0分析即 std::lower_bound() 。 public static int searchInsert(int [] nums , int target){ int first=0; int last=nums.length; while(first!=last){ int mid=(first+last)/2; if(target&gt;nums[mid]) first=mid+1; else last=mid; } return first; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"Java实现常见排序算法","slug":"Java实现常见排序算法","date":"2017-06-21T08:44:12.000Z","updated":"2017-06-27T01:59:45.933Z","comments":true,"path":"2017/06/21/java-shi-xian-chang-jian-pai-xu-suan-fa/","link":"","permalink":"http://zhoudamin.github.io/2017/06/21/java-shi-xian-chang-jian-pai-xu-suan-fa/","excerpt":"一些常见的排序算法实现！","text":"一些常见的排序算法实现！ ·查找算法典型的二分查找对于二分查找算法要求, 查找前的数据必须是已经排好序的, 然后得到数组的开始位置start和结束位置end, 取中间位置mid的数据a[mid]跟待查找数据key进行比较, 若 a[mid] &gt; key, 则取end = mid - 1; 若 a[mid] &lt; key, 则取start = mid + 1; 若 a[mid] = key 则直接返回当前mid为查找到的位置. 依次遍历直到找到数据或者最终没有该条数据. public static int binarySearch(int [] nums , int key ){ int start =0; int end = nums.length-1; while(start&lt;end){ int mid = (end+start)/2; if(nums[mid]&gt;key){ end=mid-1; }else if(nums[mid]&lt;key){ start=mid+1; }else{ return mid; } } return -1; }·插入排序插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入稳定，时间复杂度 O(n^2) public static void insertSort(int [] a){ for(int i=2 ; i&lt; a.length ;i++ ){ if(a[i]&lt;a[i-1]){ a[0]=a[i]; a[i]=a[i-1]; int j=0; for(j= i-2;a[j]&gt;a[0];j--){ a[j+1]=a[j]; } a[j+1]=a[0]; } } }·选择排序选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。 不稳定, 时间复杂度 O(n^2) public static void selectSort(int [] a){ for(int i=1 ; i&lt;a.length ;i++){ int j=selectMinKey(a,i); if(i!=j){ swap(a,i,j); } } } private static int selectMinKey(int [] a, int i){ int key=i; for(int j=i+1;j&lt;a.length;j++){ if(a[j]&lt;a[key]){ key=j; } } return key; }·冒泡排序冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。 稳定，时间复杂度 O(n^2) public static void bubbleSort(int [] a){ for(int i=0;i&lt;a.length-1;i++){ for(int j=i;j&lt;a.length;j++){ if(a[j+1]&lt;a[j]){ swap(a,j+1,j); } } } }·快速排序不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n^2) 快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。 public static void quickSort(int [] a,int low ,int high){ int pivotLoc=0;//中心点 if(low&lt;high){ pivotLoc=partitionLoc(a,low,high); quickSort(a,low,pivotLoc-1); quickSort(a,pivotLoc+1,high); } } //获取到a的下标 low ~ high 中, a[low]的应该放的位置, 即左边的数 &lt; a[low] 右边的数 &gt; a[low] private static int partitionLoc(int [] a,int low ,int high){ a[0]=a[low]; while(low&lt;high){ while(low&lt;high &amp;&amp; a[high]&gt;a[0]){ high--; } a[low]=a[high]; while( low &lt; high &amp;&amp; a[low]&lt;=a[0]){ low++; } a[high] = a[low]; } a[low]=a[0]; return low; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"算法总结","slug":"算法总结","date":"2017-04-24T08:15:30.000Z","updated":"2017-05-03T02:35:40.839Z","comments":true,"path":"2017/04/24/suan-fa-zong-jie/","link":"","permalink":"http://zhoudamin.github.io/2017/04/24/suan-fa-zong-jie/","excerpt":"一些常用算法分类总结","text":"一些常用算法分类总结 1.字符串 ·字符串(String) 通常把它作为字符数组 java : String内置类型，不可更改，要更改的话可考虑转StringBuffer, StringBuilder, char []之类 Java: ［0..65535] ·和数组相关，内容广泛 概念理解：字典序 简单操作：插入、删除字符，旋转 规则判断 （罗马数字转换 是否是合法的整数、浮点数） 数字运算（ 大数加法、二进制加法） 排序、交换 （partition过程） 字符计数（hash)：变位词 匹配 （正则表达式、全串匹配、KMP、周期判断） 动态规划 (LCS、编辑距离、最长回文子串） 搜索 （单词变换、排列组合） 总结： ·我理解的in-place (原地） 本身O(1)空间 递归，堆栈空间可以不考虑 ·原地相关的问题 字符串循环左移、右移动 快排partition相关 ·滑动窗口 能达到O(n)的的时间复杂度 O(1)的空间复杂度 ·规则相关——细致 ·匹配 （暴力）：KMP比较少见 ·Manacher——要求比较高的笔试2.数组 ·数组(array) java : [], ArrayList 数组下标是一种特殊的hash…做计数 理解数组与map 给数组“顺序” ·查找和排序 二分查找 元素交换 排序，中位数 归并 位运算 前缀和的应用 ·动态规划 ·排列组合 总结： ·利用序 理解二分查找 ·利用前缀和 查找、计算、排序 ·理解数组 map ·用数组实现高级数据结构 一般树： 存每个节点的父亲 （并查集） 二叉树： 下标从1开始a[i]的儿子是a[i * 2]和a[i * 2 + 1] (堆） ·抓住简单题 分治法求逆序对数 有序数组归并 两个有序数组的中位数 两头扫的方法 （2-SUM, 3-SUM)3.栈和队列简介： 堆栈和队列统称线性表 简单的线性结构 数组和链表可以实现这两种数据结构 堆栈 后进先出 (Last In First Out) 队列 先进先出 (First In First Out) 面试题总体分析： 堆栈 基本理解 DFS 深度优先——按深度遍历 递归转非递归 队列 基本理解 BFS 广度优先——按层序遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"}]},{"title":"上交会防伪展总结","slug":"上交会防伪展总结","date":"2017-04-24T07:38:49.000Z","updated":"2017-04-24T07:47:31.107Z","comments":true,"path":"2017/04/24/shang-jiao-hui-fang-wei-zhan-zong-jie/","link":"","permalink":"http://zhoudamin.github.io/2017/04/24/shang-jiao-hui-fang-wei-zhan-zong-jie/","excerpt":"防伪，是企业在目前社会诚信缺失、假冒伪劣商品扰乱企业正常经营和损害企业、消费者利益的情况下，为保护企业品牌、保护市场、保护广大消费者合法权益而采取的一种防范性技术措施。","text":"防伪，是企业在目前社会诚信缺失、假冒伪劣商品扰乱企业正常经营和损害企业、消费者利益的情况下，为保护企业品牌、保护市场、保护广大消费者合法权益而采取的一种防范性技术措施。 这次博览会主要学习到了几类防伪技术： 激光防伪材料用特殊材料做成全息图案，达到人眼辨别真假的目的，如恒大冰泉的瓶盖贴标；缺点：全息材料防伪技术发展很成熟，防伪材料容易被仿制。 纸张防伪纸张防伪技术主要用于纸币、贵重物品包装防伪。该防伪技术关键在于复制印刷版的难度大。该技术首先需要根据需求图案刻板，然后印刷出有图案的纸张，用该纸张印刷纸币或者用该纸张包装商品，以达到防伪目的，难点在于，如果没有源板，无法印刷出相同图案的纸张，如果按照纸张图案仿制印刷板，难度很大。 三阖追溯提出该方案的公司为珠海三纬码信息技术有限公司，该技术主要服务对象为中高端产品，流程如下：1）首先生产厂家对每一个产品提供一个编号和密码，编号存入二维码中，密码存入系统数据库中。然后物流信息根据扫描二维码得到商品编号存入数据库中。2）当商品到达专卖店时，专卖店扫描二维码入库，可以从系统得到编号以及密码；3）当客户去专卖店买该商品时，专卖店根据系统查询编号，给客户密码，客户可根据二维码中的编号和密码去官网查询，如果编号和密码正确，则显示该商品所有信息，信息包括商品信息、商品状态及溯源信息；4）当专卖店出售该商品时，扫描二维码会传递信息回到系统，将商品状态：待售改为售出！故该商品无法再二次销售，避免了掉包商品二次销售的风险！ 公众号扫描防伪用公司公众号扫描商品二维码，进入页面溯源，优点是公司公众号是唯一的，从公众号进入，避免了进入假页面的风险！该方案是为了解决一般溯源扫描二维码进入假页面，欺骗消费者的风险！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"防伪","slug":"防伪","permalink":"http://zhoudamin.github.io/categories/%E9%98%B2%E4%BC%AA/"}],"tags":[{"name":"二维码防伪","slug":"二维码防伪","permalink":"http://zhoudamin.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%98%B2%E4%BC%AA/"}]},{"title":"链表","slug":"链表","date":"2017-04-13T09:40:39.000Z","updated":"2017-04-14T07:50:22.340Z","comments":true,"path":"2017/04/13/lian-biao/","link":"","permalink":"http://zhoudamin.github.io/2017/04/13/lian-biao/","excerpt":"链表基础总结。","text":"链表基础总结。 1.遍历 for(Node x=first ; x!=null ; x=x.next){ //处理x.item }2.定义链表 private class Data{ private object obj; private Data next=null; Data(Object obj){ this.obj=obj; } }3.首节点为空 private Data first=null;4.insertFirst ： 在表头插入一个新的链接点，时间复杂度为O(1) public void insertFirst(Object obj){ Data data=new Data(obj); data.next=first; first=data; }5.deleteFirst :删除表头首节点，时间复杂度为O(1) public Object deleteFirst() throws Exception{ if(first==null){ throw new Exception(\"empty!\"); } Data temp=first; first=first.next; return temp.obj; }6.find: 查找包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N) public Object find (Object obj) throws Exception{ if(first ==null){ throw new Exception(\"LinkedList is empty!\"); } Data cur=first; while (cur!=null){ if(cur.obj.equals(obj)){ return cur.obj; } cur=cur.next; } return null; }7.remove ：删除包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N) public void remove(Object obj) throws Exception{ if(first == null) throw new Exception(\"LinkedList is empty!\"); if(first.obj.equals(obj)){ first=first.next; }else{ Data pre = first; Data cur = first.next; while(cur!=null){ if(cur.obj.equals(obj)){ pre.next=cur.next; } pre=cur; cur=cur.next; } } }8.isEmpt public boolean isEmpty(){ return (first==null); }9.打印链表 public void display(){ if(first==null) System.out.println(\"empty\"); Data cur=first; while(cur!=null){ System.out.print(cur.obj.toString()+\"-&gt;\"); cur=cur.next; } System.out.print(\"\\n\"); }10.删除指定节点 public void deleteNode(ListNode node) { if(node!=null&amp;&amp;node.next!=null){ node.val=node.next.val; node.next=node.next.next; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://zhoudamin.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Algorithms code","slug":"Algorithms-code","date":"2017-04-03T03:37:50.000Z","updated":"2018-04-25T03:34:31.616Z","comments":true,"path":"2017/04/03/algorithms-code/","link":"","permalink":"http://zhoudamin.github.io/2017/04/03/algorithms-code/","excerpt":"一些值得回看的小算法。","text":"一些值得回看的小算法。 最长的连续子数组子数组数字不重复 int [] arr={1,2,3,4,7}; //输出4 int [] arr1={1,2,3,4,1,2,3,4,5,1}; //输出5 package RecursiveAndDynamic; /** * Created by zdmein on 2017/9/2. * 最长的连续子数组（子数组数字不重复） * int [] arr={1,2,3,4,7}; 输出4 * int [] arr1={1,2,3,4,1,2,3,4,5,1}; 输出5 */ public class longestSubArr1 { public static void main(String [] args){ int [] arr={1,2,3,4,7}; int [] arr1={1,2,3,4,1,2,3,4,5,1}; longestSubArr(arr1); } public static void longestSubArr(int [] arr){ if(arr==null||arr.length==0){ return; } int len=1; int maxlen=1; for(int i=1;i&lt;arr.length;i++){ if(arr[i]==arr[i-1]+1){ len++; maxlen=Math.max(len,maxlen); }else { len=1; } } System.out.println(maxlen); } } 删除链表中的元素样例给出链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3, 和 val = 3, 你需要返回删除3之后的链表：1-&gt;2-&gt;4-&gt;5。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) { // Write your code here if(head==null) return head; ListNode p=head,q=head.next; while(q!=null){ if(q.val==val){ p.next=q.next; q=q.next; }else{ p=p.next; q=q.next; } } if(head.val==val) head=head.next; return head; } }求n的阶乘结果后有几个零//结果后的零是由n中的5组成的，多少个5就有多少个0，所以只需要统计有多少5就可以了 public class Solution { public int trailingZeroes(int n) { int rs=0; while(n!=0){ rs+=n/5; n/=5; } return rs; } } 统计小于n的素数个数我写的用 n/2;改进为 Math.sqrt(n)；复杂度还是高了点； public class Solution { public int countPrimes(int n) { boolean [] notPrimes = new boolean[n]; int count =0; for(int i=2;i&lt;n;i++){ if(notPrimes[i]==false){ count++; for(int j=2;i*j&lt;n;j++){ notPrimes[i*j]=true; } } } return count; } }这个算法降低了复杂度，值得学习！！ 同构字符串Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true.即结构相同我的 public class Solution { public boolean isIsomorphic(String s, String t) { int [] count=new int [s.length()]; for(int i=0;i&lt;s.length();i++){ count[i]=s.charAt(i)-t.charAt(i); for(int j=0;j&lt;i;j++){ if(s.charAt(i)==s.charAt(j)){ if(count[i]!=count[j]){ return false; } } if(t.charAt(i)==t.charAt(j)){ if(count[i]!=count[j]){ return false; } } } } return true; } }降低复杂度,用数组装字符，很重要的思想！ public class Solution { public boolean isIsomorphic(String s, String t) { int [] m=new int [256]; int [] n=new int [256]; for(int i=0;i&lt;s.length();i++){ if(m[s.charAt(i)]!=n[t.charAt(i)]){ return false; } m[s.charAt(i)]=i+1; //关键部分，通过i，实现错位 n[t.charAt(i)]=i+1; //不同位置加的值不同 } return true; } }组合成最大的数given [3, 30, 34, 5, 9], the largest formed number is 9534330.[0,0]，输出0. public class Solution { public String largestNumber(int[] nums) { String [] rs=new String[nums.length]; String sb=new String(); for(int i=0;i&lt;nums.length;i++){ rs[i]=String.valueOf(nums[i]); } for(int j=0;j&lt;nums.length-1;j++){ for(int i=0;i&lt;nums.length-j-1;i++){ String s1=rs[i]+rs[i+1]; String s2=rs[i+1]+rs[i]; if(s2.compareTo(s1)&gt;0){ String temp=rs[i]; rs[i]=rs[i+1]; rs[i+1]=temp; } } } for(int i=0;i&lt;nums.length;i++){ sb+=rs[i]; } if(sb.charAt(0) == '0') return \"0\"; return sb; } }判断n是不是2的幂只需要将n转化为二进制，然后计算二进制位里面有多少个1，如果计数为1，那么n是2的幂 快乐数写一个算法来判断一个数是不是”快乐数”。 一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。 您在真实的面试中是否遇到过这个题？ Yes样例19 就是一个快乐数。 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 public class Solution { /** * @param n an integer * @return true if this is a happy number or false */ public boolean isHappy(int n) { // Write your code here Set&lt;Integer&gt; inLoop = new HashSet&lt;Integer&gt;(); int squareSum,remain; while (inLoop.add(n)) { squareSum = 0; while (n &gt; 0) { remain = n%10; squareSum += remain*remain; n /= 10; } if (squareSum == 1) return true; else n = squareSum; } return false; } }Add BinaryGiven two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”. package leetCode; public class Temp { public static void main(String [] args) { String a=\"11\"; String b=\"1\"; System.out.print(addBinary(a,b)); } public static String addBinary(String a, String b) { if(a == null || a.isEmpty()) return b; if(b == null || b.isEmpty()) return a; StringBuilder stb = new StringBuilder(); int i = a.length() - 1; int j = b.length() - 1; int aBit; int bBit; int carry = 0; int result; while(i &gt;= 0 || j &gt;= 0 || carry == 1) { aBit = (i &gt;= 0) ? Character.getNumericValue(a.charAt(i--)) : 0; bBit = (j &gt;= 0) ? Character.getNumericValue(b.charAt(j--)) : 0; result = aBit ^ bBit ^ carry; carry = ((aBit + bBit + carry) &gt;= 2) ? 1 : 0; stb.append(result); } return stb.reverse().toString(); } } 徒手开平方·牛顿法-直线逼近原理 package leetCode; public class Temp { public static void main(String [] args) { int a=7; System.out.print(mySqrt(a)); } public static int mySqrt(int x) { long rs=x; while(rs*rs&gt;x){ rs=(rs+x/rs)/2; } return (int)rs; } } # 数学之美 —— 0x5f375a86float InvSqrt(float x){ float xhalf = 0.5fx; int i = *(int)&amp;x; // get bits for floating VALUE i = 0x5f375a86- (i&gt;&gt;1); // gives initial guess y0 x = (float)&amp;i; // convert bits BACK to float x = x(1.5f-xhalfx*x); // Newton step, repeating increases accuracy return x;} # 两数字字符串相加 Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.package leetCode; public class Temp{ public static void main(String [] args) { String a=”1001”; String b=”1341”; System.out.print(addStrings(a,b)); } public static String addStrings(String num1, String num2) { StringBuilder sb=new StringBuilder(); int carry=0; for(int i=num1.length()-1,j=num2.length()-1;i&gt;=0||j&gt;=0||carry==1;i--,j--){ int x=i&lt;0?0:num1.charAt(i)-'0'; int y=j&lt;0?0:num2.charAt(j)-'0'; sb.append((x+y+carry)%10); carry=(x+y+carry)/10; } return sb.reverse().toString(); }} # 字符串中出现多少字母 存一下有多少个非0次出现的int nonZero = 0; for (int i = 0; i &lt; lenb; ++i) if (++num[b[i] – ‘a’] == 1) ++nonZero; `` 12.单词翻转 ``翻转句子中全部的单词，单词内容不变例如I’m a student. 变为student. a I’m in-place翻转 字符串第i位到第j位while (i &lt; j) swap(s[i++], s[j–]);有什么用？翻转整个句子 ： .tneduts a m’I每个单词单独翻转： student. a I’m难点？ 如何区分单词？找空格，split # HashSet public static int[] intersection(int[] nums1, int [] nums2){ Set set= new HashSet&lt;&gt;(); Set interset=new HashSet&lt;&gt;(); for(int i=0;i&lt;nums1.length;i++){ set.add(nums1[i]); //存入不重复的值 } for(int i=0;i&lt;nums2.length;i++){ if(set.contains(nums2[i])){ //如果重复上个set数组里的值 interset.add(nums2[i]); //添加上个数组里有的值 } } int [] res=new int [interset.size()]; int i=0; for(Integer num:interset){ res[i++]=num; } return res; }} # 350. Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 先排序，一个一个对比，相等的才存，不等就小的数组指针加1。 public static int[] intersection(int[] nums1, int [] nums2){ Arrays.sort(nums1); Arrays.sort(nums2); int p1=0; int p2=0; ArrayList myList= new ArrayList (); while((p1&lt;nums1.length)&amp;&amp;(p2&lt;nums2.length)){ if(nums1[p1]&lt;nums2[p2]){ p1++; }else{ if(nums1[p1]&gt;nums2[p2]){ p2++; }else{ myList.add(nums1[p1]); p1++; p2++; } } } int[] res= new int [myList.size()]; for(int i=0;i&lt;res.length;i++){ res[i]=myList.get(i); //ArrayList取值方法 } return res; //转化成正常数组输出 } # 将字符数组转化为字符串 public static String reverseString(String s) { char [] rs= new char[s.length()]; for(int i=0;i&lt;s.length();i++){ rs[i]=s.charAt(i); } for(int i=0;i&lt;s.length()/2;i++){ char temp=rs[i]; rs[i]=rs[s.length()-i-1]; rs[s.length()-i-1]=temp; } return new String(rs); //转化 } # 不用加号实现两数相加public int getSum(int a, int b) { return b == 0 ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);} 合并排序数组合并两个排序的整数数组A和B变成一个新的数组。 给出A=[1,2,3,4]，B=[2,4,5,6]，返回** [1,2,2,3,4,4,5,6]** public class Solution { /* * @param A: sorted integer array A * @param B: sorted integer array B * @return: A new sorted integer array */ public int[] mergeSortedArray(int[] A, int[] B) { // write your code here int indexA=0; int indexB=0; int []C =new int [A.length+B.length]; int indexC=0; while(indexA!=A.length &amp;&amp; indexB!=B.length) { if (A[indexA] &lt; B[indexB]) { C[indexC++]=A[indexA++]; }else if (A[indexA] > B[indexB]) { C[indexC++]=B[indexB++]; }else { C[indexC++]=A[indexA++]; C[indexC++]=B[indexB++]; } } if(indexA==A.length &amp;&amp; indexB!=B.length){ for(int i=indexB;i&lt;B.length;i++){ C[indexC++]=B[i]; } } if(indexA!=A.length &amp;&amp; indexB==B.length){ for(int i=indexA;i&lt;A.length;i++){ C[indexC++]=A[i]; } } return C; } } 写代码：多线程实现从A,B,C三个文件中读取文件放到D文件中，优化：如何同步实现。 写一个单例模式，什么时候用到在某些情况下，有些对象只需要一个就可以了，即每个类只需要一个实例。单例模式的作用就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。实现一个单例模式： public class Test{ private Test(){} private static Test uniqueInstance = new Test(); public static Test getInstence(){ return uniqueInstance; } } 由于在使用前就创建好了对象，因此，可以在多线程环境下使用这种方法。 装饰者模式是什么，举例装饰者模式通过组合的方式扩展对象的特性，这种方式允许我们在任何时候对对象的功能进行扩展，甚至是运行时扩展，而若我们用继承来完成对类的扩展，则只能在编译阶段实现，所以在某些时候装饰者模式比继承更灵活。 特征： 装饰者和被装饰者的对象有着共同的超类 我们可以用多个装饰者修饰一个对象 可以用修饰过的对象替代代码中的原对象 一个对象在任何时候都可以被装饰，甚至是运行时 应用场景：一家奶茶店，一杯奶茶是10元；如果加糖+2、加奶+3、加葡萄+5元…如果写类去继承，会要写n多个如果用装饰就直接在类里加价钱 return mTea.getPrice()+2; return mTea.getPrice()+15; return mTea.getPrice()+20; ----- mTea = new SimpleTea(); mTea = new SugarDecorator(mTea); mTea = new MilkDecorator(mTea); int price1 = mTea.getPrice(); System.out.println(\"price1=\"+price1); 写代码：找出字符数组中第一次只出现三次的字符package Array; /** * Created by zdmein on 2017/9/6. * 找出字符数组中第一次只出现三次的字符 思路： 1、统计各字符出现次数 2、遍历字符串，如果出现字符次数为3则输出该字符并跳出循环；否则如果不存在则输出\" . \" */ public class ThreeChar1 { public static void main(String [] args){ String str=\"abesabjdwsjibuhfrsadfesdsferewh\"; char [] chars=str.toCharArray(); ThreeChar(chars); } public static void ThreeChar(char [] chars){ if(chars==null||chars.length==0){ System.out.println(\".\"); } int [] res=new int[256]; for(int i=0;i&lt;chars.length;i++){ res[chars[i]]++; } for(int i=0;i&lt;chars.length;i++){ if(res[chars[i]]==3){ System.out.println(chars[i]); break; } } } } 验证身份证是否正确身份证号码验证 1、号码的结构 公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码， 八位数字出生日期码，三位数字顺序码和一位数字校验码。 2、地址码(前六位数） 表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按GB/T2260的规定执行。 3、出生日期码（第七位至十四位） 表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。 4、顺序码（第十五位至十七位） 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号， 顺序码的奇数分配给男性，偶数分配给女性。 5、校验码（第十八位数） （1）十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 （2）计算模 Y = mod(S, 11) （3）通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 功能：身份证的有效验证 网易笔试：一个合法的括号匹配 给一个合法的括号匹配序列s，找到同样长的所有的括号匹配序列t， 1.t和s不同，但是长度相同 2.t也合法 3.LCS（s,t） 是满足上面两个条件的t中最大的。 eg: s=”(())()” 匹配的有： “()(())”、”((()))”、”()()()”、”(()())” 其中 LCS（”(())()”,”()(())”）为4，其余都是5，所以输出3 package ProgrammingWritten; import java.util.ArrayList; import java.util.HashMap; import java.util.Map.Entry; import java.util.Scanner; /** * Created by zdmein on 2017/9/10. */ public class NetEase1 { public static int cnt; public static HashMap&lt;String,Integer> map = new HashMap&lt;>(); public static void main(String[] args) { HashMap&lt;Integer,Integer> map2 = new HashMap&lt;>(); Scanner input = new Scanner(System.in); String str1 = input.nextLine(); // int n = Integer.parseInt(str); int n2 = str1.length(); int n = (int) n2 / 2; // StringBuffer bf = new StringBuffer(\"\"); // String str1 = bf.append(str).reverse().toString(); // n += Integer.parseInt(str1); // System.out.println(n); ArrayList&lt;String> list = getBracketsOfN(n); for (String str2 : list) { if (str1.equals(str2)) { continue; }else { int[][] re = longestCommonSubsequence(str1, str2); cnt=0; print(re, str1, str2, str1.length(), str2.length()); map.put(str2, cnt); } } for (Entry&lt;String, Integer> entry : map.entrySet()) { if (map2.containsKey(entry.getValue())) { int count=map2.get(entry.getValue()); map2.put(entry.getValue(), ++count); } else { map2.put(entry.getValue(), 1); } } int result = 0; int max= 0; for(Entry&lt;Integer, Integer> entry : map2.entrySet()) { if (max&lt;entry.getKey()) { result = entry.getValue(); } } System.out.println(result); } /** * Given the number N, return all of the correct brackets. * * @param n * @return */ @SuppressWarnings(\"unchecked\") public static ArrayList&lt;String> getBracketsOfN(int n) { @SuppressWarnings(\"rawtypes\") ArrayList[] dp = new ArrayList[n + 1]; for (int i = 0; i &lt; dp.length; i++) dp[i] = new ArrayList&lt;String>(); dp[0].add(\"\"); dp[1].add(\"()\"); if (n == 0) return dp[0]; if (n == 1) return dp[1]; int count = 2; while (count &lt; n + 1) { ArrayList&lt;String> lcount = dp[count]; for (int i = 0; i &lt; count; i++) { ArrayList&lt;String> l1 = dp[i]; ArrayList&lt;String> l2 = dp[count - i - 1]; for (int j = 0; j &lt; l1.size(); j++) { for (int k = 0; k &lt; l2.size(); k++) { StringBuffer sb = new StringBuffer(); sb.append(l1.get(j)); sb.append(\"(\"); sb.append(l2.get(k)); sb.append(\")\"); lcount.add(sb.toString()); } } } dp[count++] = lcount; } return dp[n]; } // 假如返回两个字符串的最长公共子序列的长度 public static int[][] longestCommonSubsequence(String str1, String str2) { int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵 // 初始化边界条件 for (int i = 0; i &lt;= str1.length(); i++) { matrix[i][0] = 0;//每行第一列置零 } for (int j = 0; j &lt;= str2.length(); j++) { matrix[0][j] = 0;//每列第一行置零 } // 填充矩阵 for (int i = 1; i &lt;= str1.length(); i++) { for (int j = 1; j &lt;= str2.length(); j++) { if (str1.charAt(i - 1) == str2.charAt(j - 1)) { matrix[i][j] = matrix[i - 1][j - 1] + 1; } else { matrix[i][j] = (matrix[i - 1][j] >= matrix[i][j - 1] ? matrix[i - 1][j] : matrix[i][j - 1]); } } } return matrix; } //根据矩阵输出LCS public static void print(int[][] opt, String X, String Y, int i, int j) { if (i == 0 || j == 0) { return; } if (X.charAt(i - 1) == Y.charAt(j - 1)) { print(opt, X, Y, i - 1, j - 1); cnt++; // System.out.print(X.charAt(i - 1)); } else if (opt[i - 1][j] >= opt[i][j]) { print(opt, X, Y, i - 1, j); } else { print(opt, X, Y, i, j - 1); } } } 滴滴笔试：求解第n个丑数我们把只包含因子2,3和5的数称为丑数（Ugly Number),求从小到大的顺序第n的丑数，例如6,8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第1个丑数 package ProgrammingWritten; import java.util.Scanner; /** * Created by zdmein on 2017/9/10. */ public class didi2 { public static void main(String args[]) { Scanner cin = new Scanner(System.in); int n = cin.nextInt(); System.out.println(getugly(n)); } public static int getugly(int n) { if(n==0) return 0; int[] a = new int[n]; int count = 1; a[0] = 1; int num2 = 0; int num3 = 0; int num5 = 0; while(count&lt;n){ int min = min(a[num2]*2,a[num3]*3,a[num5]*5); a[count] = min; while(a[num2]*2&lt;=a[count]) num2++; while(a[num3]*3&lt;=a[count]) num3++; while(a[num5]*5&lt;=a[count]) num5++; count++; } int result = a[n-1]; return result; } public static int min(int a,int b,int c){ int tmp = a>b?b:a; return tmp>c?c:tmp; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"剑指Offer(11-20)","slug":"剑指Offer(11-20)","date":"2017-03-26T15:20:11.000Z","updated":"2017-07-03T03:22:15.915Z","comments":true,"path":"2017/03/26/jian-zhi-offer-11-20/","link":"","permalink":"http://zhoudamin.github.io/2017/03/26/jian-zhi-offer-11-20/","excerpt":"关于剑指Offer的一些解题思路","text":"关于剑指Offer的一些解题思路 题11：数值的整数次方实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 import java.util.Scanner; public class Main { public static void main(String[] args)throws Exception { Scanner sc=new Scanner(System.in); double n=sc.nextDouble(); int exp=sc.nextInt(); System.out.println(power(n,exp)); } public static double power(double base ,int exponent)throws Exception{ if(equal(base,0.0) &amp;&amp; exponent&lt;0){ throw new Exception(\"0的负次数幂无意义\"); // 1/0 没意义 } if(exponent&lt;0){ return 1.0/powerWithExponent(base,-exponent); }else { return powerWithExponent(base,exponent); } } public static double powerWithExponent(double base , int exponent){ if(base==0) return 1; if(exponent==1) return base; double res =1; for(int i=0;i&lt;exponent;i++){ res=res*base; } return res; } public static boolean equal(double base , double none){ if((base-none&gt;-0.0000001)&amp;&amp;base-none&lt;0.0000001){ //在0附近，误差0.0000001 return true; }else { return false; } } } # 题12：打印1到最大的n位数 输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3 一直到最大的3位数即999。 ``` &lt;br/&gt; # 题13： &lt;br/&gt; # 题14：调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。public class Main { public static void main(String[] args)throws Exception { int[] array = {1, 4, 2, 5, 21, 67, 21, 66, 23, 77, 68}; for (int i = 0; i &lt; array.length; i++) { System.out.println(order(array)[i]); } } public static int [] order(int [] array){ if(array.length==0||array==null) return array; int start=0; int end=array.length-1; while (start&lt;end){ while (start&lt;end &amp;&amp; !isEven(array[start])){ start++; } while (start&lt;end&amp;&amp; isEven(array[end])){ end--; } if(start&lt;end){ int temp=array[start]; array[start]=array[end]; array[end]=temp; } } return array; } public static boolean isEven(int n){ return n%2==0; }} &lt;br/&gt; # 题15：链表中倒数第k个结点 题目：输入一个链表，输出该链表中倒数第k 个结点．为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾结点是倒数第 1 个结点．例如一个链表有 6 个结点，从头结点开始它们的值依次是 1 、2、3、4、5 、6。这个个链表的倒数第 3 个结点是值为 4 的结点。public class Main { public static void main(String[] args){ ListNode head=new ListNode(); ListNode second=new ListNode(); ListNode third= new ListNode(); ListNode forth=new ListNode(); head.next=second; second.next=third; third.next=forth; head.val=1; second.val=2; third.val=3; forth.val=4; System.out.println(findKToTail(head,3).val); } public static ListNode findKToTail(ListNode head , int k){ if (head==null&amp;&amp;k==0){ return null; } int count=0; ListNode resNode = new ListNode(); ListNode headNode=head; while (headNode!=null){ headNode=headNode.next; count++; } for(int i=0;i&lt;=count-k;i++){ head=head.next; } return head.next; } public static class ListNode{ int val; ListNode next; }} &lt;br/&gt; # 题16：反转链表 &lt;br/&gt; # 题17：合并两个排序的链表 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的 `递归的方法真是好用`public class Main { public static void main(String[] args){ ListNode head1=new ListNode(); ListNode second1=new ListNode(); ListNode third1= new ListNode(); ListNode forth1=new ListNode(); head1.next=second1; second1.next=third1; third1.next=forth1; head1.val=1; second1.val=5; third1.val=8; forth1.val=13; ListNode head2=new ListNode(); ListNode second2=new ListNode(); ListNode third2= new ListNode(); ListNode forth2=new ListNode(); head2.next=second2; second2.next=third2; third2.next=forth2; head2.val=2; second2.val=4; third2.val=7; forth2.val=9; ListNode resNode=mergeList(head1,head2); while (resNode!=null) { System.out.println(resNode.val); resNode = resNode.next; } } public static ListNode mergeList(ListNode head1 , ListNode head2){ if(head1==null){ return head2; } if(head2==null){ return head1; } ListNode mergeNode=null; if(head1.val&lt;head2.val){ mergeNode=head1; mergeNode.next=mergeList(head1.next,head2); }else { mergeNode=head2; mergeNode.next=mergeList(head1,head2.next); } return mergeNode; } public static class ListNode{ int val; ListNode next; }} &lt;br/&gt; # 题18：树的子结构 &lt;br/&gt; # 题19：二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } }*/public class Solution { public void Mirror(TreeNode root) { if(root==null ) return ; TreeNode temp; temp=root.left; root.left=root.right; root.right=temp; Mirror(root.left); Mirror(root.right); }} &lt;br/&gt; # 题20：顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.import java.util.ArrayList;public class Solution { public ArrayList printMatrix(int [][] matrix) { if (matrix == null) return null; ArrayList result = new ArrayList(); int start = 0; while(matrix[0].length &gt; start *2 &amp;&amp; matrix.length &gt; start *2){ printMatrixInCircle(matrix,result,start); start++; } return result; } public static void printMatrixInCircle(int [][]matix,ArrayList&lt;Integer&gt;result,int start){ int endX = matix[0].length - start -1; int endY = matix.length - start -1; //从左向右打印一行 for(int i = start;i &lt;=endX;i++){ result.add(matix[start][i]); } //从上到下 for(int i = start+1; i &lt;=endY;i++) result.add(matix[i][endX]); //从右到左 if(start &lt; endX &amp;&amp;start &lt; endY) for(int i = endX -1;i&gt;= start;i--) result.add(matix[endY][i]); //从下到上 if(start &lt; endX &amp;&amp; start &lt; endY-1) for(int i = endY - 1;i &gt;=start+1;i--) result.add(matix[i][start]); } } ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"网易笔试","slug":"网易笔试","date":"2017-03-26T12:32:34.000Z","updated":"2017-03-26T12:52:16.772Z","comments":true,"path":"2017/03/26/wang-yi-bi-shi/","link":"","permalink":"http://zhoudamin.github.io/2017/03/26/wang-yi-bi-shi/","excerpt":"网易2017年校招","text":"网易2017年校招 java1.下厨房每组输入多行，每行有多种食材，求每组共多少食材，用hashtable不添加重复的特性解决。 import java.util.Hashtable; import java.util.Scanner; public class 下厨房{ public static void main(String [] args){ Scanner sc=new Scanner(System.in); Hashtable&lt;String,Integer&gt; set = new Hashtable&lt;String .Integer&gt;(); while(sc.hasNext()){ String str = sc.next(); set.put(str,1); } System.out.println(set.size()); } }注：在Iterator类中，我们经常用到两个方法：hasNext(),next()。具体含义：next(),是返回当前元素，并指向下一个元素。 hasNext(),是判断当前元素是否存在，并指向下一个元素（即索引）。 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"网易","slug":"网易","permalink":"http://zhoudamin.github.io/tags/%E7%BD%91%E6%98%93/"}]},{"title":"麻省理工：算法导论-分治法--上课笔记","slug":"麻省理工：算法导论-上课笔记","date":"2017-03-14T12:35:35.000Z","updated":"2017-03-16T04:24:18.058Z","comments":true,"path":"2017/03/14/ma-sheng-li-gong-suan-fa-dao-lun-shang-ke-bi-ji/","link":"","permalink":"http://zhoudamin.github.io/2017/03/14/ma-sheng-li-gong-suan-fa-dao-lun-shang-ke-bi-ji/","excerpt":"学习麻省理工算法导论的笔记。","text":"学习麻省理工算法导论的笔记。 分治：步骤：1、分2、治 3、合并 实例：一、归并排序：1、将排序数组一分为二2、将两个子数组排序3、合并两个有序子数组 二、二分查找：在一个有序数组中查找x1、先将x和有序数组中间的数比较2、再将x和左或右子数组的中间的数比较3、done 三、乘方问题：求x的n次方1、分解 x^n= x^(n/2)*x^(n/2) n为偶 x^((n-1)/2)*x^((n-1)/2)*x n为奇 ``` 2、先求两边乘(子算法规模为n/2)，再乘一起 算法时间为O(lg n) 四、斐波那契数列问题：{ 0 ; n=0Fn= | 1 ; n=1 { F(n-1)+F(n-2) 这是个指数级问题，然而可以用朴素平方递归来降低到O(lg n){ F2 F1 } = ( 1 1 ){ F1 F0 } ( 1 0 ) { Fn+1 Fn } = { Fn Fn-1 }( 1 1 ) = ( 1 1 )^n-1 * ( 1 1 ) =( 1 1 )^n{ Fn Fn-1 } { Fn-1 Fn-2 }( 1 0 ) ( 1 0 ) ( 1 0 ) ( 1 0 ) ``` $\\LaTeX$ _ss This expression $\\sqrt{3x-1}+(1+x)^2$ is an example of a $\\LaTeX$ inline equation. he Lorenz Equations: $$\\begin{aligned}\\dot{x} &amp; = \\sigma(y-x) \\\\dot{y} &amp; = \\rho x - y - xz \\\\dot{z} &amp; = -\\beta z + xy\\end{aligned}$$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"公开课","slug":"公开课","permalink":"http://zhoudamin.github.io/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"}]},{"title":"快速排序","slug":"快速排序","date":"2017-03-12T09:06:27.000Z","updated":"2017-09-28T07:02:29.414Z","comments":true,"path":"2017/03/12/kuai-su-pai-xu/","link":"","permalink":"http://zhoudamin.github.io/2017/03/12/kuai-su-pai-xu/","excerpt":"选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。","text":"选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 Java代码实现 package Sort; import java.util.Arrays; /** * Created by zdmein on 2017/9/27. * 快排 */ public class quickSort1 { public static void main(String[] args) { int[] testData = {49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int[] dataSorted = quickSort(testData, 0, testData.length-1); for(int a : dataSorted) { System.out.print(a + \" \"); } } /** * 快速排序 */ private static int partition(int[] data, int low, int high) { int key = data[low]; while(low &lt; high) { while(low&lt;high &amp;&amp; data[high]>=key) { high--; } data[low] = data[high];//(此时因low=high或data[high]&lt;key)将high下标处的数赋给low下标处的数，保证data[low]&lt;key while(low&lt;high &amp;&amp; data[low]&lt;=key) { low++; } data[high] = data[low];//(此时因low=high或data[low]>key)将low下标处的数赋给high下标处的数，保证data[high]>key } data[low] = key; return low; } public static int[] quickSort(int[] data, int low, int high) { if(low &lt; high) { int result = partition(data, low, high); quickSort(data, low, result-1);//对low到result-1下标间数进行排序 quickSort(data, result+1, high);//对result+1到high下标间数进行排序 } return data; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://zhoudamin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-03-12T03:31:43.000Z","updated":"2017-03-12T03:34:37.469Z","comments":true,"path":"2017/03/12/mou-pao-pai-xu/","link":"","permalink":"http://zhoudamin.github.io/2017/03/12/mou-pao-pai-xu/","excerpt":"自下往上对相邻的两个数进行比较和调整Key：大的数往下沉，小的数往上浮","text":"自下往上对相邻的两个数进行比较和调整Key：大的数往下沉，小的数往上浮 Java实现 package algorithms4th; public class BubbleSort { public static void main(String [] args){ int a []={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; for(int j=0;j&lt;a.length-1;j++){ for(int i=a.length-1;i&gt;j;i--){ if(a[i]&lt;a[i-1]){ int temp=a[i]; a[i]=a[i-1]; a[i-1]=temp; } } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://zhoudamin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2017-03-12T02:48:27.000Z","updated":"2017-03-12T02:50:14.809Z","comments":true,"path":"2017/03/12/xi-er-pai-xu/","link":"","permalink":"http://zhoudamin.github.io/2017/03/12/xi-er-pai-xu/","excerpt":"基本思想：算法先要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。","text":"基本思想：算法先要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 Math.ceil()是常见编程语言中的常用代码,ceil() 方法执行的是向上取整计算，它返回的是大于或等于函数参数，并且与之最接近的整数。 Java代码实现 package algorithms4th; public class ShellSort { public static void main (String []args){ int a []={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; double d1=a.length; while(true){ d1=Math.ceil(d1/3); int d=(int)d1; for(int x=0;x&lt;d;x++){ for(int j=(int) (x+d);j&lt;a.length;j+=d){ int i=(int) (j-d); if(a[i]&gt;a[j]){ temp=a[j]; a[j]=a[i]; a[i]=temp; } } } if(d==1){ break; } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://zhoudamin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"直接插入排序","slug":"直接插入排序","date":"2017-03-08T13:47:48.000Z","updated":"2017-03-11T13:53:51.122Z","comments":true,"path":"2017/03/08/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"http://zhoudamin.github.io/2017/03/08/zhi-jie-cha-ru-pai-xu/","excerpt":"基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。","text":"基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 Java代码实现 package algorithms4th; public class InsertSort { public static void main (String [] args){ int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; for(int i=1;i&lt;a.length;i++){ for(int j=i-1;j&gt;0;j--){ if(a[j]&lt;a[j-1]){ temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://zhoudamin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]}],"categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"},{"name":"开发者手册","slug":"开发者手册","permalink":"http://zhoudamin.github.io/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"编程语言","slug":"编程语言","permalink":"http://zhoudamin.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"观点与感想","slug":"观点与感想","permalink":"http://zhoudamin.github.io/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://zhoudamin.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"理解计算机","slug":"理解计算机","permalink":"http://zhoudamin.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"云计算","slug":"云计算","permalink":"http://zhoudamin.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Notes","slug":"Notes","permalink":"http://zhoudamin.github.io/categories/Notes/"},{"name":"图像","slug":"图像","permalink":"http://zhoudamin.github.io/categories/%E5%9B%BE%E5%83%8F/"},{"name":"Life","slug":"Life","permalink":"http://zhoudamin.github.io/categories/Life/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhoudamin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面经","slug":"面经","permalink":"http://zhoudamin.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/categories/Java/"},{"name":"读书","slug":"读书","permalink":"http://zhoudamin.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"防伪","slug":"防伪","permalink":"http://zhoudamin.github.io/categories/%E9%98%B2%E4%BC%AA/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhoudamin.github.io/tags/leetcode/"},{"name":"Apollo","slug":"Apollo","permalink":"http://zhoudamin.github.io/tags/Apollo/"},{"name":"Java","slug":"Java","permalink":"http://zhoudamin.github.io/tags/Java/"},{"name":"随想","slug":"随想","permalink":"http://zhoudamin.github.io/tags/%E9%9A%8F%E6%83%B3/"},{"name":"AI","slug":"AI","permalink":"http://zhoudamin.github.io/tags/AI/"},{"name":"算法与数学","slug":"算法与数学","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"},{"name":"观点与感想","slug":"观点与感想","permalink":"http://zhoudamin.github.io/tags/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"},{"name":"Notes","slug":"Notes","permalink":"http://zhoudamin.github.io/tags/Notes/"},{"name":"Java 二维码","slug":"Java-二维码","permalink":"http://zhoudamin.github.io/tags/Java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"HTTP","slug":"HTTP","permalink":"http://zhoudamin.github.io/tags/HTTP/"},{"name":"云计算","slug":"云计算","permalink":"http://zhoudamin.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Hexo","slug":"Hexo","permalink":"http://zhoudamin.github.io/tags/Hexo/"},{"name":"博主","slug":"博主","permalink":"http://zhoudamin.github.io/tags/%E5%8D%9A%E4%B8%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhoudamin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码","slug":"源码","permalink":"http://zhoudamin.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"笔试","slug":"笔试","permalink":"http://zhoudamin.github.io/tags/%E7%AC%94%E8%AF%95/"},{"name":"腾讯","slug":"腾讯","permalink":"http://zhoudamin.github.io/tags/%E8%85%BE%E8%AE%AF/"},{"name":"基础","slug":"基础","permalink":"http://zhoudamin.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://zhoudamin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://zhoudamin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"开发者手册","slug":"开发者手册","permalink":"http://zhoudamin.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"Java程序员面试笔试宝典","slug":"Java程序员面试笔试宝典","permalink":"http://zhoudamin.github.io/tags/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"书籍","slug":"书籍","permalink":"http://zhoudamin.github.io/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"算法","slug":"算法","permalink":"http://zhoudamin.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"http://zhoudamin.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"面试","slug":"面试","permalink":"http://zhoudamin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"阿里","slug":"阿里","permalink":"http://zhoudamin.github.io/tags/%E9%98%BF%E9%87%8C/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://zhoudamin.github.io/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"二维码防伪","slug":"二维码防伪","permalink":"http://zhoudamin.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%98%B2%E4%BC%AA/"},{"name":"链表","slug":"链表","permalink":"http://zhoudamin.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"网易","slug":"网易","permalink":"http://zhoudamin.github.io/tags/%E7%BD%91%E6%98%93/"},{"name":"公开课","slug":"公开课","permalink":"http://zhoudamin.github.io/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"排序","slug":"排序","permalink":"http://zhoudamin.github.io/tags/%E6%8E%92%E5%BA%8F/"}]}